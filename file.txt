POWERPOINTS:


```markdown
# SENG 365 Week 1
## Intro to Web Computing Architectures

[Icon: Lightbulb]

---

## Outline
[Icon: Yellow circle bullet points]
*   What are Web Applications
*   Course outline
*   HTTP
*   JavaScript

---

## What is a web application?
[Icon: Planet with stars and rocket in a yellow circle]

---

## What is a web application?
[Icon: Planet with stars and rocket in a yellow circle]

What makes an application a web application rather than desktop application or a mobile application, or an embedded application, or …?

---

### What is a web application? Consider…
[Icon: Thumbtack in a yellow circle]
[Icon: Yellow circle bullet points]
*   TradeMe
*   Gmail running in Chrome or equivalent
*   Gmail app running on Android or iOS
*   Facebook running in a browser
*   Office 365
*   DropBox, Google Drive, …

---

### It’s 2005…
[Icon: Gears in a yellow circle]

The iPhone wasn’t launched until 2007.
V for Vendetta was showing at cinemas …
… Star Wars: Episode III - Revenge of the Sith

[Image: Screenshot of "The Million Dollar Homepage" website from 2005, displayed on a laptop screen. The page is a dense grid of tiny advertisements.]

---

### … and now
[Image: Screenshot of a browser showing a "404 Not Found" error for www.milliondollarhomepage.com/buy.php. The text "php!" is above the screenshot. Below it, "but what's this? /buy.php An API endpoint...?" is written.]

The internet fad of 2005 now stands as a stark demonstration of 'link rot’ & ‘system decay’.
22% of the links were dead by 2014
http://www.theguardian.com/technology/2014/mar/27/after-nine-years-the-million-dollar-homepage-dead (March 2014)

For a history of the site, see Wikipedia:
https://en.wikipedia.org/wiki/The_Million_Dollar_Homepage

---

## Why take a course on web application architecture?
[Icon: Number 1 in a yellow circle]

---

[Image: Screenshot of a Prezzi card first time login page. It shows fields for "Enter Card Number" and "CVV2". An error message at the bottom reads "Date Of Birth Field cannot be left Blank". A sad face icon is below this.]

---

### Challenges for modern web applications
[Icon: Gear in a yellow circle]
*   Consume services from another system
*   Provide services to another system
*   Modularize my application (to manage complexity)
*   Respond to multiple overlapping (asynchronous) requests
*   Make changes persistent (for large, distributed systems)
*   Allow and restrict user access (security and privacy)
*   Display information from a source
*   Synchronize information shown on different views
*   Maximize responsiveness
*   Adapt to different devices and screen sizes
*   Protect user data from being harvested
*   Protect my business from harm (prevent exploits)

---

### Reference model
[Icon: Network/molecule in a yellow circle]

[Diagram:
User (Human) interacts with Client (Machine) containing HTML, CSS, JS (with APIs).
Client communicates via HTTP & REST with Server (Machine).
Server uses Express, Node.js (Headless browser) and has an API.
Data (JSON, XML,...) and Resources (HTML, CSS, JavaScript, ...) are exchanged.
Server queries Database (Machine) (Relational, Not-only relational Object) using SQL and gets Results (data).
]
**User:** Human
**HTTP client:** Machine
**HTTP Server:** Machine
**Database:** Machine

---

## Course administration
[Icon: Number 2 in a yellow circle]
**Teaching team, Course requirements, Assignments**

---

### Teaching team
[Icon: User profile in a yellow circle]

**Ben Adams**
Lecturer and Course Coordinator
Erskine 314
benjamin.adams@canterbury.ac.nz

**Kush Desai**
Tutor

**Lachlan Stewart**
Tutor

---

### Overview of lecture topics
[Icon: Thumbtack in a yellow circle]

**Term 1**
*   **Week 1 & 2:** HTTP, JS & asynchronous flow
*   **Week 3:** TypeScript and Data persistence
*   **Week 4:** HTTP Servers and APIs
*   **Week 5:** GraphQL, API Testing
*   **Week 6:** Security, Client-side basics
*   **Week 7:** Single Page Applications

**Term 2**
*   **Week 8 & 9:** React
*   **Week 10:** Communication with server, performance
*   **Week 11:** Web storage, Progressive web apps
*   **Week 12:** Testing, Review

---

### Assessment
[Icon: Thumbtack in a yellow circle]

**The Assessments**
*   **Assignment 1 (25%)**
    *   No extension
*   **Assignment 2 (25%)**
    *   No extension
*   **Final Exam (50%)**

**Additional information and requirements**
*   Assignment resources on Learn
*   API specification with skeleton project
*   Infrastructure
    *   eng-git project
    *   MySQL database
    *   Postman tests

---

### Assignment 1 - API Server
[Icon: Thumbtack in a yellow circle]

**HTTP server + application**
*   HTTP request & response cycle
*   URL e.g. protocol, path, endpoints, query parameters
*   HTTP headers and body
*   Headers: e.g. Cookies
*   Headers: e.g. CORS
*   Body e.g. JSON data
*   HTTP methods e.g. GET, PUT, DELETE
*   HTTP status codes e.g. 201, 404

**And also**
*   Authentication and authorization
*   Asynchronous requests
*   Database connectivity
*   Conform to API specification
    *   You will be given an API specification to implement

---

### Assignment 2 - Client front-end
[Icon: Thumbtack in a yellow circle]

**HTTP client**
*   HTML + CSS + JS app
*   Modern browser
*   Implementing user story backlog

**And also**
*   Authentication and authorization
*   Asynchronous requests
*   RESTful API calls

---

### Labs
[Icon: Thumbtack in a yellow circle]

**Term 1**
*   **Week 1:** 3 x pre-labs
*   **Week 2:** Lab 1
*   **Week 3 & 4:** Lab 2
*   **Week 5 & 6:** assignment support
*   **Week 7:** Lab 3

**Term 2**
*   **Week 8:** Lab 4
*   **Week 9:** Lab 5
*   **Week 10 & 11:** assignment support
*   **Week 12:** assignment 2 testing (**attendance mandatory!**)

---

## The HTTP protocol
[Icon: Number 3 in a yellow circle]

[Diagram: Simplified version of the reference model focusing on Client (HTML, CSS, JS, APIs) and Server (Express, Node.js, API) communicating via HTTP & REST.]
**Client** **Server**

---

### Protocol Layers
[Icon: Yellow circle]

[Diagram: OSI Model Layers stacked, from Physical (1) to Application (7)]
1.  **PHYSICAL LAYER** - Transmits raw bit stream over the physical medium
2.  **DATALINK LAYER** - Defines the format of data on the network
3.  **NETWORK LAYER** - Decides which physical path the data will take
4.  **TRANSPORT LAYER** - Transmits data using transmission protocols including TCP and UDP
5.  **SESSION LAYER** - Maintains connections and is responsible for controlling ports and sessions
6.  **PRESENTATION LAYER** - Ensures that data is in a usable format and is where data encryption occurs
7.  **APPLICATION LAYER** - Human-computer interaction layer, where applications can access the network services

**HTTP** is at the Application Layer.

---

### Overview to HTTP
[Icon: Thumbtack in a yellow circle]

HTTP messages are how data is exchanged between a server and a client.
There are two types of messages: requests sent by the client to trigger an action on the server, and responses, the answer from the server.

HTTP messages are composed of textual information encoded in ASCII*, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection.
https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages
(* There’s a bit more to it than just ASCII…)

---

### Uniform Resource Identifiers
[Icon: Yellow circle]

[Diagram: Venn diagram showing URI as the overarching set. URN (e.g., dmn.tld/page.htm, ste.org/img.png) and URL (e.g., https://dmn.tld/page.htm, ftp://ste.org/file.pdf) are subsets. `data.htm` is shown as a URI that might be a URN but not necessarily a URL.]

*   **URI (Uniform Resource Identifier)**
    String of characters to identify (name, or name and location) resource
*   **URL (Uniform Resource Locator)**
    A URI that also specifies the means of acting upon, or obtaining representation. That is, a URI with access mechanism and location
*   **URN (Uniform Resource Name)**
    Deprecated: historical name for URI.

---

### Your server needs to handle URLs like:
**http://www.example.com:80/path/to/myfile.html?key1=val1&key2=val2#Somewhere**

---

#### The protocol
**http**://www.example.com:80/path/to/myfile.html?key1=val1&key2=val2#Somewhere

---

#### The domain name
http://**www.example.com**:80/path/to/myfile.html?key1=val1&key2=val2#Somewhere

---

#### The port
http://www.example.com:**80**/path/to/myfile.html?key1=val1&key2=val2#Somewhere
*   The default **HTTP** port is **80**
*   The default **HTTPS** port is **443**
*   The port on which your HTTP server listens for requests is a different port to the port to which the server issues queries to the MySQL database (default: 3306)

---

#### The path
http://www.example.com:80/**path/to/myfile.html**?key1=val1&key2=val2#Somewhere
*   The path is increasingly an abstraction, not a ‘physical path’ to a file location.
*   A path to an HTML file is not (quite) the same thing as the path to an API endpoint
*   An API endpoint uses the standard URI path structure to achieve something different
    *   In particular, parameter information
*   The path may need to include information on the version of the API

---

#### An example API endpoint path
...80/**api/v1/students/:id**?key1=val1...
*   The path contains versioning: **api/v1/**
*   There’s an API endpoint: **students**
*   The path contains a variable in the path itself: **:id**
    *   How are these path variables handled by the server…?
*   You may still pass query parameters: **?key1=val1**
    *   Given the path variable, query parameters may be redundant for the endpoint
    *   There is also the body of the HTTP request for passing information

---

#### Query parameters and other parameters
http://www.example.com:80/path/to/myfile.html**?key1=val1&key2=val2**#Somewhere

The API could be designed to accept parameter information via
*   The URI’s **? query parameters**
*   The URI’s path (see previous slide/s) e.g. **:id**
*   The body of the HTTP request e.g. JSON
*   Or via some combination of the above
*   What goes in query parameters, in the path, and in the body?

---

#### # anchors
http://www.example.com:80/path/to/myfile.html?key1=val1&key2=val2**#Somewhere**
*   Anchors used as ‘bookmarks’ within a classic HTML webpage
    *   i.e. point to a ‘subsection’ of the page
*   We don’t need to use anchors for our API requests
    *   (Being creative, you might…?!? )

---

### HTTP Headers
[Icon: Thumbtack in a yellow circle]

**Distinguish between**
*   **General headers** required
*   **Entity headers** (apply to the body of the request)

**And between**
*   **Request** headers
*   **Response** headers

**Cookies are implemented in/with the header**
*   **Set-Cookie: <...>** (in the header of the server’s HTTP response)
*   **Cookie: <...>** (in the header of subsequent client HTTP requests)

**Use headers to**
*   Maintain **session**
*   **Personalise**
*   **Track** (e.g. advertising)

---

### Structure and example of HTTP requests
[Icon: Thumbtack in a yellow circle]

HTTP requests are of form:
`HTTP-method SP Request-URL SP HTTP-Version CRLF`
`*(Header CRLF)`
`CRLF`
`Request Body`

**Example GET (no body):**
`GET /pub/blah.html HTTP/1.1`
`Host: www.w3.org`

**Example POST (with indication of body):**
`POST /pub/blah2.php HTTP/1.1`
`Host: www.w3.org`
`Body of post (e.g. form fields)`

**KEY:**
`SP` = space
`CRLF` = carriage return, line feed (`\r\n`)

---

### HTTP verbs
[Icon: Thumbtack in a yellow circle]
*   GET
*   PUT
*   POST
*   DELETE
*   HEAD
*   Others

---

### Structure and example of HTTP responses
[Icon: Thumbtack in a yellow circle]

HTTP responses are of form
`HTTP-Version SP Status-Code SP Reason-Phrase CRLF`
`*(Header CRLF)`
`CRLF`
`Response Body`

**Typical successful response (GET or POST):**
`HTTP/1.1 200 OK` <--- Headers
`Date: Mon, 04 Jul 2011 06:00:01 GMT`
`Server: Apache`
`Accept-Ranges: bytes`
`Content-Length: 1240`
`Connection: close`
`Content-Type: text/html; charset=UTF-8`
<--- Space
`<Actual HTML>` <--- Body...

---

### Response codes
[Icon: Thumbtack in a yellow circle]
**1xx, informational (rare)**
*   e.g. 100 continue
**2xx, success**
*   e.g. 200 OK, 201, Created, 204 No Content
**3xx, redirections**
*   e.g. 303 See Other, 304 Not Modified
**4xx, client error (lots of these)**
*   e.g. 400 Bad Request, 404 Not Found
**5xx, server error**
*   e.g. 500 Internal Server Error, 501 Not Implemented

---

## JavaScript
[Icon: Number 4 in a yellow circle]
https://www.learn-js.org/

---

### JavaScript in the Browser
[Icon: Yellow circle]
*   Runs in a **web browser** (Chrome, Firefox, Edge)
*   Executes in a **sandboxed environment** for security
*   Primarily used for **UI interactions** and **handling user events**
*   Has access to **Web APIs** (e.g., fetch, localStorage, document)
    *   More on these in **Term 2**
*   **Limited access** to system resources for security reasons
*   Can make **network requests** but **cannot directly access files or databases**

---

### JavaScript on the Server
[Icon: Yellow circle]
*   Runs in JavaScript engine **outside browser** (Node.js, Deno, Bun)
*   Can interact with **file systems, databases, and networks**
*   Uses non-blocking I/O for **handling multiple requests efficiently**
*   Has access to **server-side modules** (e.g., **fs** for file handling, **http** for server creation)
*   Can execute **background tasks** without user interaction
*   Requires implementing specific **security measures**

---

### The JavaScript way of programming
[Icon: Jigsaw puzzle pieces in a yellow circle]

**Highlights**
*   Scoping
*   Variables
*   Objects, methods & functions
*   Destructuring arrays and objects
*   Expressions, statements and declarations
*   Functions
*   Immediately invoked function expressions (IIFE)
*   Variable hoisting
*   Closures
*   this

**Next week**
*   Method chaining (cascading)
*   'use strict'; mode
*   Modularisation: **export** & **require()**
*   Node.js
*   Asynchronous (event) handling
*   Callbacks, Promises, Async/Await

---

### Scoping
[Icon: Thumbtack in a yellow circle]

**Block scope (Java, C#, C/C++)**
```java
public void foo() {
    if (something){
        int x = 1;
    }
}
// x is available only in the if () {} block
```

**Lexical scope (JavaScript, R)**
```javascript
function foo () {
    if (something) {
        var x = 1;
    }
}
// x is available to the foo function (and any of foo’s inner functions)
```

---

### Evolving JavaScript language ES6
[Icon: Thumbtack in a yellow circle]

**Examples of JS variables**
`a = 1; //undeclared`
`var b = 1;`

**New in ES6**
`let c = 1;`
`const d = 1;`

**Undeclared variables shouldn’t be used in code**
But they can be, unless you use **'use strict';**
**Always declare a variable**
**var** is lexically-scoped
**let** is block-scoped
**const** is block-scoped, and can’t be changed

---

### Variable hoisting
[Icon: Thumbtack in a yellow circle]
```javascript
function foo () {
    // x hoisted here
    if (something) {
        let x = 1;
    }
}
```
Variable declarations in a function are hoisted (pulled) to the top of the function.
*   **Not** variable assignment
Invoking functions before they’re declared works using hoisting
*   **Note:** doesn’t work when assigning functions

---

### Objects and methods
[Icon: Thumbtack in a yellow circle]
*   JavaScript is an **object-oriented** programming language
    *   Not as strict as Java, in its definition of objects e.g. not compulsory to have classes
*   An **object** is a collection of properties
*   A **property** is an association between a name (or **key**) and a **value**.
    *   A property can itself be an object.
*   A **method** is a function associated with an object; or, alternatively, a method is a property (of an object) that is a function.

---

### Destructuring arrays
[Icon: Yellow circle]
**Destructure array**
```javascript
const animals = ["Kiwi", "Kea", "Tuatara"];
// Extract values
const [bird, parrot, reptile] = animals;

console.log(bird); // "Kiwi"
console.log(parrot); // "Kea"
console.log(reptile); // "Tuatara"
```

**Destructure array with default assignment**
```javascript
const [first = "Kākāpō", second = "Pūkeko"] = ["Takahē"];

console.log(first); // "Takahē"
console.log(second); // "Pūkeko"
```

---

### Destructuring objects
[Icon: Yellow circle]
**Destructure object**
```javascript
const city = { name: "Wellington", population: 215000, knownFor: "Windy weather" };
// Extract values
const { name, population, knownFor } = city;

console.log(name); // "Wellington"
console.log(population); // 215000
console.log(knownFor); // "Windy weather"
```

**Rename properties**
```javascript
const cityInfo = { name: "Auckland", population: 1600000, nickname: "City of Sails" };
const { name: cityName, population: cityPopulation, nickname } = cityInfo;

console.log(cityName); // "Auckland"
console.log(cityPopulation); // 1600000
console.log(nickname); // "City of Sails"
```

---

### Destructuring objects in function parameters
[Icon: Yellow circle]
```javascript
function describeAnimal({ name, habitat }) {
  console.log(`The ${name} is found in ${habitat}.`);
}

const animal = { name: "Yellow-eyed Penguin", habitat: "Otago Peninsula" };
describeAnimal(animal); // "The Yellow-eyed Penguin is found in Otago Peninsula."
```

---

### Functions
[Icon: Thumbtack in a yellow circle]
*   Functions are **first-class objects**
*   They can have **properties** and **methods**, just like any other object.
*   Unlike other objects, functions can be **called**.
*   Functions are, technically, **function objects**.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions

---

### Expressions, statements, declarations
[Icon: Thumbtack in a yellow circle]
*   An **expression** produces a value.
*   A **statement** does something.
*   **Declarations** are something a little different again: creating things.
*   BUT, JavaScript has:
    *   **Expression statements:** wherever JavaScript expects a statement, you can also write an expression!
    *   The **reverse does not hold:** you cannot write a statement where JavaScript expects an expression.

http://2ality.com/2012/09/expressions-vs-statements.html

---

### Functions and their execution
[Icon: Thumbtack in a yellow circle]

**Example 1**
```javascript
var result = function aFunction (){
    return -1;
};
// What is the value of result? (The function aFunction itself)
```

**Example 2**
```javascript
var result1 = function aFunction1 (){
    return -1;
};
var foo = result1();
// What is the value of foo? Why? (foo is -1, because result1() is executed)
```

**Example 3**
```javascript
var result1 = function aFunction1 (){
    return -1;
}();
// What is the value of result1? (result1 is -1, because the function is immediately invoked)
```

**Example 4**
```javascript
(function aFunction3 () {
 return 2;
})();
// What is happening here? Why? (This is an IIFE - Immediately Invoked Function Expression. The function is defined and executed immediately. The result of the expression is 2, though it's not assigned here.)
```

---

### Digression: a pair of brackets ()
[Icon: Thumbtack in a yellow circle]
The pair of brackets, (), is:
*   Used to execute a function e.g. `function();`
*   The grouping operator, e.g., to force precedence `(a + b) * c;`

---

### Immediately invoked function expressions (IIFE)
[Icon: Thumbtack in a yellow circle]
```javascript
(function () {
    // statements
})();
```
*   The **outer brackets**, `(function...)();`, enclose an **anonymous function**.
*   The subsequent **empty brackets**, `();` **execute** the function.
*   The anonymous function establishes a **lexical scope**. Variables defined in statements cannot be accessed outside the anonymous function.

---

### Uh oh: IIFE not executing
[Icon: Thumbtack in a yellow circle]
At the console I type this:
```javascript
> function () {
    // statements
}();
// But this doesn’t work. Why? (Parser expects a function declaration, not an expression. The trailing () is a syntax error in this context.)
```

---

### But: These IIFEs are working, Why?
[Icon: Thumbtack in a yellow circle]
```javascript
+function afunction () {
    console.log('Here I am!');
}();
// The leading '+' forces the parser to treat it as an expression.

!function afunction () {
    console.log('Here I am!');
}();
// The leading '!' (or other unary operators) forces the parser to treat it as an expression.
```

---

### JavaScript functions
[Icon: Diagram illustrating lexical scoping: Global scope / all JavaScript code surrounds Function scope / local scope, which contains LOCAL VARIABLES (Defined variables, Function parameters). JavaScript executes functions using the variable scope at the time of definition and not at the time of invocation.]

JavaScript executes any function:
*   using the variable scope at the time of **definition of the function**
*   **not** the variable scope at the time of **invocation of the function**

In other words:
*   Did the variable exist at the time of definition, e.g., in an outer function?
*   This approach to function execution supports **closures**.

---

### Closures
[Icon: Thumbtack in a yellow circle]
When JavaScript executes a function (any function), it:
*   Uses the variables in-scope at the **time of definition** of the function
*   **Not** the variable scope at the **time of invocation** of the function
*   A closure is a **record** storing a **function together with an environment**
    *   Variables **used locally** but **defined in enclosing scope**

Additional reading: [Closures - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)

---

## More JS next week
[Icon: Jigsaw puzzle pieces forming a sphere in a yellow circle]
Any **questions** ?

---
---

# SENG 365 Week 2
## More JavaScript and Asynchronous Flow

[Icon: Lightbulb]

---

### The story so far
[Icon: Thumbtack]

**In the lectures**
*   Introduction to Web Computing
*   HTTP
*   JavaScript basic concepts
*   Introduction to the assignments

**In the lab**
*   Pre-labs x 3
*   Coming up:
    *   Introduction to Node.js
    *   Introduction to persistence
    *   Structuring your server application

---

### In lecture this week
[Icon: Thumbtack]
*   Method chaining
*   Asynchronous programming
*   Event loop
*   Callback hell
*   Promises
*   async/await syntax
*   Module dependency

---

### Reference model
[Icon: Network/molecule in a yellow circle]

[Diagram:
User (Human) interacts with Client (Machine) containing HTML, CSS, JS (with APIs).
Client communicates via HTTP & REST with Server (Machine).
Server uses Express, Node.js (Headless browser) and has an API.
Data (JSON, XML,...) and Resources (HTML, CSS, JavaScript, ...) are exchanged.
Server queries Database (Machine) (Relational, Not-only relational Object) using SQL and gets Results (data).
]
**User:** Human
**HTTP client:** Machine
**HTTP Server:** Machine
**Database:** Machine

---

### Assignment 1
[Icon: Thumbtack]
*   Your eng-git repo has been created
    *   skeleton project
        *   Clone from eng-git into your own development environment
        *   Install node modules: `npm install`
        *   Create a `.env` file in the root directory of your project
        *   Add `.env` to `.gitignore`
        *   Add your specific environment variables to `.env`
    *   API specification (see next slide)
    *   README.md

---

### The assignment in essence
[Icon: Thumbtack]
*   (Assignment Briefing on Learn)
*   Implement the API specification provided in the repo
*   We will assess the implementation using a suite of automated tests.
    *   Assessing API coverage: how much of the API was implemented?
    *   Assessing API correctness: was an endpoint correctly implemented?
*   The automated tests are available for you
    *   See the information in the README.md
    *   You can see how well you are progressing
*   For the actual assessment we will use different data, but intend to use the same (or similar) automated test suite.

---

## Brief examples in Node.JS
[Icon: Yellow circle]
**With http package and with express package**

---

### `express` ‘Listening’ for a request to an endpoint
[Icon: Thumbtack]

[Image: Code snippet showing express route definition]
```javascript
// The root of the path in the URL
//          app.rootUrl
//                      A simple API endpoint:
//                      An 'extension' to the path in the URL
//                          '+ '/users''
app.route(app.rootUrl + '/users')
    .post(users.create); // Method chaining using dot (.), The HTTP method: POST
```
**Note:**
Nothing stated about
*   ports
*   domain names
*   query parameters

---

### `express` Create a user and respond
[Icon: Thumbtack]

[Image: Code snippet showing express user creation and response]
```javascript
try {
    const userId = await Users.create(req.body); // Object containing content of request body
    res.statusMessage = 'Created'; // HTTP status message
    res.status(201) // HTTP status code (201)
       .json({ userId }); // Set HTTP headers and return JSON in body
} catch (err) {
    // ... error handling ...
}
```

---

### The body of the HTTP request
[Icon: Thumbtack]
*   Some HTTP requests (typically) **do not need a body**:
    *   e.g. a GET request, a DELETE request
*   Broadly, there are three categories of body:
    *   **Single-resource bodies**, consisting of a single file of **known length**, defined by the two headers: `Content-Type` and `Content-Length`.
    *   **Single-resource bodies**, consisting of a single file of **unknown length**, encoded by chunks with `Transfer-Encoding` set to `chunked`.
    *   **Multiple-resource bodies**, consisting of a multipart body, each containing a different section of information. These are relatively rare.
*   HTTP bodies can contain **different kinds of content**
    *   We’re going to be using **JSON** (because JSON is most commonly used :))

---

## JavaScript cont.
[Icon: Yellow circle]

---

### `this` needs careful attention
[Icon: Thumbtack]
The context of any given piece of JavaScript code is made up of:
*   The current function’s (lexical) scope, and
*   Whatever is referenced by **this**

By default in a **browser**, `this` references the global object (**window**)
By default in **node**, `this` references the global object (**global**)
**`this` can be manipulated**, for example:
*   Invoke methods directly on an object, e.g. with `foo.bar()`; the object `foo` will be used as `this`

But `this` is fragile:
*   `let fee = foo.bar; // this=foo` (Here `this` inside `fee` if it were called directly would not be `foo`, the comment seems misleading. `fee` is just a reference to the function.)
*   `fee(); // this=global/window` (If `fee` is called like this, `this` will indeed be global/window in non-strict mode)

---

### Arrow functions (ES6)
[Icon: Yellow circle]
New anonymous function notation
`function (a, b) { return a + b; }`

Becomes
`(a, b) => a + b;`

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions

---

### Arrow functions and `this`
[Icon: Yellow circle]
Unlike anonymous functions, arrow functions **do not bind their own `this`**
```javascript
...
this.color = 'red';
setTimeout(() => {this.color = 'green'}, 1000); // 'this' here lexically inherits from the surrounding scope
```

---

### Method chaining (cascading)
[Icon: Thumbtack]
`let result = method1().method2(args).method3();`
*   Each method in the chain returns an object…
    *   each method must execute a `return…;` statement
*   The returned object must ‘contain’ within it the next method being invoked in the chain.
    *   `method1()` returns an object that has `method2()` within it, so that you can call `method2()`
*   The first method in the chain may need to create the object.
*   Usually, each method contains a `return this;` as a pointer to a common object being worked with
    *   That common object contains all of the methods e.g. `method1`, `method2` and `method3`
*   You can’t just arbitrarily chain together any set of methods

---

### Example (Method Chaining)
[Icon: Thumbtack]
```javascript
let anotherperson = {
  firstname: 'Ben',
  surname: 'Adams',
  printfullname: function () {
    console.log(this.firstname + ' ' + this.surname);
    return this;
  },
  printfirstname: function () {
    console.log(this.firstname);
    return this;
  },
  printsurname: function () {
    console.log(this.surname);
    return this;
  }
}
// anotherperson.printfirstname().printsurname().printfullname();
```

---

### Why chain?
[Icon: Thumbtack]
*   Reduces temporary variables
    *   No need to create temporary variable(s) to save each step of the process.
*   The code is expressive
    *   Each line of code expresses clearly and concisely what it is doing
    *   (Using verbs as names for methods helps).
*   The code is more maintainable
    *   Because it’s easier to read e.g. it can read like a sentence.
    *   Because it requires a coherent design to the chained methods
*   Method chaining used in, for example, Promises and other ‘then-able’ functions

---

### `'use strict'`
[Icon: Thumbtack]
Strict mode:
*   (a way of managing backward compatibility)
*   **modifies semantics** of your code (modifies the interpretation of your code), e.g.:
    *   `this` is defaulted to `undefined`
    *   less lenient about variable declarations e.g. `var`
    *   throws errors rather than tolerating some code
    *   rejects `with` statements, octal notation
    *   Prevents keywords such as `eval` being assigned
*   like a linter (e.g. linters give warnings and strict mode throws errors)
*   Linters need to be configured to ‘play nicely’ with strict mode
    *   can be applied to entire script or at function level

---

## Asynchronous JavaScript
[Icon: Yellow circle]

---

### The Event Loop (JavaScript Concurrency model)
[Icon: Thumbtack]

[Image: Diagram showing Stack, Heap, and Queue. Stack is for function calls, Heap for memory allocation, Queue for messages/callbacks.]

**Call Stack:** a data structure to maintain record of function calls.
*   Call a function to execute: push something on to the stack
*   Return from a function: pop off the top of the stack.
(The single thread.)

**Heap:** Memory allocation to variables and objects.

**Queue:** a list of messages to be processed and the associated callback functions to execute.

---

### An initial example (Event Loop)
[Icon: Thumbtack]
What will complete first? … and why?
```javascript
// Line Code
// 1
setTimeout(() => console.log('first'), 0);
// 2
console.log('second');
```
[Image: Diagram of Stack, Heap, Queue]
*Output: 'second', then 'first'. `setTimeout` places its callback in the event queue, even with a 0ms delay. The main thread executes `console.log('second')` first. Then, the event loop picks up the callback from the queue.*

---

### `setTime()` and `setInterval()` code examples
[Icon: Yellow Circle]
[Image: Screenshot of JavaScript code using `setTimeout` and `setInterval` with `console.log` to demonstrate timing and execution order.]
```javascript
/* jshint esversion: 6 */
let currentDateAndTime;
let currentTime;

console.log('Script start: ' + getDateTime());

function ping() {
    console.log('Ping: ' + getDateTime());
}

console.log('ping function declared: ' + getDateTime());

function sayHi(phrase, who) {
    console.log(phrase + ' ' + who + ', it\'s ' + getDateTime());
}

console.log('sayHi function declared: ' + getDateTime());

setInterval(ping, 500); // Initiate ping events
setTimeout(sayHi, 1000, "Hello", "Austen"); // Initiate message

console.log('setInterval and setTimeout executed: ' + getDateTime());

function getDateTime() {
    currentDateAndTime = new Date();
    currentTime = currentDateAndTime.toLocaleTimeString();
    return currentTime;
}

console.log('Script end: ' + getDateTime());
```

---

[Image: Diagram illustrating the JavaScript Event Loop in more detail.]
What the heck is the event loop anyway?
https://www.youtube.com/watch?v=8aGhZQkoFbQ

[Diagram components:
User Interface (1.Data show, 2.Do stuff (button click, etc)) ->
Javascript Runtime [ Heap (memory allocation), Call Stack (function call) { setTimeout(), showText(), console.log(), main() } ] -> (2)
Web APIS (Browser provided) [ DOM events(click, etc), XMLHttpRequest(ajax), Timers(setTimeout) ] -> (3)
Callback Queue [ DOM Queue (onClick..), NetworkQueue (ajax callback..), Timer Queue (callback..) ] -> (4) Event Loop -> Call Stack
]

---

### Another example (mysql query)
```javascript
mysql.query('SELECT * from a_table',
  function (error, results, fields) {
    if (error) throw error;
    console.log('Done');
  }
);
// The console.log('Done') will execute only after the database query completes and its callback is processed by the event loop.
```

---

## Callback Hell and the Pyramid of Doom
[Icon: Yellow circle]
**by Asynchronous JavaScript**

---

[Image: Screenshot of deeply nested JavaScript callback functions, forming a "pyramid of doom". Each `db.getPool().query(...)` has a callback function, and subsequent queries are nested within these callbacks.]
```javascript
// TODO: refactor, to avoid the pyramid of doom, by using promises
db.getPool().query('DROP TABLE IF EXISTS bid', function (err, rows){
  if (err) return done({"ERROR":"Cannot drop table bid"});
  console.log("Dropped bid table.");

  db.getPool().query('DROP TABLE IF EXISTS photo', function (err, rows){
    if (err) return done({"ERROR":"Cannot drop table photo"});
    console.log("Dropped photo table.");

    db.getPool().query('DROP TABLE IF EXISTS auction', function (err, rows){
      if (err) return done({"ERROR":"Cannot drop table auction"});
      console.log("Dropped auction table.");

      db.getPool().query('DROP TABLE IF EXISTS category', function (err, rows){
        if (err) return done({"ERROR":"Cannot drop table category"});
        console.log("Dropped category table.");

        db.getPool().query('DROP TABLE IF EXISTS auction_user', function (err, rows){
          if (err) return done({"ERROR":"Cannot drop table auction_user"});
          console.log("Dropped auction_user table.");
          done(rows);
        });
      });
    });
  });
});
```

---

### APIs and callback hell
[Icon: Thumbtack]
Consider that:
*   An API call from the client may under-fetch data… (the API is not designed to provide all and only the data the client needs)
*   … so the client will need to make subsequent API calls.
*   For example:
    *   First, an API call to get a list of student IDs in order to select one ID, then
    *   an API call to get the list of courses studied by that student, and then
    *   another API call to get further information of specific courses
*   This produces a nested (conditional) set of API calls
    *   For each call, the client must test whether the call was successful or not

---

### Promises
[Icon: Thumbtack]
*   The **Promise** object is used for deferred and asynchronous computations.
*   Promises allow you to use **synchronous and asynchronous** operations with each other
*   A Promise represents an **operation that hasn't completed yet**, but is expected in the future.
    *   **pending**: initial state, not fulfilled or rejected.
*   Or resolved as either:
    *   **fulfilled**: meaning that the operation completed successfully.
    *   **rejected**: meaning that the operation failed.

---

[Image: Flowchart of a Promise lifecycle.]
[Diagram:
Promise (pending) --[fulfill]--> .then(onFulfillment) --[return/settled]--> [async actions] --> Promise (pending) --> .then() / .catch() ...
Promise (pending) --[reject]--> .then(..., onRejection) / .catch(onRejection) --[return]--> Promise (pending) --> .then() / .catch() ...
                                        `--> [error handling]
]

---

### Chaining Promises
[Icon: Thumbtack]
*   Each Promise is first **pending**, and then (eventually) either **fulfilled** OR **rejected**
*   Chaining Promises allows you to chain dependent asynchronous operations, where each asynchronous operation is itself a Promise
*   Each **Promise** represents the completion of another asynchronous step in the chain.
*   To chain promises, each **Promise** returns another **Promise**
    *   Technically, each `then()` returns a Promise
*   Chain promises together using `.then()`
*   Can have multiple `.then()`s
*   Handles rejected state/s with `.catch()` (or `.then(null, callback)`)

---

[Image: A close-up of a large, round, weathered padlock on a wooden door. Text overlay: ASYNC / AWAIT]
*(This slide appears to be a transition/decorative slide for async/await, possibly from a template)*

---

### `async` ensures a function returns a Promise
[Icon: Thumbtack]
(a kind of function wrapper)
```javascript
async function f() {
  return 1;
}

f().then( (result) => { console.log(result); } ); // The original slide had `() => { console.log(result); }`, but result isn't passed if not in .then. Corrected to receive result.
// Note:
// async doesn’t execute the function immediately (it returns a promise that resolves with the return value)
```

---
[Image: Screenshot of JSFiddle showing regular functions and async functions, with console output.
Code:
```javascript
// Babel + JSX + No-Library (pure JS)
console.log("Start");

function g(input) {
    return input + 1;
}
console.log("The result of g(2) is: ", g(2)); // Output: The result of g(2) is: 3

let a_function = g;
console.log(a_function); // Output: function g(input) { ... }

async function f(input) {
    return input + 1;
}
console.log("The result of f(2) is: ", f(2)); // Output: The result of f(2) is: [object Promise]

let another_function = f;
console.log(another_function); // Output: async function f(input) { ... }
console.log("The result of f(2) is: ", f(2)); // Output: The result of f(2) is: [object Promise]

f(10).then(function(result) {
    console.log("The result of f() is: " + result); // Output: The result of f() is: 11
});

another_function(100).then(function(result) {
    console.log("The result of another_function (f()) is: " + result); // Output: The result of another_function (f()) is: 101
});
```
Link: https://jsfiddle.net/dnxquzym/15/
]
*(The previous slide's example `f().then( () => { console.log(result); } );` was slightly off, `result` isn't implicitly available. Corrected above. The JSFiddle illustrates this better.)*

---

### `await` forces JS to wait for the Promise to resolve
[Icon: Thumbtack]
*   `await` is only legal inside an `async` function…
*   … and `async` functions are Promises that commit to a future resolution…
*   … so other code can continue to run

---

## Module dependencies.
[Icon: Yellow circle]
**module.export / require()**

---

### Modular JavaScript files
[Icon: Thumbtack]
*   **CommonJS**: one specification for managing module dependencies
    *   Others exist e.g. RequireJS, ES2015 AMD (Async Module Definition)
*   Node.js adopted CommonJS
    *   To use CommonJS on front-end, you’ll need to use Browserify (or similar)
*   A module is defined by a **single JavaScript file**
*   Use `module.exports.*` or `exports.*` (but not both) to expose your module’s public interface
*   Values assigned to `module.exports` are the module’s public interface
    *   A value can be lots of things e.g. string, object, function, array
*   You want to expose something? Add it to `module.exports`
*   Import the module using `require()`

---

### Creating modules & reusing existing module
[Icon: Thumbtack]
You can create your own modules
**myModule.js**
`module.exports...`

And then reuse that module :
**myOtherModule.js**
`var something = require('../../myModule.js');`

---

### Dependency management
[Icon: Thumbtack]
*   `npm` is a package manager for node
*   `npm` is designed to be node-specific
*   `npm install` installs packages suitable for the CommonJS-like dependency management used by Node, i.e. the exports/requires approach

---

### Creating modules & reusing existing module (npm)
[Icon: Thumbtack]
You can reuse existing modules provided by the node ecosystem
First, install the existing module through npm
`> npm install aModule`

And then reuse that module :
**myOtherModule.js**
`var something = require('aModule');`

Note the differences in parameters for node and home-grown modules

---
---

```markdown
# SENG 365 Week 3
## TypeScript and Data Persistence

[Icon: Lightbulb]

---

### The story so far
[Icon: Thumbtack]
*   What is a Web Application?
*   HTTP
*   JavaScript basics
*   Asynchronous JavaScript
*   Assignment 1

---

### This week
[Icon: Thumbtack]
*   TypeScript
*   Data Persistence in Web Applications

---

## TypeScript
[Icon: Yellow Circle]
TypeScript Handbook:
https://www.typescriptlang.org/docs/handbook/intro.html

---

### Problems with JavaScript
[Icon: Thumbtack]
*   Dynamically typed
*   Type coercion behaves in unexpected ways
    *   Poor IDE support
    *   https://blog.campvanilla.com/javascript-the-curious-case-of-null-0-7b131644e274
        ```javascript
        var container = "hello";
        container = 43; // No error

        null > 0;  // false
        null == 0; // false
        null >= 0; // true
        ```
*   Different ECMAScript versions of the language that are not supported by all browsers

---

### TypeScript
[Icon: Thumbtack]
*   Developed by Microsoft
*   Goal to create safer web code quicker
*   Superset of JavaScript
    *   All JavaScript code is TypeScript
*   Adds:
    *   Static typing
    *   Type inference
    *   Better IDE support
    *   Strict null checking

---

### TypeScript files
[Icon: Thumbtack]
*   TypeScript files use `.ts` extension
*   Any JavaScript file can be converted to TypeScript by simply changing extension from `.js` to `.ts`
*   The opposite is not true

---

### Static typing in TypeScript
[Icon: Thumbtack]
*   **Basic Types:**
    *   From JS primitives: `boolean`, `number`, `bigint`, `string`, `array`, `tuple`, `object`, `null`, `undefined`
    *   Additional: `enum`, `unknown`, `any`, `void`, `never`
*   **Type declarations for variable**
    *   Do not change how the code runs
    *   Are used by the compiler for type checking
    *   Can be explicit or inferred by assignment

---

### Static typing examples
[Icon: Thumbtack]
```typescript
let isDone: boolean = false;

let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;
let big: bigint = 100n;

let color: string = "blue";
color = 'red';
```

---

### Static typing examples
[Icon: Thumbtack]
```typescript
let list: number[] = [1, 2, 3];
// or
let list: Array<number> = [1, 2, 3];

enum Color {
  Red,
  Green,
  Blue,
}
let c: Color = Color.Green;
```

---

### Static typing functions
[Icon: Thumbtack]
```typescript
// Parameter type annotation
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase() + "!!");
}

// Would be a runtime error if executed! (TypeScript catches this at compile time)
// greet(42);
// Argument of type 'number' is not assignable to parameter of type 'string'.

function getFavoriteNumber(): number { // Return type annotation
  return 26;
}
// void type is used when no return value
```

---

### Static typing objects
[Icon: Thumbtack]
*   Duck typing – based on the shape
*   Can be anonymous or named using `interface`
```typescript
function greet(person: { name: string; age: number }) { // Anonymous interface
  return "Hello " + person.name;
}

interface Person { // Named interface
  name: string;
  age: number;
  // Properties can be optional using ?
  // address?: string;
}

function greetPerson(person: Person) {
  return "Hello " + person.name;
}
// age?: number; // Example of optional property
```

---

### Static typing interfaces, types, and classes
[Icon: Thumbtack]
Interface declarations can be used with classes
```typescript
interface User {
  name: string;
  id: number;
}

class UserAccount {
  name: string;
  id: number;

  constructor(name: string, id: number) {
    this.name = name;
    this.id = id;
  }
}

const user: User = new UserAccount("Murphy", 1);
```
`type` is like `interface` but cannot be extended.
See https://cutt.ly/NAnFoG9 (likely points to TypeScript documentation on type vs interface)

---

### Unions
[Icon: Thumbtack]
```typescript
function printId(id: number | string) { // Union type for parameter
  console.log("Your ID is: " + id);
}
// OK
printId(101);
// OK
printId("202");
// Error (TypeScript will catch this)
// printId({ myID: 22342 });
```
**Union types (literal types)**
```typescript
type WindowStates = "open" | "closed" | "minimized";
type LockStates = "locked" | "unlocked";
type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;
```

---

### Unions and `typeof`
[Icon: Thumbtack]
```typescript
function printId(id: number | string) {
  if (typeof id === "string") {
    // In this branch, id is of type 'string'
    console.log(id.toUpperCase());
  } else {
    // Here, id is of type 'number'
    console.log(id);
  }
}
```

---

### Strict null checking
[Icon: Thumbtack]
```typescript
// With strictNullChecks enabled:
let x: number = undefined; // Error: Type 'undefined' is not assignable to type 'number'.

// To allow undefined:
let y: number | undefined;
if (y !== undefined) {
    y += 1; // this line will compile
}
// y += 1; // this line will fail compilation if y could still be undefined
```

---

### Compiling TypeScript
[Icon: Yellow circle]
*   Node.JS and browsers do not execute TypeScript
    *   It must be compiled to JS first
*   For Node.JS we need to add it to our project:
    *   `npm i -D typescript`

---

### TypeScript and Modules
[Icon: Yellow circle]
*   Node packages can have TypeScript bindings (supports IDE)
*   Recall Node uses CommonJS modules (`module.exports`)
*   Add `.d.ts` file to package (declaration file for types)

**mymodule.ts**
```typescript
const maxInterval = 12;
function getArrayLength(arr: any[]): number {
  return arr.length;
}
module.exports = {
  getArrayLength,
  maxInterval,
};
```

**mymodule.d.ts** (Declaration file)
```typescript
export function getArrayLength(arr: any[]): number;
export const maxInterval: 12;
```

---

## Data in Web Applications
[Icon: Yellow Circle]
**JSON, Relational DB, NoSQL**

---

### POJO and JSON
[Image: Book covers of "JavaScript: The Good Parts" by Douglas Crockford and "How JavaScript Works" by Douglas Crockford with Virgule Solidus.]

David Crockford’s view: https://json.org/
A useful tool: https://json-to-js.com/ with npm version: `npm i -g json-to-js`
Useful tools (but not always accurate): https://tools.learningcontainer.com/

*(The initial slide for this section was titled "Data and Web Applications" with "JSON, Relational DB, NoSQL, GraphQL". The subsequent POJO/JSON slide didn't mention GraphQL, but the context of "Data in Web Applications" applies.)*

---

### JSON Semi-formal definitions
[Icon: Gear in a yellow circle]
*   JSON is a lightweight **data-interchange** format.
*   A syntax for **serializing data** e.g., objects, arrays, numbers, strings, etc.
    *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
*   **Data only**, does not support comments except as a data field
*   Not specific to JavaScript
    *   Was originally intended for data interchange between Java and JavaScript
*   No versioning for JSON: why? (Simplicity, ubiquity, parsing ease. Versioning is typically handled at the API level.)

---

### JSON: some rules
[Image: JSON syntax diagram for numbers.]
https://json.org/
*   All key-names are double-quoted
*   Values:
    *   Strings are double-quoted
    *   Non-strings are not quoted
*   Use `\` to escape special characters, such as `\` and `"`
*   Numbers need to be handled carefully
    *   e.g. a decimal must have a trailing digit
        *   Correct: 27.0
        *   Incorrect 27.
        *   Correct 27
*   Can’t – shouldn’t – JSONify functions or methods
*   See the following for guidance:
    *   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
    *   https://json.org/
*   And this for an… interesting discussion… on JSON syntax:
    *   https://stackoverflow.com/questions/19176024/how-to-escape-special-characters-in-building-a-json-string

---

### Reference model (with Data Storage Options)
[Icon: Network/molecule in a yellow circle]

[Diagram:
User (Human) interacts with Client (Machine) containing HTML, CSS, JS (with APIs).
Client communicates via HTTP & REST with Server (Machine).
Server uses Express, Node.js (Headless browser) and has an API.
Data (JSON, XML,...) and Resources (HTML, CSS, JavaScript, ...) are exchanged.
Server queries Database (Machine) and gets Results (data).
]
**Many data storage options:**
**SQL:** MySql, PostgreSQL, OracleDB, …
**NoSQL:**
 Key-value stores
 Memory stores
 Document databases
**Graph** Databases, …

---

### Relational databases
[Icon: Yellow highlighting "Relational"]
*   One of the few cases where a theoretical contribution in academic computer science led innovation in industry
*   **Relational model** (E.F. Codd 1970)
    *   Data is presented as **relations**
    *   Collections of **tables** with **columns** and **rows** (tuples)
    *   Each **tuple** has the same attributes
    *   **Unique key** per row
    *   **Relational algebra** that defines operations: UNION, INTERSECT, SELECT, JOIN, etc.

---

### ACID database transactions
[Icon: Yellow highlighting "ACID"]
*   **Atomicity**—“all or nothing” if one part of a transaction fails, then the whole transaction fails
*   **Consistency**—the database is kept in a consistent state before and after transaction execution
*   **Isolation**—one transaction should not see the effects of other, in progress, transactions
*   **Durability**—ensures transactions, once committed, are persistent

---

### “The end of an architectural era?”
*   Traditional RDBMSs
    *   ACID properties were requirement for data handling
*   Over the past few decades:
    *   Moore’s Law—CPU architectures have changed how they acquire speed
    *   New requirements for data processing have emerged
    *   Stonebraker et al. (2007), suggest that “one size fits all” DBs not sufficient
    *   Still… relational databases are extremely useful in many cases

---

### CAP Theorem
[Icon: Yellow highlighting "CAP Theorem"]
*   In distributed computing, **choose two** of:
    *   **Consistency**—every read receives the most recent data
    *   **Availability**—every read receives a response
    *   **Partition tolerance**—system continues if network goes down
*   Situation is actually more subtle than implied above
    *   Can adaptively choose appropriate trade-offs
    *   Can understand semantics of data to choose safe operations

---

### BASE
[Icon: Yellow highlighting "BASE"]
*   Give up consistency (first part of CAP) and we can instead get:
    *   **Basic Availability**—through replication
    *   **Soft state**—the state of the system may change over time
        *   This is due to the eventual consistency…
    *   **Eventual consistency**—the data will be consistent eventually
        *   … if we wait long enough
        *   (and probably only if data is not being changed frequently)

---

### ACID versus BASE example (1/2)
[Icon: Yellow highlighting "ACID versus BASE"]
*   Suppose we wanted to track people’s bank accounts:
    `CREATE TABLE user (uid, name, amt_sold, amt_bought)`
    `CREATE TABLE transaction (tid, seller_id, buyer_id, amount)`
*   ACID transactions might look something like this:
    ```sql
    BEGIN
    INSERT INTO transaction(tid, seller_id, buyer_id, amount);
    UPDATE user SET amt_sold=amt_sold + amount WHERE id=seller_id;
    UPDATE user SET amt_bought=amt_bought + amount WHERE id=buyer_id;
    END
    ```

---

### ACID versus BASE Example (2/2)
[Icon: Yellow highlighting "ACID versus BASE"]
*   If we consider `amt_sold` and `amt_bought` as *estimates*, transaction can be split:
    ```sql
    BEGIN
    INSERT INTO transaction(tid, seller_id, buyer_id, amount);
    END

    BEGIN
    UPDATE user SET amt_sold=amt_sold + amount WHERE id=seller_id;
    UPDATE user SET amt_bought=amt_bought + amount WHERE id=buyer_id;
    END
    ```
*   Consistency between tables is no longer guaranteed
*   Failure between transactions may leave DB inconsistent

---

### Key value databases overview
[Icon: Thumbtack]
*   Unstructured data (i.e., schema-less)
*   Primary key is the only storage lookup mechanism
*   No aggregates, no filter operations
*   Simple operations such as:
    *   **Create**—store a new key-value pair
    *   **Read**—find a value for a given key
    *   **Update**—change the value for a given key
    *   **Delete**—remove the key-value pair

---

### Key value databases
[Icon: Thumbtack]
**Advantages**
*   Simple
*   Fast
*   Flexible (able to store any serialisable data type)
*   High scalability
*   Can engineer high availability

**Disadvantages**
*   Stored data is not validated
    *   NOT NULL checks
    *   colour versus color
*   Complex to handle consistency
*   Checking consistency becomes the application’s problem
*   No relationships—each value independent of all others
*   No aggregates (SUM, COUNT, etc.)
*   No searching (e.g., SQL SELECT-style) other than via key

---

### Key value database implementations
[Icon: Thumbtack]
*   Amazon Dynamo (now **DynamoDB**)
*   Oracle NoSQL Database, ... (eventually consistent)
*   Berkeley DB, ... (ordered)
*   Memcache, **Redis**, ... (RAM)
*   LMDB (used by OpenLDAP, Postfix, InfluxDB)
*   LevelDB (solid-state drive or rotating disk)
*   **IndexedDB** (in the browser)

---

### Dynamo Amazon’s Highly Available Key-value Store
[Icon: Thumbtack]
*   Just two operations:
    *   `put(key, context, object)`
    *   `get(key) → context, object`
*   Context provides a connection to DynamoDB
    *   contains information not visible to caller
    *   but is used internally, e.g., for managing versions of the object
*   Objects are typically around 1MiB in size

---

### Dynamo Design
[Icon: Thumbtack]
*   Reliability is one of the most important requirements
    *   Significant financial consequences in its production use
    *   Impacts user confidence
*   Service Level Agreements (SLAs) are established
*   Used within Amazon for:
    *   best seller lists; shopping carts; customer preferences; session management; sales rank; product catalog

---

### Redis in memory store
[Icon: Thumbtack]
*   Whole database is stored in RAM
    *   Very fast access
    *   Useful for cached data on the server
    *   E.g. commonly accessed data from RDBMS can be stored in memory store on same computer as the API server.
*   Key-value store where the value can be a complex data structure
    *   Strings, Bitarrays, Lists, Sets, Hashes
    *   Streams (useful for logs)
    *   Binary-safe keys
    *   Command set for optimized load, storing, and changing data values

---

### Document databases
[Icon: Thumbtack]
*   Semi-structured data model
*   Storage of documents:
*   typically JSON or XML
*   could be binary (PDF, DOC, XLS, etc.)
*   Additional metadata (providence, security, etc.)
*   Builds index from contexts and metadata

---

### Document databases
[Icon: Thumbtack]
**Advantages**
*   Storage of raw program types (JSON/XML)
*   Indexed by content and metadata
*   Complex data can be stored easily
*   No need for costly schema migrations
*   (Always remember that your DB is likely to need to evolve!)

**Disadvantages**
*   Same data replicated in each document (can lead to this, if not designed carefully)
*   Risk inconsistent or obsolete document structures

---

### Document database implementations
[Icon: Thumbtack]
*   ElasticSearch
*   LinkedIn's Espresso
*   CouchDB
*   MongoDB
*   Solr / Apache Lucene
*   RethinkDB
*   Microsoft DocumentDB
*   PostgreSQL (when used atypically, e.g., with JSONB)

---

### Graph databases
[Icon: Thumbtack]
*   **Node** (or **vertex**)—represents an entity
*   **Edge**—represents relationship between nodes
*   **Bidirectional** (usually illustrated without arrowheads)
*   **Unidirectional** (usually illustrated with an arrowhead)
*   **Properties**—describe attributes of the node or edge
*   Often stored as a **key-value set**
*   **Hypergraph** – one edge can join multiple nodes

---

### Street map connectivity is a graph
[Image: Map of University of Otago campus with nodes at intersections and edges along streets, some directed (red arrows) and some bi-directional (black lines with arrows at both ends).]
*   **Node**
    *   Traffic junction
*   **Edge**
    *   Shows traffic flow
    *   Can be uni/bidirectional

---

### Edges can have properties
[Image: Close-up of the University of Otago map. Several streets (edges) are highlighted, with callouts showing their properties.
Example:
`name: "Union Street East"`
`type: "residential"`
`max_speed: "50"`
`restrictions: "commercial"`
`surface: "tarmac"`
`status: "closed"`
`reason: "repairs"`
`length: "250m"`

Another example:
`name: "Forth Street"`
`type: "residential"`
`max_speed: "50"`
`furniture: "bus stop"`

Another example:
`name: "Leithbank"`
`type: "residential"`
`max_speed: "50"`
`direction: "one way"`
`traffic_control: "traffic lights"` (This property seems to apply to a node/intersection rather than the edge itself based on common map data models, but the slide presents it as an edge property).
]

---

### Nodes can have properties
[Image: Diagram showing three nodes (Dave, Cathy, Haibo) connected by bidirectional arrows (colleague of). Each node has associated properties.
Dave: `office: "125", building: "Owheo", phone: "x5749", email: ...`
Cathy: `office: "121", building: "Owheo", phone: "x8580", email: ...`
Haibo: `office: "247", building: "Owheo", phone: "x8534", email: ...`
]

---

### Different types of nodes
[Image: Graph diagram.
Blue nodes (People): Paul, Dave, Haibo, Cathy.
Yellow nodes (Years): 2018, 2019, 2020.
Green node (Course): COSC430.
Edges:
- People -> Years (e.g., Cathy teaches in 2020)
- Years -> Course (e.g., 2020 offering COSC430)
The relationship "teaches" is shown between Cathy and 2020. The relationship "offering" is shown between 2020 and COSC430. Other edges between people and years are implied but not explicitly labeled with relationship types in this visual.
]

---

### Building blocks of property graph model
[Image: Diagram showing an "Employee" node connected to a "Company" node by a ":HAS_CEO" relationship, which has a "start_date" property. The "Company" node is connected to a "City" node by a ":LOCATED_IN" relationship.
Employee node properties: `name: Amy Peters, date_of_birth: 1984-03-01, employee_ID: 1`
Company node is just labeled "Company".
City node is just labeled "City".
Relationships can have properties (name/value pairs). Relationships are directional. Relationships connect nodes and represent actions (verbs). Nodes can have properties (name/value pairs). Nodes represent objects (nouns).
]

---

### Building blocks of property graph model
[Image: Same diagram as above, with an additional overlay below it:
(adjective) Noun --[VERB (adverb)]--> Noun (adjective)
This illustrates the semantic structure that graph models often represent.
]

---

### Why do we need graph databases?
*   We can store graphs in RDBMSs, e.g.,
    *   Node table
    *   Edge table
*   But, joins between nodes and edges are common
    *   … as the number of hops in a graph increases, this becomes increasingly expensive
*   Some problems best suit direct representation in graphs
    *   E.g. social graph

---

### Designing graph databases
[Icon: Thumbtack]
*   Typical mapping from application’s data to a graph:
    *   **Entities** are represented as **nodes**
    *   **Connections** are represented as **edges** between nodes
    *   Connection **semantics** dictate **directions** of edges
    *   Entity **attributes** become node **properties**
    *   Link strength / weight / quality maps to relationship properties
*   Other metadata will also be include in property sets
    *   e.g., information about data entry and revision

---

### Graph database implementations
[Icon: Thumbtack]
*   **Neo4j**
    *   https://neo4j.com/developer/graph-database/
*   Amazon Neptune
*   JanusGraph (scalable, distributed graph database)
*   ArangoDB
*   OrientDB
*   RedisGraph (in memory)
*   RDF-specific
    *   Virtuoso, BlazeGraph, AllegroGraph
*   Others… see https://tinkerpop.apache.org

---

### Graph DB Query languages
[Icon: Yellow highlighting "Graph DB"]
*   **Cypher** – developed for neo4j but used by other systems
    *   https://neo4j.com/developer/cypher/
    *   Declarative language (like SQL for graph databases)
    *   Create, Read, Update, Delete operations on the elements of the graph
    *   Match patterns in the graph
    `(node)-[:RELATIONSHIP]->(node)`
    `(node {key: value})-[:RELATIONSHIP]->(node)`
*   **Alternatives:**
    *   SPARQL – querying RDF graphs
    *   Gremlin – graph traversal language for Apache Tinkerpop
    *   PGQL – Oracle – mix of SQL SELECT-style with graph matching

---

### Cypher MATCH and RETURN keywords
[Image: Neo4j browser showing a Cypher query and its visual result.
Query: `neo4j$ Match (m:Movie) where m.released > 2000 RETURN m limit 5`
Result: Five nodes (The Polar Express, Somethi..., Rescue..., The Matrix Revol..., The Matrix Reloa...) representing movies, not connected by relationships in this particular query result visualization.]

---

### Cypher MATCH and RETURN keywords
[Image: Neo4j browser showing a more complex Cypher query and its visual result.
Query: `neo4j$ MATCH (p:Person)-[d:ACTED_IN]->(m:Movie) where m.released > 2010 RETURN p,d,m`
Result: A graph showing Person nodes connected to a Movie node ("Cloud Atlas") by ACTED_IN relationships. Persons include Halle Berry, Jim Broadb..., Hugo Weaving, Tom Hanks.]

---

### Complex graph queries
[Image: Neo4j browser showing a very complex Cypher query and its visual result.
Query: `neo4j$ MATCH (p:Person {name: 'Kevin Bacon'})-[*1..3]-(hollywood) return DISTINCT p, hollywood`
Result: A large, interconnected graph showing Kevin Bacon, movies he acted in, other actors in those movies, and potentially further connections up to 3 hops away. Many nodes and relationships are visible.]

---

### Connecting to neo4j from nodeJS
[Image: Code snippets for connecting to Neo4j from Node.js.
**Shell:**
`npm install neo4j-driver`

**JavaScript:**
```javascript
const neo4j = require('neo4j-driver');

const driver = neo4j.driver(uri, neo4j.auth.basic(user, password));
const session = driver.session();
const personName = 'Alice';

try {
  const result = await session.run(
    'CREATE (a:Person {name: $name}) RETURN a',
    { name: personName }
  );

  const singleRecord = result.records[0];
  const node = singleRecord.get(0);

  console.log(node.properties.name);
} finally {
  await session.close();
}

// on application exit:
await driver.close();
```
]

---
---
```
```markdown
# SENG 365 Week 4
## REST, APIs, GraphQL

[Icon: Lightbulb]

---

### This week
[Icon: Thumbtack]
*   RESTful APIs
*   Managing state in web applications
*   API versioning

---

[Image: Photo of Roy Fielding speaking at a conference. Text overlay:
**REST:**
**Representational State**
**Transfer**
Developed by Roy Fielding
]

---

[Image: Screenshot of Chapter 5 from Roy Fielding's dissertation, "Architectural Styles and the Design of Network-based Software Architectures". The chapter title is "Representational State Transfer (REST)".]
https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf (2000)

---

### REST and HTTP Methods
[Icon: Thumbtack]
REST asks developers to use HTTP methods explicitly and consistently with the HTTP protocol definition.

---

### HTTP
[Icon: Yellow circle]
*   HTTP is a **stateless protocol** originally designed for document retrieval
    *   HTTP requests and responses are self-contained
    *   Not dependent on previous requests and responses
*   HTTP **common commands**
    *   **GET** – retrieve a named resource (shouldn’t alter visible server state)
    *   **HEAD** – like GET but only gets headers
    *   **POST** – submits data to the server, usually from an HTML form
*   Some **less common commands**
    *   **OPTIONS** – get supported methods for given resource
    *   **POST** – create a new resource (Note: POST is also used here in a more RESTful context than just HTML forms)
    *   **PUT** – submit (changes to) a specified resource
    *   **DELETE** – delete a specified resource
    *   **PATCH** – modify an existing resource

---

### Idempotence and safe methods
[Icon: Yellow circle]
*   **Safe** methods are HTTP methods that do **not modify resources**
    *   Like read-only methods
*   **Idempotent** methods: the *intended state* (e.g. data changed) is the same whether the method is called once or many times
    *   Depends on the current state of the system
*   **Clarification**
    *   This is about best practice & standards
    *   You can break these standards, but shouldn’t
    *   Concerns the server, not the client

| HTTP method | Should be safe | Should be Idempotent |
|-------------|----------------|----------------------|
| GET         | Yes            | Yes                  |
| HEAD        | Yes            | Yes                  |
| PUT (GET first) | No           | Yes                  |
| POST        | No             | No                   |
| DELETE      | No             | Yes                  |
| PATCH       | No             | No                   |

*(Note: For PUT, "GET first" implies that PUT is often used to replace a resource, and if the resource doesn't exist, it might be created. The idempotence comes from the fact that multiple identical PUT requests should result in the same state as a single PUT request. PATCH is not idempotent because successive identical PATCH requests might have different outcomes if the patch operation is relative, e.g., "increment counter".)*

---

### Why does idempotency matter? Side-effects
[Icon: Yellow circle]
“Idempotency and safety (nullipotentcy) are **guarantees** that **server applications make to their clients** … An operation **doesn’t automatically become idempotent** or safe just because it is invoked using the GET method, if it isn’t **implemented** in an idempotent manner.

A poorly written server application might use GET methods to update a record in the database or to send a message to a friend … **This is a really, really bad design.**

**Adhering to the idempotency and safety contract helps make an API fault-tolerant and robust.**”
https://codeahoy.com/2016/06/30/idempotent-and-safe-http-methods-why-do-they-matter/

---

### CRUD and REST
[Icon: Thumbtack]
*   To **Create** a resource on the server, you should use **POST**
*   To **Retrieve** a resource, you should use **GET**
*   To change the state of a resource or to **Update** it, … use **PUT**
*   To remove or **Delete** a resource, you should use **DELETE**

---

### Bad practice
[Icon: Yellow circle]
*   You don’t have to map CRUD operations to HTTP methods.
*   Here’s a bad practice:
    `GET /path/user?userid=1&action=delete`
*   What’s this HTTP request doing? (It's using a GET request, which should be safe and idempotent, to perform a destructive delete operation. This violates REST principles.)

---

### How good are these examples?
[Icon: Yellow circle]

1.  `GET /adduser?name=Robert HTTP/1.1`
    *(Bad: GET should not be used to create resources/alter state.)*
2.  ```http
    POST /users HTTP/1.1
    Host: myserver
    Content-Type: application/xml
    <?xml version="1.0"?>
    <user>
        <name>Robert</name>
    </user>
    ```
    *(Good: POST is used to create a resource. XML is a valid representation.)*
3.  ```http
    POST /users HTTP/1.1
    Host: myserver
    Content-Type: application/json
    {
        "name": "Robert"
    }
    ```
    *(Good: POST is used to create a resource. JSON is a common and valid representation.)*

---

### CRUD and REST cont.
[Icon: Yellow circle]
*   For a partial change, use **PATCH** (like diff)
*   Include only elements that are changing
*   Null (value) to delete an element (in a PATCH request)
*   See also “best practices”
    *   http://51elliot.blogspot.co.nz/2014/05/rest-api-best-practices-3-partial.html
*   JSON merge patch
    *   https://tools.ietf.org/html/rfc7386

---

### A REST service is
[Icon: Yellow circle]
*   Platform-independent
    *   Server is Unix, client is a Mac…
*   Language-independent
    *   C# can talk to Java, etc.
*   Standards-based (runs *on top of* HTTP), and
*   Can easily be used in the presence of firewalls

---

### A REST service is
[Icon: Yellow circle]
*   RESTful systems typically, but not always:
    *   communicate over the Hypertext Transfer Protocol (HTTP)
    *   with the same HTTP verbs (GET, POST, PUT, DELETE, etc.) used by web browsers
    *   to retrieve web pages and send data to remote servers.
*   RESTful apps are (a subset of) web apps

---

### (HTTP | REST) resources
[Icon: Yellow circle]
*   **Nouns not verbs** (because resources are things not actions)
*   Instances or Collections
*   Resource instance typically identified by `:id`
    *   Integer
        *   sequential numbering issues, reuse of ids (generally bad idea)
        *   some systems have troubles with long integers (>53 bits in JavaScript)
    *   UUID
*   Hypertext As The Engine Of Application State (HATEOAS)
    *   http://restcookbook.com/Basics/hateoas/

---

### REST features
[Icon: Yellow circle]
*   REST offers **no built-in security features**, encryption, session management, QoS guarantees, etc.
*   These can be added by building on top of HTTP
*   For encryption, REST can be used on top of HTTPS (secure sockets)

---

### REST vs SOAP
[Icon: Yellow circle]
*   REST displaced SOAP, because…
*   … REST is considerably easier to use
    *   e.g. SOAP has a ‘heavy’ infrastructure
*   … works nicely with AJAX / XHR
    *   e.g. XML is verbose; JSON is more concise
*   … has some network advantages
    *   accepted through firewalls

---

### Stateless requests
[Icon: Yellow circle]
*   A complete, independent request doesn't require the server to retrieve any kind of application context or state.
*   A RESTful Web service application includes within the HTTP headers and body of a request: all of the parameters, context, and data needed by the server-side component to generate a response.
*   The entire resource is returned, not a part of it.
*   Statelessness:
    *   Improves Web service performance
    *   Simplifies the design and implementation of server-side components…
    *   because the absence of state on the server removes the need to synchronize session data with an external application.

---

### RESTful URLs
[Icon: Yellow circle]
*   **Hide the server-side scripting technology** file extensions (.jsp, .php, .asp), if any, so you can port to something else without changing the URIs
    *   Hide all implementation details!
*   Be **consistent in the singularity / plurality** of resource names
    *   Use singular or plural, but don’t mix them
    *   `/student` & `/course`; not `/student` and `/courses`
*   Keep everything **lowercase**
*   Substitute spaces for **hyphens**
*   Instead of using the 404/Not Found code if the request URI is for a partial path, always provide a **default page or resource** as a response

---

### Issues with REST
[Icon: Yellow circle]
*   Tightly coupled to HTTP
*   Request-response
    *   Can’t push/alert or broadcast
*   Multiple request-responses needed
    *   Implied tree-structure
    *   Underfetching and overfetching
    *   Latency increases for full set of request-response

---

## State and Statelessness
[Icon: Yellow circle]

---

### Mini-overview (State)
[Icon: Thumbtack]
*   State timescales
*   Session (state) information
*   GET parameters e.g. after the `?`
*   HTTP bodies & cookies
    *   Types
    *   Sequence
    *   Limitations
    *   Session IDs

---

### State timescales
[Icon: Yellow circle]
[Image: A vertical blue arrow pointing downwards. "shortest" is at the top, "longest" at the bottom.]
*   Individual HTTP request (stateless) (shortest)
*   Business transaction
*   Session
*   Preferences
*   Record state (longest)

---

### Session state information
[Icon: Yellow circle]
*   For web applications (in contrast to public web pages) there is a need to **maintain stateful information** about the client
*   The application (client & server) needs to maintain consistency on **which client** (authentication) and **what actions** (authorisation)
*   Longer-lived transactions
    *   Anything that’s built up of **multiple HTTP calls** (stateless)
    *   May be stored on server, or on client (or synchronized)

---

### GET `?` parameters (for state)
[Icon: Yellow circle]
*   Maintain some kind of **session variable** in the parameter to the HTTP request
*   Variable does not contain the username and password, but a unique (‘random’) identifier
*   Include variable as a parameter in each network request e.g.,
    `GET www.example.com?sessionid=<var>`
*   Why is this ‘bad practice’? (Session ID in URL is visible, can be bookmarked, logged, shared easily, less secure.)
*   Why may something like this be needed, at times? (When cookies are disabled or not usable.)

---

### Cookies (for state)
[Icon: Yellow circle]
*   Use cookies to maintain session information
*   The server issues a unique (‘random’) identifier in the cookie to the client, for that username & password
*   Client sends back the cookie with **each** network request to the server
*   e.g. in the POST data (or as a cookie header)
*   Note that the username and password are not sent (once the user is logged on)

---

### Cookies
[Icon: Yellow circle]
*   A **small piece of data** initially sent by the server to the client.
    *   Comprises **name-value pairs**
    *   Also has **attributes** (that are not sent back to the server)
    *   **Expiry ‘date’** (duration)
*   Used to maintain state information
    *   e.g. items in a shopping basket (although this example may be better kept on the server)
    *   e.g. browser activity such as a ‘path’ through a registration process

---

### Types of Cookies
[Icon: Yellow circle]

| Type                  | Description                                                                                                                              |
|-----------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| **First-party cookie**  | A cookie set by the server to which the browser primarily connects.                                                                      |
| **Session cookie**      | Exists only for the duration of that browser session, and the browser typically deletes the cookie when closed.                        |
| **Persistent cookie** (aka tracking cookie) | Persistent data. The cookie is not deleted when the browser closes. Can be used by advertising to track user behaviour. Can be used to store credentials e.g. log in details. |
| **Secure cookie**       | A cookie that can only be transmitted over an encrypted connection, such as HTTPS.                                                       |
| **HTTPOnly cookie**     | Can only be transmitted through HTTP/S, and are not accessible through non-HTTP APIs such as JavaScript.                                |
| **Third-party cookie**  | Cookies set by third-parties that serve content to the page e.g. advertising.                                                            |

---

### Cookie sequence
[Icon: Yellow circle]
*   **Request from browser**
    ```http
    GET /index.htm HTTP/1.1
    Host: www.example.com
    ```
*   **Response from server**
    ```http
    HTTP/1.1 200 OK
    Content-type: text/html
    Set-cookie: sessionToken=a1b2c3; Expires=[date]
    ```
*   **Follow-up request from browser**
    ```http
    GET /profile.htm HTTP/1.1
    Host: www.example.com
    Cookie: sessionToken=a1b2c3
    ```

---

### Limitations of cookies
[Icon: Yellow circle]
*   Each browser maintains its own ‘cookie jar’
*   A cookie does not identify a person
*   A cookie identifies the combination of:
    *   User account (on a specific site)
    *   Web browser
    *   Device
*   A cookie requires that the browser is cookie-enabled and is set to allow cookies

---

## API Versioning
[Icon: Yellow circle]

---

### API versioning: overview
[Icon: Yellow circle]
*   Compatibility between API provider and API consumer
*   Semantic versioning
*   Specifying API versions in HTTP requests (and handling of those)
*   JSON (considerations for versioning data structures)
*   Publishing APIs

Interesting (though a bit dated) discussion at SO:
https://stackoverflow.com/questions/389169/best-practices-for-api-versioning

---

### Why version APIs?
[Icon: Yellow circle]
*   Maintain compatibility of APIs with API consumers, as APIs change
*   Add / amend functionality/services
*   Performance improvements e.g., reduce the number of HTTP requests
*   Market testing of ideas e.g., A/B testing
*   System testing e.g. dev, test, prod
*   Subsets of clients, e.g.,
    *   B2B vs B2C
    *   Geographical / political region
*   Rollback of (unacceptable) API
*   From client perspective:
    *   API is backward compatible if client can continue through service changes
    *   Forward compatible if client can be changed without needing service change (This is less common terminology; usually forward compatibility refers to a newer client working with an older server, or an older server gracefully handling requests with new, unknown parameters.)

---

### Semantic versioning: MAJOR.MINOR.PATCH
[Icon: Yellow circle]
1.  Caching - want different versions cached differently
2.  Number or name?
    *   If number, what format? Semver? Counter?

[Image: An arrow pointing from "If number, what format?" to "Semantic Versioning - semver.org"]

Given a version number MAJOR.MINOR.PATCH, increment the:
*   **MAJOR** version when you make **incompatible** API changes,
*   **MINOR** version when you add functionality in a **backwards-compatible** manner, and
*   **PATCH** version when you make **backwards-compatible** bug fixes.
(from semver.org)

---

### Specifying API version in HTTP request
[Icon: Yellow circle]
*   **Query parameter**
    *   `?v=xx.xx` or `?version=xx.xx` or `?Version=2015-10-01`
    *   e.g., Amazon, NetFlix
*   **URI**
    *   `api/v1/`
    *   e.g. Facebook: `https://graph.facebook.com/v2.2/me/adaccounts`
    *   Semantically messy (implies version refers to version of object, not API)
*   **Header**
    *   `Accept` header - hard to test - can't just click on link or type URL (e.g., `Accept: application/vnd.example.v2+json`)
    *   Custom request header - duplicates `Accept` header function (e.g., `X-API-Version: 2`)
    *   E.g., GitHub: `https://developer.github.com/v3/media/` (uses Accept header with custom media types)

---

### Publishing an API
[Icon: Yellow circle]
*   **Documentation** - current, accurate, easy, guide/tutorial/directed (management tool generated)
*   **Direct access** (no SDK required)
    *   e.g., through Postman or curl (say, `curl -L http://127.0.0.1:4001/v2/keys/message -XPUT -d value="Hello world"`)
*   **SDKs/Samples** in developer preferred languages
    *   Any SDK is just libraries to access REST/SOAP API, nothing more. Potentially an impediment to simply making use of the straight API.
    *   Straightforward install and use
*   **Free/Freemium** use for developers
*   **Instant API keys**
*   **Simple sandbox** to try things out for developers
*   Before API available, establish **API landing page** on web to discover interest and potential user types

---
---

# SENG 365 Week 5
## GraphQL and API Testing

[Icon: Lightbulb]

---

### This week
[Icon: Thumbtack]
*   More info on assignment
*   GraphQL
*   API testing

---

## More info on Assignment 1
[Icon: Yellow circle]

---

### Getting started (Assignment 1)
[Icon: Yellow circle]
*   Some of the endpoints rely on other endpoints
*   E.g. you cannot do a POST request to create a new film until you have logged in
    *   You will get a 401 unauthorized error
*   Where to start?
    *   Implementing user endpoints
    *   Other GET requests that do not rely on user authentication

---

### Example routes code (in JS)
[Icon: Yellow circle]
```javascript
// Line 1
const venues = require('../controllers/venues.controller');
// Line 2
const authenticate = require('../middleware/authenticate');
// Line 3
// Line 4
module.exports = function (app) {
// Line 5
    app.route(app.rootUrl + '/venues')
// Line 6
        .get(venues.search)
// Line 7
        .post(authenticate.loginRequired, venues.create);
// Line 8
// Line 9
    app.route(app.rootUrl + '/venues/:id')
// Line 10
        .get(venues.viewDetails)
// Line 11
        .patch(authenticate.loginRequired, venues.modify);
// Line 12
// Line 13
    app.route(app.rootUrl + '/categories')
// Line 14
        .get(venues.getCategories);
// Line 15
};
```

---

### Example controller code (in JS)
[Icon: Yellow circle]
```javascript
// Line 45
exports.viewDetails = async function (req, res) {
// Line 46
    try {
// Line 47
        const venue = await Venues.viewDetails(req.params.id);
// Line 48
        if (venue) {
// Line 49
            res.statusMessage = 'OK';
// Line 50
            res.status(200)
// Line 51
               .json(venue);
// Line 52
        } else {
// Line 53
            res.statusMessage = 'Not Found';
// Line 54
            res.status(404)
// Line 55
               .send();
// Line 56
        }
// Line 57
    } catch (err) {
// Line 58
        if (!err.hasBeenLogged) console.error(err);
// Line 59
        res.statusMessage = 'Internal Server Error';
// Line 60
        res.status(500)
// Line 61
           .send();
// Line 62
    }
// Line 63
};
```

---

### Example model code (in JS)
[Icon: Yellow circle]
```javascript
// Line 142
exports.viewDetails = async function (venueId) {
// Line 143
    const selectSQL = 'SELECT venue_name, city, short_description, long_description, date_added, ' +
// Line 144
                      'address, latitude, longitude, user_id, username, venue.category_id, category_name, category_description ' +
// Line 145
                      'FROM venue ' +
// Line 146
                      'JOIN user ON admin_id = user_id ' +
// Line 147
                      'JOIN VenueCategory ON venue.category_id = VenueCategory.category_id ' +
// Line 148
                      'WHERE venue_id = ?';
// Line 149
// Line 150
    try {
// Line 151
        const venue = (await db.getPool().query(selectSQL, venueId))[0];
// Line 152
        if (venue) {
// Line 153
            const photoLinks = await exports.getVenuePhotoLinks(venueId);
// Line 154
            return {
// Line 155
                'venueName': venue.venue_name,
// Line 156
                'admin': {
// Line 157
                    'userId': venue.user_id,
// Line 158
                    'username': venue.username
// Line 159
                },
// Line 160
                'category': {
// Line 161
                    'categoryId': venue.category_id,
// Line 162
                    'categoryName': venue.category_name,
// Line 163
                    'categoryDescription': venue.category_description
// Line 164
                },
// Line 165
                'city': venue.city,
// Line 166
                'shortDescription': venue.short_description,
// Line 167
                'longDescription': venue.long_description,
// Line 168
                'dateAdded': venue.date_added,
// Line 169
                'address': venue.address,
// Line 170
                'latitude': venue.latitude,
// Line 171
                'longitude': venue.longitude,
// Line 172
                'photos': photoLinks
// Line 173
            };
// Line 174
        } else {
// Line 175
            return null;
// Line 176
        }
// Line 177
    // } catch (err) { ... }
```

---

### Authentication (Middleware example)
[Icon: Yellow circle]
```javascript
// Line 27
exports.loginRequired = async function (req, res, next) {
// Line 28
    const token = req.header('X-Authorization');
// Line 29
// Line 30
    try {
// Line 31
        const result = await findUserIdByToken(token);
// Line 32
        if (result === null) {
// Line 33
            res.statusMessage = 'Unauthorized';
// Line 34
            res.status(401)
// Line 35
               .send();
// Line 36
        } else {
// Line 37
            req.authenticatedUserId = result.user_id.toString();
// Line 38
            next();
// Line 39
        }
// Line 40
    } catch (err) {
// Line 41
        if (!err.hasBeenLogged) console.error(err);
// Line 42
        res.statusMessage = 'Internal Server Error';
// Line 43
        res.status(500)
// Line 44
           .send();
// Line 45
    }
// Line 46
};
```

---

### Some advice #1
[Icon: Yellow circle]
*   We are testing against the **API specification**
*   Be **clear** about what you are trying to achieve with **each function**
*   Ensure npm packages have been added to **package.json**
*   Remember to do an `npm install` when doing a clean test deploy
*   Be aware of your **npm dependencies**
    *   Dependencies in `dev` vs dependencies for `prod` e.g. nodemon
*   Remember the prefix to the URL, `/api/v1`
*   Check against the **latest version** of the API specification
    *   Am I using the correct parameters? Are they formatted correctly?

---

### Some advice #2
[Icon: Yellow circle]
*   How are you handling photos?
    *   Do you need to add a photo directory to git?
    *   `/storage/photos` is tracked, but the contents are not…
    *   Make sure that you use correct mime type for images, e.g. `image/png`
    *   Use `mz/fs` (or similar) to handle file reading and writing of image files from filesystem: https://www.npmjs.com/package/mz
*   Test against the reference server

---

### Some advice #3
[Icon: Yellow circle]
*   Encrypting password in database
    *   Best practice to use existing library, e.g. **bcrypt**
    *   https://www.npmjs.com/package/bcrypt
    *   We will test that you are not storing the password in plain text
*   Generate authentication token
    *   Several options: e.g. **rand-token**:
    *   https://www.npmjs.com/package/rand-token

---

[Image: Logo for GraphQL (pink geometric shape) next to a stylized logo for REST (curly braces around "REST").]

---

### Endpoints and client views
[Icon: Yellow circle]
*   Endpoints tend to be designed and structured according to the views expected to be needed on the front-end
    *   e.g. we design request parameters (query & body) and the response’s JSON structure to fit the view
*   That’s an efficient design…
… **EXCEPT THAT**…
*   Views change
*   Users want different information, more information, less information, more and less views
*   The fit between endpoint/s and view/s therefore disintegrates

[Diagram:
Initially: Client and Server have a well-defined, somewhat rigid communication interface (represented by straight parallel lines).
Later: Client views become more complex and varied (represented by jagged, diverging lines), while the Server interface might not have adapted as quickly, leading to a mismatch.
]

---

### RESTful APIs and their limitations
[Icon: Yellow circle]
*   Fetching complicated data structures requires **multiple round trips** between the client and server.
    *   An example set of requests:
        `/auctions/{id}`
        `/auctions/{id}/bids`
        `/users/…`
        `/auctions/{id}/photos`
*   For mobile applications operating in **variable network conditions**, these multiple roundtrips are highly undesirable.

---

### Overfetching and underfetching
[Icon: Yellow circle]
**Overfetch**: Download more data than you need
*   e.g. you might only need a list of usernames, but `/users` downloads (as a JSON object) more data than just usernames
*   And endpoint provides more than you need

**Underfetch**: download less than you need so must then do more (the n+1 problem)
*   e.g. you need a list of most recent three friends for a username, so for each item in `/users` you need to get information from `/user/friends`, but then only take the first three entries

---

### RESTful APIs and their limitations cont.
[Icon: Yellow circle]
*   REST endpoints are usually **weakly-typed** and lack **machine-readable metadata**.
    *   An example of the confusion:
        `eventStartTime integer`
        Why integer and not Date?
        Mapping from integer to date and time?
    *   `POST /events` API, is `startingTime` the same as the `event_startingtime` in the events table?

---

### GraphQL
[Icon: Yellow circle]
*   A specification for:
    *   How you specify data (cf. strong-typing)
    *   How you query that data
*   There are reference implementations of the GraphQL specification
    *   https://github.com/graphql/graphql-js (Node.js)
*   Extra lab on LEARN (not pre-req for assignment)

---

### GraphQL simple example
[Icon: Thumbtack]

**Comments**
*   `Character` is a GraphQL Object Type that has fields
*   `name` and `appearsIn` are the fields
*   `String` is a scalar type (a base type that’s irreducible)
*   `[Episode]!` is an array `[]` that’s non-nullable (due to the `!`)
*   Each `type Query` specifies an entry point for every GraphQL query.

**Example (of API)**
```graphql
type Character {
  name: String!
  appearsIn: [Episode]!
}

type Query {
  hero: Character
}
```

---

### GraphQL vs REST
[Icon: Thumbtack]

**GraphQL**
*   Define objects and fields that can be query-able
*   Define **entry points** for a query
*   The client application can dynamically ‘compose’ the content of the query
*   A much more flexible interface to the server side.

**REST**
*   Endpoints that are set and inflexible
*   Pre-defined fixed endpoints that
    *   Require pre-defined inputs
    *   Return pre-defined data structures
*   Those endpoints are then ‘set’…
    *   … until version x.y.z of the API

---

### GraphQL vs REST response codes
[Icon: Thumbtack]

**GraphQL**
*   All GraphQL queries return **200 response code**, even errors.
    *   E.g. malformed query, query does not match schema, etc.
*   Errors are returned in user-defined field (typically an `errors` array in the JSON response)
*   Network errors can still return 4xx/5xx
    *   E.g. GraphQL server is down
```json
{
  "data": {
    "getInt": 12,
    "getString": null
  },
  "errors": [
    {
      "message": "Failed to get string!",
      // ...additional fields...
    }
  ]
}
```

**REST**
*   HTTP response code indicates success / error
*   2xx, 4xx, 5xx, etc.

---

### GraphQL and data
[Icon: Yellow circle]
*   Does not require you to think in terms of graphs
    *   You think in terms of **JSON-like structures** for a query (see earlier slide)
*   Is not querying the database directly
    *   Rather is a **‘language’ (specification)** for composing queries to a server
*   Still requires some kind of **pre-defined data and queries** on the server-side
    *   Objects, fields and allowable queries
    *   But these pre-definitions are more ‘atomic’ in their nature

---

### REST vs GraphQL requests
[Image: Diagram comparing REST and GraphQL data fetching for a similar task.
**REST Client:**
1. `GET /albums/album_id/assets` -> Server returns `data: [{id:1, url:'...'}, {id:2, url:'...'}]`
2. For each asset: `GET /assets/asset_id/comments` -> Server returns `data: [{author_id:32, text:'...'}, {author_id:243, text:'...'}]`
Many requests to REST Server.

**GraphQL Client:**
Sends a single request to GraphQL Server:
```graphql
{
  assets(<album_id>) {
    id,
    url,
    comments {
      text
    }
  }
}
```
GraphQL Server returns:
```json
{
  "assets": [
    { "id": 1, "url": "...", "comments": [{ "text": "..."}]},
    { "id": 2, "url": "...", "comments": [{ "text": "..."}]}
  ]
}
```
One request to GraphQL Server.
]

---

### GraphQL uses GET and POST
[Icon: Yellow circle]

**GET**
GraphQL query is specified using the URL query parameters
`http://myapi/graphql?query={me{name}}`

**POST**
Specify the query in the HTTP body, using JSON
```json
{
  "query": "...",
  "operationName": "...",
  "variables": {
    "myVariable": "someValue",
    // ...
  }
}
```

---

### GraphQL can sit in front of REST API(s)
[Image: Diagram showing a Client, which communicates with a GraphQL Server. The GraphQL Server, in turn, can communicate with one or more REST Servers.]

---

### GraphQL additional resources
[Icon: Yellow circle]
*   GraphQL Introduction
    *   https://graphql.org
*   Express + GraphQL
    *   https://www.npmjs.com/package/express-graphql
*   Apollo GraphQL Server
    *   https://www.apollographql.com/docs/apollo-server/
*   From REST to GraphQL
    *   https://0x2a.sh/from-rest-to-graphql-b4e95e94c26b

---

## Automated API Testing
[Icon: Yellow circle highlighting "Testing"]

---

### API testing
[Icon: Yellow circle]
[Image: Logos for Chai (a teacup) and Mocha (a coffee cup color scheme).]
*   **Postman** tests - Javascript console for testing API endpoints
*   **Mocha + Chai**
    *   Packages for automated testing Node.JS code
    *   Can be used with continuous integration/deployment (CI/CD) environments, such as GitLab Runner
    *   Mocha - Asynchronous testing environment
    *   Chai - Assertion library
    *   https://www.digitalocean.com/community/tutorials/test-a-node-restful-api-with-mocha-and-chai

---

### Mocha + Chai setup
[Icon: Thumbtack]
*   Can have one test file
*   For multiple test files:
    *   Mocha runs test files in order of occurrence (depends on OS’s file systems)
    *   Depends on how defined in `package.json`
*   Each test (even multiple tests in one test file):
    *   Is intended to be independent
    *   Runs asynchronously

[Image: File tree structure showing a `tests` directory with `template.js`, `test.a.database.js`, `test.b.users.unauth.js`, etc. Also shows `package.json`.]

---

### Separate test project (package.json scripts)
[Icon: Yellow circle]
In `package.json`
```json
{
  // ...
  "scripts": {
    "start": "mocha ./tests/test.*.js --reporter spec --log-level=warn",
    "test": "mocha ./tests/test.a.file.js --reporter spec --log-level=warn"
  },
  // ...
}
```
Given the above:
`npm start` will run all my test files (matching `test.*.js`)
`npm test` will run a particular test file (that I have specified, `test.a.file.js`)

---

### Asynchronous behavior when testing
[Icon: Yellow circle]
*   You can setup pre- and post-conditions
    *   `before()`, `beforeeach()`, `after()`, etc
*   Mocha, Chai and Chai-HTTP can handle callbacks, and Promises (and async/await)
    *   Don’t get these mixed up in a given test
    *   Avoid the use of `return` together with `done()`

---

### A single test using a Promise
[Icon: Yellow circle]
```javascript
describe('Test case:/POST/login with parameters in query string', () => {
    it('Should return 200 status code, id and authorisation token', function () {
        return chai.request(server_url)
            .post('/users/login')
            .query({
                username: 'testUsername4',
                email: 'user4@testexample.com',
                password: 'testpassword'
            })
            .then(function(res){
                expect(res).to.have.status(200);
                expect(res).to.be.json;
                expect(res.body).to.have.property('id');
                expect(res.body).to.have.property('token');
                authorisation_token = res.body['token']; //use in subsequent test
                user_id = res.body['id']; //use in subsequent test
            })
            .catch(function (err) {
                expect(err).to.have.any.status(400, 500); // Or specific error status
                throw err; // // there is any error
            });
    });
});
```

---

### A single test using old-style callbacks
[Icon: Yellow circle]
```javascript
describe('Test case: ' + test_case_count + ': POST /users', () => {
    it('Callback with done(): Should return 400 or 500 as there was a duplicate entry', (done) => {
        chai.request(server_url)
            .post('/users')
            .send({
                username: "testUsername4",
                givenName: "testGivenName",
                familyName: "testFamilyName",
                email: "user4@testexample.com",
                password: "testpassword"
            })
            .then(function (res) {
                expect(res).to.have.any.status(201); // is this line really needed?
                done(new Error("Status code 201 returned unexpectedly")); // //test completed but failed
            })
            .catch(function (err) {
                expect(err).to.have.any.status(400,500);
                done(); // test completed as it should / as it was expected to complete
            });
    });
});
```

---

### Tests are asynchronous
[Icon: Yellow circle]
*   With the assignment, for example, you would be testing a **network request** to a server that is then making a **database request**
*   You **don’t know when** the network request or the database request will **complete**
    *   Therefore you don’t know when the test will complete
*   You **shouldn’t assume** that test n+1 will complete before test n+2 starts
    *   Which is why you have `before()`, `beforeeach()`, `after()` etc.
*   Need to be careful with the **dependencies between tests**
*   Need to be careful on how you **report the progress of tests**, because the report may not output synchronously with completion of the test itself

---

### Testing for expected success and expected failure
[Icon: Yellow circle]
*   Often we test to corroborate that something completes as we expected
    *   e.g. that `user/login` is successful as expected: the user logs in
*   We also need to test that the system rejects/doesn’t complete as expected
    *   e.g. that `user/login` is unsuccessful as expected: the user is not logged in
*   Need to think carefully about:
    *   `.then()`, `catch()`, `done()`, `done(err)`, and/or `throw err;`

---

### Passing tests does not always mean intended behavior
[Icon: Yellow circle]

|                       | Actual behavior: successful | Actual behavior: failed |
|-----------------------|-----------------------------|-------------------------|
| **Intended behavior: successful** | **The test passed**         | **The test failed**     |
| **Intended behavior: failure**    | **The test failed**         | **The test passed**     |

---
---
```
```markdown
# SENG 365 Week 6
## Security and Intro to client side

[Icon: Lightbulb]

---

### This week
[Icon: Thumbtack]
*   Brief primer on Security issues
*   Introduction to client-side technologies and concepts

---

## Security for Web Apps
[Icon: Yellow circle]
**Brief Introduction**

---

[Image: OWASP (Open Web Application Security Project) logo - a stylized blue wasp.]
https://owasp.org
https://www.meetup.com/OWASP-New-Zealand-Chapter-Christchurch/

---

### Open Web Application Security Project (updated 2020)
[Icon: Yellow circle]
**Top 10 security problems**
1.  Injection
2.  Broken Authentication
3.  Sensitive Data Exposure
4.  XML External Entities (XXE)
5.  Broken Access Control
6.  Security Misconfiguration
7.  Cross-Site Scripting (XSS)
8.  Insecure Deserialization
9.  Using Components with Known Vulnerabilities
10. Insufficient Logging and Monitoring

*(Note: The OWASP Top 10 is updated periodically. The slide mentions "updated 2020", but the most recent at the time of this conversion is OWASP Top 10 2021. The list items might differ slightly.)*

---

### Injection
[Icon: Yellow circle]
Injection flaws allow attackers to relay malicious code through an application to another system e.g. SQL injection.
https://www.owasp.org/index.php/Injection_Flaws

[Image: XKCD comic "Exploits of a Mom" (Bobby Tables).
Panel 1: Mom on phone: "HI, THIS IS YOUR SON'S SCHOOL. WE'RE HAVING SOME COMPUTER TROUBLE."
Panel 2: Mom on phone: "OH, DEAR - DID HE BREAK SOMETHING? IN A WAY -"
Panel 3: School admin: "DID YOU REALLY NAME YOUR SON Robert'); DROP TABLE Students;-- ?" Mom: "OH, YES. LITTLE BOBBY TABLES, WE CALL HIM."
Panel 4: School admin: "WELL, WE'VE LOST THIS YEAR'S STUDENT RECORDS. I HOPE YOU'RE HAPPY." Mom: "AND I HOPE YOU'VE LEARNED TO SANITIZE YOUR DATABASE INPUTS."
]

---

### Injection
[Icon: Yellow circle]
*   **Any time** an application uses an **interpreter of any type** there is a danger of introducing an injection vulnerability.
*   When a web application passes information from an **HTTP request** through as part of an external request, it must be **carefully scrubbed**
*   **SQL injection** is a particularly widespread and dangerous form of injection

---

### Example: Command Injection
[Icon: Yellow circle]
*   Assume that we have a Java class (on the server) that gets input from the user via a HTTP request, and that class goes on to use the Java Runtime object to make an MS-DOS call
    ```java
    Runtime rt = Runtime.getRuntime();
    // Call exe with userID
    rt.exec("cmd.exe /C doStuff.exe " + "-" + myUid);
    ```

---

### Example: Command Injection (continued)
[Icon: Yellow circle]
```java
Runtime rt = Runtime.getRuntime();
// Call exe with userID
rt.exec("cmd.exe /C doStuff.exe " + "-" + myUid);
```
When `myUid = Joe69`, we’d get the following OS call:
`> doStuff.exe -Joe69`

When `myUid = Joe69 & netstat –a`, we’d get:
`> doStuff.exe -Joe69`
`> netstat –a // “&” is command appender in MS-DOS`

---

### Basis of all injections…
[Icon: Yellow circle]
*   All injection flaws are **input validation** errors.
    *   i.e. you’re not checking the input properly
*   Input is **not just text fields**
*   All **external input** is a source of a **threat**.
    *   The input contains the data with the threat
    *   Examples: text fields, list boxes, radio buttons, check boxes, cookies, HTTP header data, HTTP post data, hidden fields, parameter names and parameter values

---

### Validate … and re-validate
[Icon: Yellow circle]
*   An input field is likely to be **validated on the client side**, e.g., that an IDNumber textfield contains a number rather than a number plus malicious code.
    *   What happens to that data **between the client and the server?**
*   Sometimes it’s **hard to validate**. Consider edge cases.
*   Sometimes there are **multiple clients** e.g. you’re offering a public web service to clients.
*   Should you safely assume that the input data is valid because it was **previously validated?** (No, always re-validate on the server.)

---

### Authentication
[Icon: Yellow circle]
*   **Definitions**
    *   **Authentication**: establish claimed identity
    *   **Authorisation**: establish permission to act
    *   Authentication precedes authorisation
*   **Why** authenticate?
    *   Control access to resources
    *   Log user activity
    *   Non-repudiation
*   **How** can we authenticate?
    *   Three factors: something you know, have, or are

---

### Securing passwords
[Icon: Yellow circle]
*   Hash username and password
*   Require users to change their passwords regularly
*   Use multi-factor authentication
    *   Username & password
    *   Code sent by phone
*   Salt the username and password
    *   Add additional elements to the ID information before hashing
*   Use HTTPS (HTTP + TLS)

---

### Secure Sockets Layer (SSL) / Transport Layer Security (TLS)
[Icon: Yellow circle]
*   Standard for encrypting internet traffic
*   **Transport Layer Security (TLS)** is the successor to SSL
*   Also authenticates identity of website (via certificates)
*   **HTTPS**: HTTP + SSL/TLS
*   Uses port **443** by default
*   More detail in COSC 362/SENG 406

---

[Diagram: Layered boxes illustrating security concepts.]
**HTTP is a “stateless” protocol**
*   Means credentials have to go with every request (or a token representing them)
*   Should use SSL for everything requiring authentication

**Session management flaws**
*   SESSION ID used to track state since HTTP doesn’t
*   and it is just as good as credentials to an attacker if stolen
*   SESSION ID is typically exposed on the network (if not HTTPS), in browser, in logs, …

**Beware the side-doors**
*   Change my password, remember my password, forgot my password, secret question, logout, email address, etc… (These are all potential attack vectors if not secured.)

**Typical Impact**
*   User accounts compromised or user sessions hijacked

---

[Diagram: Layered boxes with verification steps.]
**Verify your architecture**
*   Authentication should be simple, centralized, and **standardized**
*   Use the standard session id provided by your container/framework
*   Be sure SSL protects both credentials and session id **at all times**

**Verify the implementation**
*   Forget automated analysis approaches (for finding all flaws; they are a tool, not a silver bullet)
*   Check your SSL certificate
*   Examine all the authentication-related functions
*   Verify that logoff actually destroys the session
*   Use OWASP’s WebScarab (or similar tools like ZAP, Burp Suite) to test the implementation

**Follow the guidance from**
*   https://www.owasp.org/index.php/Authentication_Cheat_Sheet

---

### OWASP Tutorials
[Icon: Yellow circle]
Learn more here (or take SENG 406)
https://owasp.org/www-project-web-security-testing-guide/

---

### Summary of server-side
[Icon: Yellow circle]

**Lectures**
*   HTTP requests & responses
*   APIs, endpoints & API-driven design
*   The server itself
*   e.g. Node.js & express & node packages
*   Data persistence e.g. MySQL

**Labs and additional tutorials**
*   JavaScript, TypeScript
*   Node.js + Express
*   Data persistence
*   APIs
*   GraphQL
*   OWASP

---

## Introduction to Client-side
[Icon: Yellow circle]

---

[Image: Screenshot of the Stuff.co.nz news website.]
**What is the user experience in the browser?**

What kind of contents ‘appear’ in the browser?
1.  What the user sees?
2.  How the content is described? (‘view source page’)

How is that content presented?
*   Colours, styles, etc.

---

[Diagram: The reference model diagram is shown again. A dotted arrow points from the "Server (Express, Node.js)" box to the "Client (HTML, CSS, JS)" box, with the question:
**What does the client-side app need to do to assemble the data from the API endpoints into coherent, interactive ‘pages’ for the user?**
]

---

[Image: Logos for HTML5, CSS3, and JavaScript (JS shield slightly faded).]
**Introduction to the main client-side technologies**

---

[Image: JavaScript (JS shield) logo.]
**Client-side: JavaScript**

---

### But note… (JavaScript's nature)
[Icon: Yellow highlighting "But note..."]
“Unlike most programming languages, the [core|original] JavaScript language has **no concept of input or output**. It is designed to **run as a scripting language in a host environment**, and it is up to the **host environment to provide mechanisms*** for communicating with the outside world.”
https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript
\* e.g. more APIs (like DOM API, Fetch API)

---

### … the full quote:
[Icon: Yellow highlighting "... the full quote:"]
“Unlike most programming languages, the JavaScript language has **no concept of input or output**. It is **designed to run** as a scripting language **in a host environment**, and it is up to the **host environment to provide mechanisms** for communicating with the outside world.

The **most common host environment is the browser**, but JavaScript interpreters can also be found in a huge list of other places, including Adobe Acrobat, Adobe Photoshop, SVG images, Yahoo's Widget engine, server-side environments such as **Node.js**, NoSQL databases like the open source **Apache CouchDB**, embedded computers, complete desktop environments like **GNOME** (one of the most popular GUIs for GNU/Linux operating systems), and others.”
https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript

---

### JavaScript + browser !== JavaScript + Node.
[Icon: Yellow highlighting "With JS + browser:"]
*   You’re dealing with a user!
*   Input and output via HTML & CSS (& DOM)
*   Deployment of your app is different:
    *   Which browser, or version.
    *   Network-connection quality.
    *   Whether cookies are enabled.
    *   The computing power of the hosting machine.
*   Different APIs in browser
    *   AJAX (XHR)
*   Dependencies on libraries
    *   ‘importing’ JS libraries is different
        *   e.g. CDN vs npm install
    *   What about node packages…? (Need bundlers like Webpack/Parcel for browser use)
*   Project structure is different
    *   JS, HTML, CSS, other assets
*   Similar terminology, different meaning
    *   e.g. “routes” & “routing” (client-side routing vs server-side routing)

---

[Image: HTML5 logo.]
**Client-side: HTML**

---

### What is HTML?
[Icon: Yellow highlighting "What is HTML?"]
“**HTML** (HyperText Markup Language) is the most basic building block of the Web. It describes and defines the **content** of a webpage. Other technologies besides HTML are generally used to describe a webpage's appearance/presentation (**CSS**) or functionality (**JavaScript**).”
(https://developer.mozilla.org/en-US/docs/Web/HTML)

*   Be careful about the difference between **content** and **data**.
*   Also, be careful about your concept of a **webpage**. What constitutes a ‘web page’ has changed over time.

---

### Yeah, okay, but what is HTML?
[Icon: Yellow highlighting "Yeah, okay, but what is HTML?"]
*   HTML is a **declarative ‘language’**, comprising:
*   A declaration of a document type (HTML), together with a *hierarchical* structure of (nested) HTML elements, where
    *   **elements** are identified by **tags**, and
    *   elements typically contain some kind of **content** (to display), and where
    *   elements may have **attributes**, in which
    *   attributes define **characteristics** of elements,
    *   attributes often have **values** (for the characteristics),
    *   attributes allow **cross-referencing** to CSS and JavaScript, and
    *   attributes may be **custom-defined**.
(HTML5 introduced many new elements)

---

### Basic example of HTML page
[Icon: Yellow highlighting "Basic example of HTML page"]
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>A title</title>
</head>
<body>
</body>
</html>
```
HTML comprises:
*   Document type declaration
*   Elements, organised into a hierarchy, e.g.
    *   `<html>`
    *   `<head>`
    *   `<body>`
*   Attributes of elements, with values
    *   `lang="en"`

---

[Image: Diagram showing the hierarchical structure of an HTML document: `document` -> `<html>` -> `<head>` (Head part here) and `<body>` (Body part here).]
http://www.corelangs.com/html/introduction/img/html-page-structure.png

---

[Image: A simple HTML document structure on the left, and a visual representation of its rendered parts on the right.
Left (Code):
```html
<HTML>
  <HEAD>
    <TITLE>Title Text</TITLE>
  </HEAD>
  <BODY>
    <H1>H1 Heading</H1>
    <P>Paragraph 1</P>
    <P>Paragraph 2</P>
  </BODY>
</HTML>
```
Right (Visual Blocks):
Document (HTML)
  Head
    Title Text
  Body
    H1 Heading
    Paragraph 1
    Paragraph 2
]

---

### HTML elements
[Icon: Yellow circle]
[Image: A picture of stacked turtles. Overlay text: "Javascript callbacks are turtles all the way down."]
For example, if we wanted to write the following on a web page:
Javascript callbacks are turtles all the way down.

`<p>Javascript callbacks are turtles all the way down.</p>`
[Diagram breaking down the `<p>` tag:
`Opening tag`: `<p>`
`Content`: `Javascript callbacks are turtles all the way down.`
`Closing tag`: `</p>`
The whole thing is the `Element`.
]

---

### HTML elements & their attributes
[Icon: Yellow circle]
[Image: A picture of stacked turtles.]
For example, if we wanted to write the following on a web page:
Javascript callbacks are turtles all the way down.

`<p class="comment">Javascript callbacks are turtles...</p>`
[Diagram breaking down the `<p class="comment">` tag:
`Attribute`: `class="comment"`
  `Name`: `class`
  `Value`: `"comment"`
]

---

### Nested HTML elements
[Icon: Yellow circle]
[Image: A picture of stacked turtles.]
For example, if we wanted to write the following on a web page:
Javascript callbacks are **turtles** all the way down.

`<p>Javascript callbacks are <strong>turtles</strong> ...</p>`
[Diagram showing `<strong>turtles</strong>` as a `Nested element` within the `Content` of the `<p>` element.]

---

### One way to change HTML content: JavaScript
[Icon: Yellow circle]
**HTML: before**
`<p id="four">Oh, cruel world.</p>`

**JavaScript**
`document.getElementById("four").innerHTML = "Hello world!";`

**HTML: after** (in the browser's DOM)
`<p id="four">Hello world!</p>`

---

### Custom attributes (we’ll come back to this)
*   You can define your own attributes for elements
*   HTML5 offers `data-*` attribute
    *   Where `*` is a string of characters of your choice
    *   But potential for name clashes with other JavaScript libraries
        *   I define `data-student` in my `student.js` library, and
        *   You define `data-student` in your `super-student.js` library
*   Frameworks use custom-defined attributes as part of their two-way binding ‘magic’
    *   Angular has `ng-*` attributes
    *   Vue has `v-*` attributes

---

### Pointers elsewhere (HTML)
Validate your HTML at:
https://validator.w3.org/

Further information on HTML5 elements:
https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5

---

[Image: CSS3 logo.]
**Client-side: CSS**
A (declarative) ‘language’ for specifying how contents are **presented** to a user.

---

### What is CSS?
A set of rules for specifying how content of a web page should look, where:
*   A rule typically comprises:
    *   a **selector**, and
    *   a set of **properties and values** for how HTML content should be presented
*   There are selectors for:
    *   **Attributes** e.g. select on attribute name (`[type="text"]`)
    *   **Element/s** e.g. select on element type (`p`, `h1`)
*   CSS can be contained in:
    *   An external style sheet (recommended)
    *   An internal style sheet (sometimes okay)
    *   An inline style (not recommended)

---

### Examples of rules
```css
h1 {
  color: blue;
  background-color: yellow;
  border: 1px solid black;
}

p {
  color: red;
}
```
**Example 1 (h1)**
*   Select (all) `<h1>` elements, and
*   Set three properties: `color`, `background-color`, and `border`

**Example 2 (p)**
*   Select (all) `<p>` elements
*   Set one property: `color`

---

### CSS can be contained in:
*   An **external style sheet** (recommended)
    ```html
    <head>
        <meta charset="utf-8">
        <title>Blah</title>
        <link rel="stylesheet" href="style.css">
    </head>
    ```
*   An internal style sheet (sometimes okay)
*   An inline style (not recommended)

---

### CSS can be contained in:
*   An external style sheet (recommended)
*   An **internal style sheet** (sometimes okay)
    ```html
    <head>
        <title>Blah blah</title>
        <style>
            h1 {
                color: blue;
                background-color: yellow;
                border: 1px solid black;
            }
            p {
                color: red;
            }
        </style>
    </head>
    ```
*   An inline style (not recommended)

---

### CSS can be contained in:
*   An external style sheet (recommended)
*   An internal style sheet (sometimes okay)
*   An **inline style** (not recommended)
    ```html
    <body>
        <h1 style="color: blue;background-color: yellow;border: 1px solid black;">Hello World!</h1>
        <p style="color:red;">Javascript callbacks are turtles all the way down.</p>
    </body>
    ```

---

[Image: A single jigsaw puzzle piece on a gritty background. Text overlay: "How the client-side technologies fit together"]

---

### JavaScript, HTML, CSS, DOM…
[Icon: Yellow circle]
[Diagram showing the browser rendering pipeline:
Network request -> HTML (and Other resources like images) -> DOM
Network request -> CSS -> CSSOM
DOM and CSSOM -> JavaScript (can manipulate both)
DOM and CSSOM -> Render (tree) -> Layout -> Paint
]
**Advice**
Put CSS at the top in the HTML HEAD
Put JavaScript at the bottom of the page (before `</body>`)

---

### HTML, CSS and JavaScript (Relationships)
*   **HTML** has elements
    *   Many pre-defined
    *   Define your own:
        *   custom attributes (`data-*`)
*   **Elements** can be referenced by
    *   Element type e.g. `<p>`
    *   Unique identifier e.g. `id="…"`
    *   Attribute class e.g. `class="…"`
    *   (Other ways…?) (e.g., other attributes, pseudo-classes)
*   **CSS** has rules that
    *   ‘Apply’ presentation to referenced elements, through selectors
*   **JavaScript**
    *   gets (and sets) …
        *   Element content
        *   Element attributes & values
    *   … based on references to those elements
*   **HTML document** is the primary source
    *   Contains HTML (duh)
    *   Contains CSS or reference to CSS
    *   Contains JS or reference to JS

---

### Content vs data
[Icon: Yellow highlighting "Content vs data" and "Looking ahead:"]
*   **Data** as what is ‘in’ JavaScript data structures e.g. arrays, objects.
    *   And therefore what is in your database too
*   **Content** as what is ‘in’ the HTML elements.
*   Data needs to be **‘injected’** into HTML content e.g. JavaScript setter
*   User entered information needs to be **retrieved** from the rendered fields on screen e.g. JavaScript ‘getters’

**Looking ahead:**
*   **Frameworks** help us do this through **two-way binding**.
    *   ‘Injecting’ data into content; and retrieving content into data

---
---

# SENG 365 Week 7
## Single Page Applications and JavaScript Frameworks

[Icon: Lightbulb]

---

### Outline
[Icon: Yellow circle]
*   Background on Single Page Applications
*   Design patterns
*   Document Object Model (DOM)
*   Introduction to JavaScript frameworks

---

### Timeline of JavaScript Frameworks
[Icon: Yellow circle]
*   **1995** - JavaScript introduced
    *   Poor browser compatibility for several years
*   **2004** - standardized AJAX (Google Gmail)
    *   Beginning of single-page applications (SPAs)
*   **2006** - jQuery
    *   Write JavaScript code without worrying about the browser version
    *   AJAX support
*   **2010s** - MVC* Data-view binding frameworks introduced
    *   Client-side rendering
*   **2010** - AngularJS, Ember.js, Backbone
*   **2013** - React (2015 - Redux)
*   **2014** - Vue.js
*   **2016** - Svelte (compilation to JS)

---

### The move to Single Page Applications
[Icon: Yellow highlighting "Single Page Applications"]
*   Users want **responsiveness & interactivity**; improved user experience
    *   Compare user experience with native apps & stand-alone apps
*   **Managing the interactions** with a user is ***much more complex*** than managing communication with server
    *   Think of all those events (e.g. onClicks) to handle

---

### Single Page Applications (SPAs)
[Icon: Yellow highlighting "SPAs"]
“Single page apps are distinguished by their ability to redraw any part of the UI without requiring a server round trip to retrieve HTML. This is achieved by separating the data from the presentation of data by having a model layer that handles data and a view layer that reads from the models.”
http://singlepageappbook.com/goal.html

---

### Some features of Single Page Applications
[Icon: Yellow highlighting "Separate:", "Reduce communication", "'Page' navigation"]
**Separate:**
*   Data
*   ‘Content’ & Presentation: HTML & CSS (and other resources)

**Reduce communication** with the server/s by:
*   Occasional **download of resources** e.g. HTML, CSS and JavaScript
*   Asynchronous **‘background’ fetching** of data: AJAX / XHR or web sockets
*   **Fetch data only** e.g. JSON
*   Fetch data from different servers: **CORS**

**‘Page’ navigation**
*   **Client-side JavaScript** handles the **routing** instead of the browser itself
    *   Managing **page history**
*   **Routing** within the SPA

---

### Reconceive web application
[Icon: Yellow highlighting "Reconceive web application", "Re-balance workload", "Considerations:"]
**Re-balance workload** across:
*   **Server-side** application
    *   e.g. Node.js
*   **Client-side** application/
    *   Front-end libraries and frameworks e.g. React
**Communication** between client & server
    *   API-driven/specified
    *   e.g. AJAX & JSON

**Considerations:**
*   Manage application **assets / resources**
    *   e.g. dependency management
*   Application **design and implementation**
    *   Modularisation
    *   Design patterns
*   **Templating**

---

[Image: Diagram showing the architectural shift.
User interacts with "React" (representing client-side framework with Resources, Design patterns, Virtual DOM, Templating, Routing).
React communicates with Server (Express, Node.js) via XHR/AJAX, Web sockets, HTTP, CORS (API communication).
Server communicates with Database.
This illustrates the increased responsibility and complexity on the client-side.
]
**The balance of work between client and server changes. And there are new technologies**

---

[Image: Book cover of "Design Patterns: Elements of Reusable Object-Oriented Software" by Gamma, Helm, Johnson, Vlissides (Gang of Four).]
**Design patterns**

---

### Background: Separation of concerns
[Icon: Yellow highlighting "Separation of concerns"]
*   A **design principle** for separating software code into distinct ‘sections’, such that each section addresses a separate concern.
*   A **strategy** for handling complexity
    *   Of the problem
    *   Of the solution e.g. software code
*   **Examples** of separation of concerns:
    *   Object-oriented programming
        *   Classes, objects, methods
    *   Web computing
        *   HTML: structure/organisation of content
        *   CSS: presentation
        *   JavaScript: functionality

---

### Example: data and views of data
[Image: Diagram showing "Data (models) e.g. array, object, NoSQL" (represented as a simple table) transforming (blue arrow) into "Visualisation of data" (represented by a table, a bar chart, and a pie chart).]
**Separation of concerns:**
*   The management of the data e.g. CRUD
*   The visualisation of the data

---

### A generic approach (Model-View-Bridge)
[Icon: Yellow highlighting "A generic approach"]
[Diagram:
View1 (Bar chart) <-> Bridge1 <-> Model1
View2 (Table)   <-> Bridge2 <-> Model1
View1 (Bar chart) <-> Bridge3 <-> Model2
]
*   We want to **display data** to the user in **different ways** e.g. as a bar chart or as a table of data.
*   We want to keep our **data independent** of the way it is **presented**.
*   We may want to **compute additional values** depending on how and why we present data e.g. add a total in our table.
*   We need some **connection** – some ‘bridge’ – between **views and data**.
*   We can **reuse**:
    *   **models** and
    *   **views**.

---

### Variations on a theme of Model-View-{Bridge}*
[Icon: Yellow highlighting "Model-View-{Bridge}*", "MV...", "Commentary"]
**MV...**
*   Model View Controller (MVC)
*   Model View Adaptor (MVA)
*   Model View Presenter (MVP)
*   Model View ViewModel (MVVM)

**Commentary**
(Some) disagreements on what *exactly* defines these design patterns

---

[Image: Diagram showing a UI screen with "Quantity: [ 2 ]". "Screen" is highlighted. An arrow points from "Screen" to "Layout is app specific". An arrow points from the input field "2" to "Widgets are standard".]
http://martinfowler.com/eaaDev/uiArchs.html

---

[Image: Diagram showing "Screen" (Quantity: [ 2 ]) above a line, and "State" ( [ 2 ] ) below the line.]

---

[Image: Diagram showing "Screen" (Quantity: [ 2 ]) with a "Load" arrow coming from "State" ([ 2 ]) below, and a "Save" arrow going to "State".]

---

### Data Binding
[Icon: Yellow highlighting "Screen", "State", "Data binding"]
[Image: Diagram.
Top: "Screen" (Quantity: [ 2 ])
Middle: Two-way arrows labeled "Data binding"
Bottom: "State" ([ 2 ])

Below this, two smaller diagrams:
One way: Screen <- State
Two way: Screen <-> State
]

---

[Image: Diagram.
Top box (Screen): Quantity: [ 2 ]
Middle box (Session state): [ 2 ] (connected by two-way "Data binding" arrows to Screen)
Cloud icon between Middle and Bottom box.
Bottom box (Record state): [ 2 ]
]

---

[Image: Diagram.
Top box (Screen): Quantity: [ 2 ]  Total: [ $70 ]
Middle box (Session state): [ 2 ] (One-way "Data binding" arrow from "Quantity [2]" in Session state to "Quantity [2]" in Screen)
Cloud icon.
Bottom box (Record state): [ 2 ]
]

---

[Image: Diagram.
Top box (Screen): Quantity: [ 2 ] <-> Total: [ $70 ] (Arrow from Quantity to Total implying calculation)
Middle box (Session state): [ 2 ] (One-way "Data binding" arrow from "Quantity [2]" in Session state to "Quantity [2]" in Screen)
Cloud icon.
Bottom box (Record state): [ 2 ]
]

---

### Presentation, Model, Data
[Icon: Yellow highlighting "Screen = Presentation", "Session state = Model", "Record state = Data"]
[Image: Diagram.
Top box (Screen = Presentation): Quantity: [ 2 ] <-> Total: [ $70 ]
  Specific to the UI
  Independent of Domain
Middle box (Session state = Model): [ 2 ] <-Observer-> (Total $70 on screen)
  Independent of UI
  Specific to the Domain
Cloud icon.
Bottom box (Record state = Data): [ 2 ]
]

---

### MVC (Model-View-Controller) Conceptual
[Image: Diagram showing Model ([ 2 ]), View ([ 2 ] on screen), and Controller. Arrows indicate flow: Model updates View, Controller updates Model, View can trigger Controller actions (not explicitly shown but implied by standard MVC).]

---

### MVC:
[Icon: Yellow highlighting "MVC:"]
[Image: Standard MVC diagram: Model <--(MANIPULATES)-- Controller --(USES)--> User --(SEES)--> View --(UPDATES)--> Model (or View is updated by Model/Controller).]
*   \+ Multiple views
*   \+ Synchronized views
*   \+ Pluggable views and controllers
*   \+ Exchangeable look and feel
*   \- Complexity
*   \- Can have lots of updates/notifications
*   \- Links between controller and view
*   \- Coupling of controller/view and model
*   \- Mix of platform-dependent/independent code within controller and view (porting)

---

### MVP (Model-View-Presenter) - View and Controller Interaction
[Image: Diagram showing Model ([ 2 ]), View ([ 2 ] on screen), and Controller. A two-way arrow is now between Controller and View, distinct from the Model.]

---

### MVP (Model-View-Presenter) - Adding Presenter
[Image: Diagram showing Model ([ 2 ]), View ([ 2 ] on screen, as a Widget), Controller, and Presenter. Presenter mediates between Model and View/Controller.
Controller <-> View (Widget)
Presenter -> View
Presenter <-> Model
]

---

### MVC & MVP Comparison
[Icon: Yellow highlighting "MVC & MVP"]
[Image: Side-by-side diagrams.
Left (Model-View-Controller): User Interaction -> View -> (Passes calls to) Controller -> (Manipulates) Model -> (Fires events) View.
Right (Model-View-Presenter): User Interaction -> View -> (Passes calls to) Presenter -> (Manipulates) Model -> (Fires events) Presenter -> (Updates) View.
]
http://joel.inpointform.net/software-development/mvvm-vs-mvp-vs-mvc-the-differences-explained/

---

### MVC versus MVP
*   **MVC** is Model-View-Controller
*   **MVP** is Model-View-Presenter
*   Much hot air expended in defining / comparing / contrasting these.
    *   **MVC**: view is stateless with not much logic. Renders a representation of model(s) when called by controller or triggered by model. Gets data directly from model.
    *   **MVP**: view can be completely isolated from model and rendering data from presenter, or can be a MVC view, or somewhere in between
*   But many variants.
*   Categorisation not very important; you mostly just use whatever tools the framework gives you.
*   The term MV\* may be safer to avoid arguments!

---

### MVVM (Model/View/ViewModel)
[Icon: Yellow highlighting "MVVM"]
[Image: Diagram showing View <--(DataBinding)--> ViewModel <--> Model.
View: Presentation and Presentation Logic
ViewModel: (No specific label, but implies holding view-specific data and logic)
Model: BusinessLogic andData
]
*   **ViewModel** is just the data currently required by the view
    *   In a web context, Model may be on server, View and ViewModel on client
*   **Data binding** synchronises view and viewModel bidirectionally
    *   Uses lower-level "hidden" mechanism

---

### Design pattern summary
[Icon: Yellow circle]
*   **Developing web applications is challenging**
*   **One strategy** to development, and to integration, is to **‘divide and conquer’**
*   **Separate out concerns**
    *   3-tier architecture of browser, server and data store
*   **Separate out concerns**
    *   MV\* as a **design concept**
    *   **Differences of opinion** on what the M, the V and the \* were
    *   **Differences on how** M, V and \* **interact** with each other
    *   Looked at MVC, MVP, MVVM and MVW (Model-View-Whatever)

---

## Data-binding frameworks
[Icon: Yellow circle]
**Angular, React, Vue.JS etc.**

---

### Data binding frameworks (Landscape)
[Image: A 2x2 matrix.
Top-left (Simple, Automatic data binding): Vue.js, React, Aurelia (ES6), AngularJS (1.x)
Bottom-left (Simple, Manual data binding): Knockout.JS, Backbone.JS, jQuery
Top-right (Full stack, Automatic data binding): (Covered by Aurelia, Angular)
Bottom-right (Full stack, Manual data binding): Ember, AngularJS (2.0/Angular ES6)
*(Note: This landscape is a snapshot and might be outdated. Angular 2.0+ is considered full-stack and uses automatic data binding concepts extensively, though it offers more control than AngularJS 1.x.)*
]

---

### Client-side rendering
[Icon: Yellow circle]
*   Renders the page using JS in the browser
*   Logic, data-fetching, templating, and routing handled by browser code
*   First-contentful page (FCP) as JS bundle loaded
*   Time-to-interactive (TTI) after the render function is executed

[Diagram: Timeline showing network request for HTML (bootstrapping), then JS bundle download (GET /bundle.js), leading to FCP. After this, `render(app)` executes, leading to TTI. "Client Rendering (blocked)" is shown during the JS execution phase.]

---

### Templating
[Icon: Yellow circle]
[Image: Code snippets.
Left (HTML):
```html
<div id="counter">
  Counter: {{ counter }}
</div>
```
Right (JS - Vue.js example):
```javascript
const Counter = {
  data() {
    return {
      counter: 0
    }
  }
}
Vue.createApp(Counter).mount('#counter') // Counter: 0
```
An arrow connects `{{ counter }}` in HTML to `counter: 0` in JS, labeled "Counter: 0".]

*   Frameworks such as Angular and Vue use **templating** to map JS variables to HTML elements
*   Data-binding in HTML using **“moustache” syntax**:
    *   Most frameworks use curly braces: `{{data}}`
*   JS, CSS, HTML separate files / sections

---

### Types of data binding
[Icon: Yellow circle]
[Image: Two diagrams.
Left (One-Way Data Binding): Model -> Merge -> View; Template -> Merge -> View.
Right (Two-Way Data Binding): Template -> Compile -> View. View <--(Continuously watch on update)--> Model. Model updates View if model changes, View updates Model if view changes.
]
One way binding can also go the other way: view -> data

---

### DOM (Document Object Model)
[Image: Tree diagram representing the DOM structure of a simple HTML page.
`document` -> `<html>` (Root element)
`<html>` -> `<head>` (Element) and `<body>` (Element)
`<head>` -> `<title>` (Element) -> "My title" (Text)
`<body>` -> `<h1>` (Element) -> "A heading" (Text)
`<body>` -> `<a>` (Element, with attribute `href`) -> "Link text" (Text)
The entire structure is labeled "DOM Document Object Model".
]
“The W3C Document Object Model (DOM) is a platform and language-neutral interface that allows programs and scripts to dynamically access and update the content, structure, and style of a document.” (W3C). The **HTML DOM** : standard model for HTML documents

---

### Examples of DOM ‘sizes’
[Icon: Yellow highlighting "DOM 'sizes'"]

| Website                         | DOM count |
|---------------------------------|-----------|
| www.bbc.com/news                | 2298      |
| Facebook.com                    | 1570      |
| Facebook.com with a few scrolls | 8300      |
| Yahoo performance site          | 700       |
| Trademe.co.nz                   | 3200      |

1.  Load page
2.  Open JavaScript console
3.  `document.getElementsByTagName('*').length`

---

### DOM performance
[Icon: Yellow highlighting "DOM performance"]
*   The **DOM (Document Object Model)** can become **excessively large** in an application, e.g. Facebook, when you’ve scrolled down a bit
*   A large number of **DOM nodes to traverse**
*   **Performance impact** e.g. you have to modify a large number of nodes (even with a tree structure)

---

### Virtual DOM
[Icon: Yellow highlighting "Virtual DOM"]
*   The **Virtual DOM**: an abstraction of the DOM
    *   Modify the virtual DOM; update the real DOM from the virtual DOM when needed
    *   Libraries / frameworks (e.g. React, Vue.js) will use a virtual DOM in the background
    *   You don’t need to work directly with the DOM
https://bitsofco.de/understanding-the-virtual-dom/

---

### Updating the Virtual DOM
[Icon: Yellow highlighting "Updating the Virtual DOM", "When"]
**When**
The data has changed and it needs to be updated: but how do we know that the data has changed?
1.  **Dirty checking**: poll the data at a regular interval to check the data structure recursively.
2.  **Observable**: observe for state change. If nothing has changed, don’t do anything. If something has changed, we know exactly what to update.

---

### Updating the Virtual DOM
[Icon: Yellow highlighting "Updating the Virtual DOM", "How"]
**How**
How do we make changes efficiently?
*   Need efficient **diff** algorithms.
*   **Batch** DOM read/write operations.
*   Efficient **update** of sub-tree only.

---

[Image: Diagram illustrating Virtual DOM diffing.
Top row (Virtual DOM):
1. Initial tree with one node highlighted (changed).
2. Tree after change, same node highlighted.
3. Tree after another change, two nodes highlighted.
Bottom row (Browser DOM):
1. Initial tree.
2. Tree remains unchanged (no re-render yet).
3. Tree updates only the changed nodes.
Arrows: State Change -> Compute Diff -> Re-render
]

---

### Angular
[Icon: Yellow circle]
[Image: Angular logo (Red 'A' shield). Diagram showing Angular architecture: Injector (Service), Template (< >), Metadata, Component, Property Binding, Event Binding, Directive.]
*   Platform for enterprise-scale web application development
*   Typescript only (no JS) (This is not strictly true, you *can* use JS, but TS is the standard and highly recommended)
*   Relatively complex to learn
*   Two-way binding
*   Dirty-checking to know when DOM should change (Angular moved to a more sophisticated change detection mechanism called Zone.js beyond simple dirty checking, but the core idea of checking for changes remains).

---

### React
[Icon: Yellow circle]
[Image: React logo (atom symbol).]
*   Unlike Angular does not use templating (in the same way as Angular's HTML templates; React uses JSX)
*   Rather defines reusable **components** in **JSX**
    *   Brings the HTML inside the JavaScript
    *   Each component has a lifecycle
*   Most popular framework at present
    *   Thousands of third-party libraries
*   Uses a **virtual DOM**
*   More about React in coming weeks

---

### VueJS
[Icon: Yellow circle]
[Image: Vue.js logo (green stylized 'V').]
*   Designed by Google dev who found Angular too heavy-weight
*   Uses component with lifecycles concept & virtual DOM from React
*   But templating in HTML, instead of JSX
    *   Closer to native HTML than React, whereas JS is the “starting point” in React

---

### Svelte
[Icon: Yellow circle]
[Image: Svelte logo (orange stylized 'S').]
*   Svelte is different again, it parses `.svelte` files and compiles into JavaScript
    *   Uses abstract syntax tree to generate JS and CSS
*   Compiled JS mounts the component, handles events, and patches the DOM directly (no virtual DOM)
    *   All HTML elements are created by JS
*   No framework code, so small and fast code
 https://lihautan.com/the-svelte-compiler-handbook/

---
---

# SENG 365 Week 8
## React: JSX and Components

[Icon: Lightbulb]

---

### This week
[Icon: Thumbtack]
*   JSX
*   Class and Function components

---

## JSX and Components
[Icon: Yellow circle]
[Image: Illustration of stacked Lego bricks.]

---

### Creating a React project
[Icon: Yellow circle]
*   Several toolchains available
    *   **Create React App** easiest way to start with a project from scratch
    *   See also: https://reactjs.org/docs/create-a-new-react-app.html
    *   You can also modify an existing project (w/o toolchain) by adding React JS using script tags and an appropriate JSX preprocessor
```bash
npx create-react-app my-app
cd my-app
npm start
```

---

[Image: A wireframe mockup of a social media feed, divided into three main colored sections: a top navigation bar (teal), a main content feed (pink), and a right sidebar (purple).]
*(This likely illustrates how a complex UI can be broken down into components.)*

---

### Many ways to group files
[Icon: Yellow circle]
[Image: Two different file structures for a React project.
**common/**
  Avatar.js, Avatar.css, APIUtils.js, APIUtils.test.js
**feed/**
  index.js, Feed.js, Feed.css, FeedStory.js, FeedStory.test.js, FeedAPI.js
**profile/**
  index.js, Profile.js, ProfileHeader.js, ProfileHeader.css, ProfileAPI.js

**api/**
  APIUtils.js, APIUtils.test.js, ProfileAPI.js, UserAPI.js
**components/**
  Avatar.js, Avatar.css, Feed.js, Feed.css, FeedStory.js, FeedStory.test.js, Profile.js, ProfileHeader.js, ProfileHeader.css
]
No one right way
Think about **import** statements
Consistency

---

### Anatomy of a React app (index.js - older React versions)
[Icon: Yellow circle]
```javascript
import ReactDOM from "react-dom";
import App from "./App"; // Assuming App.js or App.jsx exists

ReactDOM.render(<App />, document.getElementById("root"));
```

---

### Anatomy of a React app (index.js - React 18+)
[Icon: Yellow circle]
```javascript
import React from 'react'; // Often still imported for completeness or older patterns
import ReactDOM from 'react-dom/client'; // Note the /client
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```
This has changed slightly in React 18

---

### Anatomy of a React app (ReactDOM)
[Icon: Yellow circle]
```javascript
import ReactDOM from "react-dom"; // Or react-dom/client
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root")); // Or root.render(...)
// ReactDOM.render is highlighted
```
ReactDOM is a JavaScript library that renders **JSX** to elements in the document object model (DOM)

---

### Anatomy of a React app (Components)
[Icon: Yellow circle]
```javascript
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
// <App /> is highlighted
```
Application components (e.g. App) are written in JSX
Imported components can have `.js` or `.jsx` extension and it does not need to be indicated in the `import` statement

---

### Anatomy of a React app (Target DOM element)
[Icon: Yellow circle]
```javascript
import ReactDOM from "react-dom";
import App from "./App";

ReactDOM.render(<App />, document.getElementById("root"));
// document.getElementById("root") is highlighted
```
The second parameter (for `ReactDOM.render`) or the argument to `createRoot` is the HTML element that the compiled JSX should be attached to (in this case the element with id `root`)

---

### JSX basics
[Icon: Yellow circle]
*   JSX is a syntax extension of JavaScript
*   Looks a bit like a mix of JS and HTML
*   Compiled to HTML (via JavaScript calls like `React.createElement`) before running in the browser
*   Your project needs a JSX preprocessor (this is already installed by Create React App, typically Babel)
    ```bash
    npm install babel-cli@6 babel-preset-react-app@3 # Example, CRA handles this
    ```

---

### JSX examples (Single element)
[Icon: Yellow circle]
Single element
```javascript
const title = <h1>Welcome all!</h1>;
```

---

### JSX examples (Single element with attributes)
[Icon: Yellow circle]
Single element with attributes (like HTML)
```javascript
const example = <h1 id="example">JSX Attributes</h1>;
```

---

### JSX examples (Multiline and nested)
[Icon: Yellow circle]
Multiline and nested expressions
*   Requires surrounding brackets: `( )`
*   Must be **only one** outermost tag (e.g. `<ul> </ul>` or a Fragment `<>...</>`)
```javascript
const mylist = (
  <ul>
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
  </ul>
);
```

---

### JSX examples (Evaluated JavaScript)
[Icon: Yellow circle]
Can contain evaluated JavaScript
*   Denoted by curly brackets: `{ }`
```javascript
let expr = <h1>{10 * 10}</h1>;
// above will be rendered as <h1>100</h1>
```

---

### JSX conditionals
[Icon: Yellow circle]
Can be tricky and there is more than one approach

1.  JavaScript Boolean short circuit evaluation (`&&`)
    ```javascript
    // All of the list items will display if
    // baby is false and age is above 25
    const tasty = (
      <ul>
        <li>Applesauce</li>
        { !baby && <li>Pizza</li> }
        { age > 15 && <li>Brussels Sprouts</li> }
        { age > 20 && <li>Oysters</li> }
        { age > 25 && <li>Grappa</li> }
      </ul>
    );
    ```

---

### JSX conditionals (Ternary operator)
[Icon: Yellow circle]
Can be tricky and there is more than one approach

2.  Ternary operator `<expr> ? <expr> : <expr>`
    ```javascript
    // Using ternary operator
    const headline = (
      <h1>
        { age >= drinkingAge ? 'Buy Drink' : 'Do Teen Stuff' }
      </h1>
    );
    ```

---

### Arrays and JSX collections
[Icon: Yellow circle]
Use `map` function to generate a collection from an array
```javascript
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li>{number}</li>
);

// Later in JSX:
// <ul>{listItems}</ul>
```
But this generates a warning message that the list items should have a **key**

---

### List item keys in JSX
[Icon: Yellow circle]
*   Keys are necessary because they tell React when a render needs to happen because a list element has changed or is added/removed.
```javascript
const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
  <li key={number.toString()}> {/* Key added */}
    {number}
  </li>
);
```

---

### Key as id field in list object
[Icon: Yellow circle]
```javascript
function Car(props) {
  return <li>I am a { props.brand }</li>;
}

function Garage() {
  const cars = [
    {id: 1, brand: 'Ford'},
    {id: 2, brand: 'BMW'},
    {id: 3, brand: 'Audi'}
  ];
  return (
    <> {/* React Fragment */}
      <h1>Who lives in my garage?</h1>
      <ul>
        {cars.map((car) => <Car key={car.id} brand={car.brand} />)}
      </ul>
    </>
  );
}
```

---

### JSX compilation
[Icon: Yellow circle]
JSX is syntactic sugar for JavaScript that calls `React.createElement`

[Image: Side-by-side code.
Left (JSX):
```javascript
const App = () => {
  const now = new Date();
  const a = 10;
  const b = 20;

  return (
    <div>
      <p>Hello world, it is {now.toString()}</p>
      <p>
        {a} plus {b} is {a + b}
      </p>
    </div>
  );
};
```
Right (Compiled JavaScript):
```javascript
const App = () => {
  const now = new Date();
  const a = 10;
  const b = 20;

  return React.createElement(
    'div',
    null, // props
    React.createElement(
      'p',
      null,
      'Hello world, it is ', now.toString()
    ),
    React.createElement(
      'p',
      null,
      a, ' plus ', b, ' is ', a + b
    )
  );
};
```
A large yellow arrow points from the JSX to the compiled JS.]

---

### `React.createElement`
[Icon: Yellow circle]
Takes three parameters:
`type`, `props`, `children`

It returns a JavaScript object

[Image: Screenshot of browser console showing the output of `React.createElement('div', {}, 'Hello')`. It's an object with properties like `$$typeof: Symbol(react.element)`, `key: null`, `props: {children: "Hello"}`, `ref: null`, `type: "div"`, etc.]

---

### `React.createElement` (Nesting)
[Icon: Yellow circle]
React elements can be nested in `children`

`ReactDOM.render` is passed one of these nested objects

[Image: Screenshot of browser console showing nested `React.createElement` calls resulting in a nested object structure.
`React.createElement('div', {}, React.createElement('p', {}, 'A p inside a div'))`
The outer element has `type: "div"`. Its `props.children` is another React element object with `type: "p"` and `props.children: "A p inside a div"`.
]

---

### Defining your own Components
[Icon: Yellow circle]
**Class** component
```javascript
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

---

### Defining your own Components (Class vs Function)
[Icon: Yellow circle]
**Class** component
```javascript
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```
**Function** component
```javascript
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
[A yellow arrow labeled "Equivalent" points from the class component to the function component.]

---

### Composing Components
[Icon: Yellow circle]
**props** stands for properties and is a **read-only object** that is passed to the component

Components in JSX have to **start with a capital letter** to differentiate them from HTML tags

```javascript
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

function App() {
  return (
    <div>
      <Welcome name="Sara" />
      <Welcome name="Cahal" />
      <Welcome name="Edite" />
    </div>
  );
}
```

---

### What does this render?
[Icon: Yellow circle]
```javascript
const Hello = (props) => {
  return (
    <div>
      <p>
        Hello {props.name}, you are {props.age} years old
      </p>
    </div>
  )
}

const App = () => {
  const name = 'Peter';
  const age = 10;

  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} />
      <Hello name={name} age={age} />
    </div>
  )
}
```

---

### What does this render? (Output)
[Icon: Yellow circle]
```
Greetings
Hello Maya, you are 36 years old
Hello Peter, you are 10 years old
```
*(Rendered HTML would be structured with `<h1>` and `<p>` tags within `<div>`s)*

---

## Component lifecycle and managing state
[Icon: Yellow circle]

---

### Making components stateful
[Icon: Yellow circle]
[Image: Diagram showing "Props vs State".
Props:
  - props are read-only
  - props can not be modified
State:
  - state changes can be asynchronous
  - state can be modified using this.setState (for class components) or a setter function (for function components with hooks)
Arrows point from a central React logo to "Props" and "State".]

---

### Data flow
[Icon: Yellow circle]
[Image: Diagram illustrating data flow in React. "Data Flow - React". "Components can either be passed data (PROPS), or materialize their own state and manage it over time (STATES)".
A tree of "Component" nodes. `props` flow down from parent to child. Each component can have its own internal `state` (represented by a circular arrow within the component box).]

---

### State and Lifecycle in Class Components
[Icon: Yellow circle]
Class components extend `React.Component`.

`this.state` is the component’s state object

It is initialized in the component’s constructor, which takes `props` as a parameter. It should always call `super(props);` at the beginning.

The state object is how we change the view (made by the `render` method) based on events.

```javascript
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
  // ...
}
```

---

### State and Lifecycle in Class Components (Methods)
[Icon: Yellow circle]
Every React component has a lifecycle, accessed through component methods, e.g.:
*   `componentDidMount`
*   `componentDidUpdate`
*   `componentWillUnmount` (Note: `componentWillMount` is legacy and unsafe, `componentWillUnmount` is for cleanup)

`this.state` should not be set directly, instead use `this.setState()`

`this.setState()` is a *request* to change the state, not updated immediately

The object sent to `setState` is *merged* with the existing state in a batch operation

```javascript
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }
  // ... render method
}
```

---

### State and Lifecycle in Class Components (Render)
[Icon: Yellow circle]
The state can be referenced with `this.state` in the `render()` method

You should **not** update the state in `render()`
Why? (This would cause an infinite loop, as `setState` triggers a re-render.)

```javascript
class Clock extends React.Component {
  // ... constructor, lifecycle methods, tick ...

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}
```

---

### State and Lifecycle in Class Components (Events)
[Icon: Yellow circle]
The state can be referenced with `this.state` in the `render()` method

You should **not** update the state in `render()`
Why? (Causes infinite re-renders.)

The state update will trigger a new render of the view.

In this example the state is updated every second using `setInterval`. How about events triggered by user actions? (Event handlers would call `this.setState` to update state based on user interaction.)

---
---

# SENG 365 Week 9
## React: Event Handling, Hooks, Global State

[Icon: Lightbulb]

---

### This week
[Icon: Thumbtack]
*   Event handling
*   Hooks
*   Global storage
*   Routing
*   Debugging React apps

---

## Event handling and hooks
[Icon: Yellow circle]

---

### Event handling
[Icon: Yellow circle]
*   Event handling in a component is similar to DOM events but with some differences
    *   Camel case notation: `onClick`, `onSubmit`, etc.
    *   Pass a function as the event handler
*   The function can be a method in the component class but cannot be called unless `this` is explicitly bound.

---

### Digression: function binding
[Icon: Yellow circle]
```javascript
const module = {
  x: 42,
  getX: function() {
    return this.x;
  }
};

const unboundGetX = module.getX;
console.log(unboundGetX()); // The function gets invoked at the global scope
// expected output: undefined (in non-strict mode, `this` is window/global; in strict mode, `this` is undefined, leading to an error)

const boundGetX = unboundGetX.bind(module);
console.log(boundGetX());
// expected output: 42
```

---

### Accessing a component method for an event (option 1 - bind in constructor)
[Icon: Yellow circle]
Bind `this` in the component constructor.
```javascript
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
```

---

### Accessing a component method for an event (option 2 - class fields syntax)
[Icon: Yellow circle]
Use public class fields syntax
This syntax is experimental but enabled by default by Create React App (Babel preset)
```javascript
class LoggingButton extends React.Component {
  // This syntax ensures `this` is bound within handleClick.
  // Warning: this is *experimental* syntax.
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```

---

### Accessing a component method for an event (option 3 - arrow function in callback)
[Icon: Yellow circle]
Use arrow function in callback
Not as performant because creates new function with each render (can be an issue for components that re-render frequently or pass callbacks to child components that rely on reference equality for optimization).
```javascript
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      <button onClick={() => this.handleClick()}>
        Click me
      </button>
    );
  }
}
```

---

### Function components with state
[Icon: Yellow circle]
*   Function components have been around in React for a long time for simple components
*   Stateless before React 16.8
*   **Hooks** were added in React 16.8
*   Now most of what you could do with class components can be done with function components
*   Syntax much lighter, easier to read code

---

### Hooks in Function Components (`useState`)
[Icon: Yellow circle]
```javascript
import React, { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0); // useState(0) - 0 is the initial state

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```
Import `useState` hook
`count` is assigned the initial value which is zero.
`setCount` is assigned to a function used to modify the state.

Note: must use arrow function notation (e.g., `() => setCount(count + 1)`) if passing the call directly in JSX, otherwise if we execute `setCount(count + 1)` directly in the render statement it will get in an endless render loop.

---

### Hooks in Function Components (Alternative event handler)
[Icon: Yellow circle]
If we don’t want to use an arrow function in the render, declare a `const` set equal to the arrow function in the component body.
```javascript
const App = () => {
  const [ counter, setCounter ] = useState(0);

  const increaseByOne = () => setCounter(counter + 1);
  const setToZero = () => setCounter(0);

  return (
    <div>
      <div>{counter}</div>
      <button onClick={increaseByOne}>
        plus
      </button>
      <button onClick={setToZero}>
        zero
      </button>
    </div>
  )
}
```
(Note in this example App component function is also using the `const` function expression form, instead of `function` keyword)

---

### Accessing previous state explicitly in setter function
[Icon: Yellow circle]
```javascript
function Counter({initialCount}) {
  const [count, setCount] = useState(initialCount);
  return (
    <div>
      Count: {count}
      <button onClick={() => setCount(initialCount)}>Reset</button>
      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>
      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>
    </div>
  );
}
```

---

### `useState` can be used to set multiple state variables
[Icon: Yellow circle]
```javascript
function App() {
  const [sport, setSport] = useState('basketball');
  const [points, setPoints] = useState(31);
  const [hobbies, setHobbies] = useState([]); // Example: array state
}
```
Compare with `this.state` in class components.
Updating a state variable *replaces* the variable, in contrast to merging as in `this.setState()` (for objects). For multiple independent state values, use multiple `useState` calls.

---

### `useReducer`
[Icon: Yellow circle]
Pass in a reducer of type `(state, action) => newState`
Returns state and a `dispatch` method that can be used to trigger different actions.
Useful to maintain state of complex objects.
In React source `useState` is just a special case of the `useReducer` hook.

```javascript
const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({type: 'decrement'})}>-</button>
      <button onClick={() => dispatch({type: 'increment'})}>+</button>
    </>
  );
}
```

---

### `useEffect` hook
[Icon: Yellow circle]
Creates **side effects** in components
Tells component that it needs to do something *after* render
Guarantees DOM has been updated
Allows similar functionality to lifecycle methods in a class component

```javascript
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // Similar to componentDidMount and componentDidUpdate:
  useEffect(() => {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;
  }); // Runs after every render if no dependency array

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

---

### `useEffect` optimization (dependency array)
[Icon: Yellow circle]
Second parameter is a **dependency array**: specifies what state variables must change to execute side effect
```javascript
useEffect(() => {
  document.title = `You clicked ${count} times`;
}, [count]); // Only re-run the effect if count changes
```

---

### Rules for Hooks
[Icon: Yellow circle]
*   Only call at **Top Level** (not inside loops, conditions, etc.)
*   Only call from **React functions or custom hooks** (next slide)

*   Many more pre-defined hooks:
    https://reactjs.org/docs/hooks-reference.html

---

### Custom hooks
[Icon: Yellow circle]
JS function name starts with `use`
Must follow Rules of Hooks (from previous slide)
```javascript
import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() => {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    // Specify how to clean up after this effect:
    return () => {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  }); // Runs after every render; consider adding friendID to dependency array if ChatAPI changes behavior based on it.

  return isOnline;
}
```

---

### Using custom hooks
[Icon: Yellow circle]
Two different components using the same hook **do not** share state
```javascript
function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}

function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    <li style={{ color: isOnline ? 'green' : 'black' }}>
      {props.friend.name}
    </li>
  );
}
```

---

### How do Hooks work under the hood?
[Icon: Yellow circle]
*   In React, **reconciliation** and **render** are two different phases
*   **Reconciliation** is the tree diffing algorithm in React used to say what changed (virtual DOM)
*   **Render** uses that info to update the app view
*   Reconciliation is implemented using **fibers**
    *   a JavaScript object that contains information about a component, its input, and its output
    *   a kind of virtual stack frame
More info: https://blog.logrocket.com/deep-dive-react-fiber/

---

### Fiber tree traversal
[Icon: Yellow circle]
[Image: Two diagrams showing tree structures.
Left: "Current" tree (currently rendered on UI) and "WorkInProgress" tree (tree created during computation after an update, used for next rendering). An arrow shows "At the end of computation", the WorkInProgress tree potentially becomes the Current tree.
Right: A flowchart illustrating React's render/reconciliation process starting from "Root/Any React Element", processing nodes, creating fiber nodes, and checking for child/sibling availability to continue processing.
]

---

### Hooks are called in render
[Icon: Yellow circle]
*   Hooks use a “**dispatcher**” object
*   When you call `useState`, `useEffect`, … it passes the call to the dispatcher object
*   The **renderer** is what executes the component function (based on the result of reconciliation)
*   The renderer knows the context of the component and works through linked list of hooks

---

### More resources on React under the hood
[Icon: Yellow circle]
*   How does React actually work? (video)
    *   https://www.youtube.com/watch?v=7YhdqIR2Yzo
*   What is React Fiber?
    *   https://www.youtube.com/watch?v=0ympFIwQFJw
    *   https://blog.logrocket.com/deep-dive-react-fiber/
*   How do Hooks work?
    *   https://www.youtube.com/watch?v=1VVfMVQabx0

---

### State and props revisited
[Icon: Yellow circle]
*   In React, **state** is internal to components
*   **props** are used to pass information from parents to children
*   Children can pass information to parents, by passing a parent setter function as a prop in a child element
*   But what about complex apps with shared state across components not in parent-child relationship?

---

### Global state
[Icon: Yellow circle]
[Image: Two tree diagrams.
Left: A component (highlighted blue) updates its state, and this change might need to propagate up and then down to other components through props ("prop drilling").
Right: A central "Store" (dotted oval) is introduced. The blue component interacts with the Store. Other components can also read from or subscribe to the Store, simplifying state sharing across distant components.
"Component initiating change" is the blue highlighted node.
]

---

### Global state management
[Icon: Yellow circle]
*   Several libraries exist to manage global state
*   Define actions to update the state, can be async functions (e.g., including a data fetch from server)
*   **Redux** is the most popular
    *   Verbose, lots of boilerplate
    *   Best to use **Redux-Toolkit** for React >16.8 with function components and hooks
*   We use **Zustand** in the labs
*   **`useContext`** hook is useful for sharing global variables such as CSS themes, but can be inefficient for large apps (triggering updates of all components that consume the context if the context value changes).

---

### Redux model (Actions)
[Icon: Yellow circle]
[Image: Diagram of Redux flow: Actions -> Dispatcher -> Store (Reducer -> State) -> View (React Components) -> Actions.]
**Actions** = JavaScript objects that *describe* the action to be taken
```javascript
// action to add a todo item
{ type: 'ADD_TODO', text: 'This is a new todo' }
// action that pass a login payload
{ type: 'LOGIN', payload: { username: 'foo', password: 'bar' }}
```

---

### Redux model (Reducers)
[Icon: Yellow circle]
[Image: Redux flow diagram, highlighting Reducer within the Store.]
**Reducer** = *pure functions* that take an action and update the state
```javascript
// takes in the current state and action
// updates the value based on the action's type
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { value: state.value + 1 }
    case 'DECREASE':
      return { value: state.value - 1 }
    default:
      return state
  }
}
```

---

### Redux model (Redux-Toolkit Slices)
[Icon: Yellow circle]
[Image: Redux flow diagram.]
**Redux-toolkit**: `slices` combines all this to create less boilerplate code
```javascript
import { createSlice } from '@reduxjs/toolkit'

export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0
  },
  reducers: {
    increase: state => {
      state.value += 1 // Redux Toolkit uses Immer internally, allowing direct mutation logic in reducers
    },
    decrease: state => {
      state.value -= 1
    }
  }
})
// each case under reducers becomes an action
export const { increase, decrease } = counterSlice.actions
export default counterSlice.reducer
```

---

### Redux model (Redux-Toolkit Hooks)
[Icon: Yellow circle]
[Image: Redux flow diagram, highlighting interaction with React Components.]
**Redux-toolkit**: `useSelector` and `useDispatch` hooks are used in the component
```javascript
export function Counter() {
  const count = useSelector(state => state.counter.value) // in our slice, we provided the name property as 'counter'
  // and the initial State with a 'value' property
  // thus to read our data, we need useSelector to return the state.counter.value
  const dispatch = useDispatch()
  // gets the dispatch function to dispatch our actions

  return (
    <div>
      <button onClick={() => dispatch(increase())}>
        Increase
      </button>
      <p>{count}</p>
      <button onClick={() => dispatch(decrease())}>
        Decrease
      </button>
    </div>
  )
}
```

---

### Zustand
[Icon: Yellow circle]
[Image: Screenshot of a live code example using Zustand. A simple counter with a "one up" button.]
```javascript
import create from 'zustand'

const useStore = create(set => ({
  count: 1,
  inc: () => set(state => ({ count: state.count + 1 })),
}))

function Controls() {
  const inc = useStore(state => state.inc)
  return <button onClick={inc}>one up</button>
}

function Counter() {
  const count = useStore(state => state.count)
  return <h1>{count}</h1>
}
```

---

### `useContext` (Step 1: Create Context)
[Icon: Yellow circle]
1.  Create a context object
    ```javascript
    const UserContext = createContext();
    ```

---

### `useContext` (Step 2: Wrap with Provider)
[Icon: Yellow circle]
1.  Create a context object
2.  Wrap components in context Provider (`user` is a state variable)
    ```javascript
    // const UserContext = createContext(); // from previous step
    <UserContext.Provider value={user}>
      <h1>{`Hello ${user}!`}</h1>
      <Component2 user={user} />
    </UserContext.Provider>
    ```

---

### `useContext` (Step 3: Consume Context)
[Icon: Yellow circle]
1.  Create a context object
2.  Wrap components in context Provider, and pass state variable (e.g. `user`) as `value`
3.  In child component access the variable with `useContext`
    ```javascript
    // In Component2.js
    // const user = useContext(UserContext); // This line would be inside the Component2 function body

    return (
      <>
        <h1>Component 5</h1>
        <h2>{`Hello ${user} again!`}</h2>
      </>
    );
    ```

---

## Routing
[Icon: Yellow circle]

---

### Routing basics
[Icon: Yellow circle]
*   In a traditional non-SPA website, when you navigate to a new route (e.g. by clicking a link) it loads a new page from the server
*   In SPA:
    *   The page is not re-loaded
    *   The link is intercepted and any new content needed from the server is made by client-side code
    *   Do not need to re-render entire page, including framework JS (e.g. React), potentially saving data transfer/time.
    *   Bonus: can update the page dynamically, e.g. using CSS transitions

---

### React Router basic concepts
[Icon: Yellow circle]
**URL** - URL is address bar
**Location** - object based on `window.location`
**History** - object that subscribes to the browser’s history stack
The history stack is changed via `POP`, `PUSH`, `REPLACE` operations

**Client-side routing** - programmatically changing the history stack without making a server request
**Route match** - when the URL matches a pattern a specific route is rendered

---

### Location object
[Icon: Yellow circle]
`pathname`, `search` and `hash` come from the url
`state` is the current top of the history stack (can be set by PUSH/REPLACE)
`key` is a unique key (useful for client-side caching etc.)
```json
{
  pathname: "/bbq/pig-pickins",
  search: "?campaign=instagram",
  hash: "#menu",
  state: null, // or custom state object
  key: "aefz24ie" // example key
}
```

---

### Route config and matching (React Router v5 example style)
[Icon: Yellow circle]
[Image: Code snippet showing React Router route configuration (likely v5 or earlier style with `<Route>` components nested or as a flat list within `<Switch>` or `<Routes>`).
```xml
<Routes>
  <Route path="/" element={<App />}>
    <Route index element={<Home />} />
    <Route path="teams" element={<Teams />}>
      <Route path=":teamId" element={<Team />} />
      <Route path="new" element={<NewTeamForm />} />
      <Route index element={<LeagueStandings />} />
    </Route>
  </Route>
  <Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
  </Route>
  <Route path="contact-us" element={<Contact />} />
</Routes>
```
*(Note: React Router v6 introduced significant changes to its API, using `element` prop and nested routes more explicitly. The slide's example might reflect an older version or a conceptual representation.)*

*   The route config is a tree of route elements.
*   Matches can be **exact** or **dynamic** (e.g. `:teamId`)
*   `path` prop defines the match
*   `element` prop (in v6) or component prop (in v5) defines the component to be rendered

---

### Higher-order Components (Props Proxy)
[Icon: Yellow circle]
Wrapping components with **props proxy**
```javascript
class Welcome extends React.Component {
  render() {
    return (
      <div>Welcome {this.props.user}</div>
    );
  }
}

const withUser = (WrappedComponent) => {
  return class extends React.Component {
    render() {
      if (this.props.user) { // Assuming user prop is passed to this HOC
        return <WrappedComponent {...this.props} />
      }
      return <div>Welcome Guest!</div>
    }
  }
}

export default withUser(Welcome);
```

---

### Higher-order Components (Inheritance Inversion)
[Icon: Yellow circle]
Wrapping components with **inheritance inversion** (less common, more complex)
```javascript
// Base component
class Welcome extends React.Component {
  render() {
    // ...
    return <div>Welcome {this.props.user}</div>;
  }
}

// HOC using props proxy (shown before) is generally preferred.
// Inheritance inversion HOC example:
const withLoader = (WrappedComponent) => {
  return class extends WrappedComponent { // Extends the wrapped component
    render() {
      const { isLoaded } = this.props; // Assuming isLoaded is a prop
      if (!isLoaded) {
        return <div>Loading...</div>;
      }
      return super.render(); // Calls the render method of WrappedComponent
    }
  }
}
// This pattern allows the HOC to access the WrappedComponent's state, methods, and lifecycle,
// but it's more tightly coupled and can lead to complexities.
// export default withLoader(withUser(Welcome)); // Example of composing HOCs
```
*(The slide shows two HOC examples, the second one related to `withLoader` and `isLoaded` which is more indicative of state manipulation often seen with inheritance inversion, though the specific code for `withLoader` using inheritance inversion directly wasn't fully shown on the combined slide image, so a plausible example is provided above.)*

---

## Debugging React Apps
[Icon: Yellow circle]

---

### Tips on debugging
[Icon: Yellow circle]
*   When you run in dev hot reloading is enabled
*   Keep browser open with web page (e.g. `localhost:3000`) and console visible while developing
*   Sometimes when it crashes (shows error message in browser) you need to reload the page

---

### `console.log`
[Icon: Yellow circle]
*   `console.log` is still a great way to view the state of variables when components load
*   Remember to remove these before production, though!
```javascript
console.log('props value is', props);
```
Use comma, not `+` when concatenating complex objects to strings (to get better object inspection in console).

---

### `debugger` in Chrome developer tools
[Icon: Yellow circle]
[Image: Screenshot of Chrome DevTools. The "Sources" tab is open, showing JavaScript code. A line `debugger;` is highlighted, and the script execution is paused at this line ("Paused in debugger"). The call stack and scope variables are visible.]
Can also set **breakpoints** manually.
Once it has stopped you can use the console to view the value of various variables.

---

### React developer tools
[Icon: Yellow circle]
https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi

[Image: Screenshot of Chrome DevTools with the React Developer Tools extension. The "Components" tab is highlighted, showing a tree of React components and their props and state. A "Profiler" tab is also visible.]
Adds a **Components** tab to the developer console
Can view component **state** and **props**, and **hooks** in order of definition

---

### React developer tools (Profiler)
[Icon: Yellow circle]
[Image: Same screenshot as above, but conceptually highlighting the "Profiler" tab.]
Adds a **Components** and **Profiler** tabs to the developer console
Can view component **state** and **props**, and **hooks** in order of definition
**Profiler** allows you to test performance of components

---
---
```
```markdown
# SENG 365 Week 10
## Communication between SPA and Server

[Icon: Lightbulb]

---

### This week
[Icon: Thumbtack]
*   AJAX
*   XHR
*   CORS
*   Web sockets

---

[Image: A bottle of Ajax cleaning product with a red "X" over it. Next to it, the official AJAX shield logo (circular arrow). Text: "AJAX".]
**AJAX: Asynchronous JavaScript and XML**
**XHR: XMLHttpRequest**

How can you retrieve data from the server, or send data to the server, whilst the user is interacting with your webpage on the browser?
https://xhr.spec.whatwg.org/

---

[Image: Architectural diagram of Chromium's multi-process architecture, showing browser process, renderer processes, and GPU process communicating via IPC. This illustrates the complexity of browser operations and how network requests fit in.]
https://www.chromium.org/developers/design-documents/multi-process-architecture
*(This slide likely serves as context for how browsers handle requests in the background.)*

---

### Getting data from server into SPA
[Icon: Yellow circle]
*   SPAs separate data from content and presentation.
*   How do you get data from the server without refreshing the page?
    *   How do you get data from the server without an HTTP GET of HTML?
    *   How do you get data from the server without requiring a user to reload the page?
*   Problem/requirement:
    *   Need some way of performing HTTP requests concurrently to, and independently of, the user interacting with the application on the browser
    *   Balance security and usability

---

### Summary of XHR / AJAX
[Icon: Yellow circle]
*   Execute HTTP methods programmatically, and in the ‘background’
    *   But remember that JavaScript is single threaded (asynchronous operations don't block the main thread thanks to the event loop).
*   Use JavaScript to issue HTTP requests e.g. HTTP GET, HTTP POST etc.
*   Use XMLHttpRequest (XHR) JavaScript API
    *   Raw JavaScript XHR; or
    *   Abstraction of XHR e.g. jQuery’s `$.ajax()` method, `axios`, `fetch`, etc.
*   Setup XHR request, in which you specify things like:
    *   HTTP request
        *   Method e.g. GET, etc. including `?` query parameters
        *   Body e.g. what’s in the HTTP body you’re sending (if anything)
    *   Expected HTTP responses: what data you want back from the server e.g. JSON, XML etc
    *   Callbacks for handling the range of HTTP response/s
        *   e.g. successful | unsuccessful response
*   Execute the request

---

### Example of raw XHR
[Icon: Yellow circle]
```html
<div>
  <p><strong>Example data returned.</strong></p>
</div>
<div>
  <div id="pid">Nothing.</div>
  <button type="button" onclick="go()">Click me.</button>
</div>
<script>
  function go(){
    var xhttp = new XMLHttpRequest();
    xhttp.onreadystatechange = function() {
      if (this.readyState == 4 && this.status == 200) {
        document.getElementById("pid").innerHTML =
        this.responseText;
      }
    };
    xhttp.open("GET", "https://www.canterbury.ac.nz", true); // true for asynchronous
    xhttp.send();
  }
</script>
```
1.  Copy and paste into HTML file.
2.  Add the DOCTYPE, `<html>`, `<head>`, and `<body>` elements
3.  Open in a browser window.
4.  Enjoy responsibly…

**NOTE**
1.  The code does not handle unsuccessful responses... (or network errors)

---

### Events (handlers) for XHR
[Icon: Yellow circle]
`onloadstart`
`onprogress`
`onabort`
`onerror`
`onload`
`ontimeout`
`onloadend`
`onreadystatechange`

---

### XMLHttpRequest ++
[Icon: Yellow circle]
*   The term **XMLHttpRequest** (XHR) is (now) misleading:
    *   Can retrieve data other than XML e.g. JSON
    *   Works with other protocols, not just HTTP (though HTTP is primary)
    *   Doesn’t have to be asynchronous
        *   … but should be asynchronous and should **NOT** synchronous (as synchronous XHR blocks the main thread and is deprecated).
*   Browser differences (in older browsers)
    *   Internet Explorer variants do things differently…
        *   `XDomainRequest` in Internet Explorer 8 and 9
    *   Best to use an abstraction rather than raw XHR e.g. a library such as **axios** or **fetch API**

---

### `fetch` API
[Icon: Yellow circle]
*   Native Javascript API introduced in 2017
*   Implemented in most modern browsers now
    *   https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#browser_compatibility
```javascript
fetch('examples/example.json') // or any URL
  .then(function(response) {
    // Do stuff with the response (e.g., response.json(), response.text())
    return response.json(); // Example: parse as JSON
  })
  .then(function(data) {
    console.log('Data:', data);
  })
  .catch(function(error) {
    console.log('Looks like there was a problem: \n', error);
  });
```

---

### `fetch` API (with async/await)
[Icon: Yellow circle]
*   Native Javascript API introduced in 2017
*   Implemented in most modern browsers now
    *   https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#browser_compatibility

Works with async functions
```javascript
async function doAjax() {
  try {
    const res = await fetch('send-ajax-data.php'); // Example endpoint
    const data = await res.text(); // Or res.json()
    console.log(data);
  } catch (error) {
    console.log('Error:' + error);
  }
}

doAjax();
```

---

[Icon: Large quotation mark in a yellow circle]
**How does an application respond to multiple overlapping requests?**

---

[Image: Diagram of Node.js Event Loop and request handling.
1. Application makes a Request I/O (e.g., file read, network call).
2. Request I/O is passed to Demultiplexer which holds Resources, Operations, and Handlers.
3. Completed operations are pushed as Events (with their Handlers) to the Event Queue.
4. The Event Loop continuously checks the Event Queue. If an event is present, it's popped and its Handler is executed (Run Handler()) by the Application (Main thread).
This illustrates non-blocking I/O.
]
Node.js Design Patterns, 2nd edition, Casciaro and Mammino, 2016, Packt Publishing

---

[Image: Line graph titled "A little holiday present: 10,000 reqs/sec with Nginx!". It compares Nginx (yellow line, higher performance) and Apache (blue line, lower performance) in terms of requests per second versus concurrent connections. The article snippet discusses benchmarking Nginx against Apache for serving a small static file.]
*(This slide likely illustrates the performance benefits of event-driven, non-blocking architectures like Node.js and Nginx, which are relevant to handling many concurrent AJAX requests efficiently.)*

---

### Concurrency (vs Parallelism)
[Icon: Yellow circle]
"In programming, **concurrency** is the composition of independently executing processes, while **parallelism** is the simultaneous execution of (possibly related) computations. Concurrency is about **dealing** with lots of things at once. Parallelism is about **doing** lots of things at once."
- Concurrency is not Parallelism, the GoLang blog

---

## CORS
[Icon: Yellow circle]
**Cross Origin Resource Sharing**
```javascript
app.use(function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*"); // Allows all origins
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE"); // Specify allowed methods
  next();
});
```

---

### Why CORS?
[Icon: Yellow circle]
*   Cross-site request forgery: send fake client requests to another application.
*   E.g. external website uses stolen credentials to an application pretending to be user
*   Solution: **same-origin policy** (browser security feature that restricts how a document or script loaded from one origin can interact with a resource from another origin.)

---

### Everyday & legitimate cross-origin resource request
[Image: Diagram.
User's browser (Resource A, Domain A: www.first.com:80) makes an HTTP request for HTML.
The HTML contains an `<img>` tag pointing to Resource B on Domain B: www.second.com:443.
The browser makes a separate HTTPS request for Resource B. This is a legitimate cross-origin request for an image.
]
URL -> Browser (Resource A) -(HTTP request)-> Server (Domain A, Resource A: `<HTML>`) -(HTTP response)-> Browser
Browser (Resource A) -(HTTPS request for `<img>` content)-> Server (Domain B, Resource B: `<img>`) -(HTTPS response)-> Browser

---

### Cross-origin requests with `<script>` (XHR)
[Image: Diagram similar to the previous one, but Resource A now contains `<script>` that attempts an XHR (HTTPS request) to Resource B. A large red question mark is over this XHR request, indicating potential blocking by same-origin policy.]
URL -> Browser (Resource A: `<script>`) -(HTTP request)-> Server (Domain A, Resource A: `<script>` as content) -(HTTP response)-> Browser
Browser (Resource A `<script>`) --[**?** XHR HTTPS request]--> Server (Domain B, Resource B: `<img>` or other data) -(HTTPS response)-> Browser

For security reasons, browsers restrict `<script>`s in the way they make cross-origin resource requests.
By default, an XHR request can be made only to the originating origin (the same origin).

---

### Sending and retrieving resources
*   Many web pages (web applications) load resources from **separate** domains
    *   CSS stylesheets, images, frames, video
*   Certain "cross-domain" requests, notably **AJAX / XHR** requests, are **forbidden** by the same-origin security policy.
    *   AJAX requests are JavaScript and `<script>`s can’t by default make cross-origin requests

---

### CORS to the rescue
[Icon: Yellow highlighting "CORS"]
*   CORS defines a way in which a **browser** and a **server** can **work together** to determine whether or not it is safe to allow a **client-side app** to make a cross-origin request
*   The CORS standard describes HTTP headers which provide browsers and servers a way to request remote URLs only when they have permission.
    *   The app can’t access (some of) these headers directly.
*   Some validation and authorization is performed by the server
    *   The server specifies the acceptable origins of the HTTP requests
**It is generally the browser's responsibility to support these headers and honour the restrictions they impose.**

Note: **not** the application’s responsibility; the browser’s responsibility e.g. to prevent the application doing something malicious or unintended.

---

### What defines ‘origin’?
[Icon: Yellow highlighting "origin"]
Origin is defined in terms of
*   Protocol
*   Domain
*   Port

Identical {protocol, domain, port} = same origin
Different {protocol, domain, port} = cross-origin

So:
`http://example.com:80`
is different from:
`https://example.com:80` (different protocol)
`http://exemple.com:80` (different domain)
`http://example.com:463` (different port)

---

### HTTP forbidden headers
[Icon: Yellow circle]
*   Some headers are managed by the browser and/or the server, and…
*   ... these headers can’t be manipulated by the client-side application.
*   “A forbidden header name is an HTTP header name that cannot be modified programmatically; specifically, an HTTP request header name.”

**Examples of forbidden headers**
The browser should prevent your application from modifying these:
`Access-Control-*` (e.g., `Access-Control-Allow-Origin`, `Access-Control-Allow-Headers`)
`Origin`
There are many others
https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name

---

### Some of the headers returned by the server (CORS related)
`Access-Control-Allow-Origin: *`
Allow the request from any origin

`Access-Control-Allow-Origin: https://foo.bar`
Allow the request only from resources originating from `HTTPS://foo.bar` (remember what defines an origin)

`Access-Control-Allow-Methods: POST, GET, OPTIONS`
Allow only these HTTP methods

`Access-Control-Max-Age: 86400`
Access (for preflight requests) is allowed for up to 86400 milliseconds (86.4s)

`Access-Control-Allow-Credentials: true`
Required if you want to send cookies etc (and can’t use `Access-Control-Allow-Origin: *` with credentials)

---

### Adding CORS headers to server response in node.js
[Image: Code snippet for Express middleware]
```javascript
app.use(function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");
  next();
});
```

---

### Example 1: accept request from foo.com only (CORS)
[Image: Diagram similar to the XHR one.
Browser on foo.com (Resource A, `<script> XHR </script>`) sends an HTTPS request to bar.com (Resource B).
The request includes `Origin: https://foo.com` (Added by browser, not app).
Server on bar.com responds with `Access-Control-Allow-Origin: https://foo.com`.
The browser allows the XHR.
]

---

### Example 2: accept request from anywhere (*) (CORS)
[Image: Diagram.
Browser on foo.com sends HTTPS request with `Origin: https://foo.com`.
Server on bar.com responds with `Access-Control-Allow-Origin: *`.
The browser allows the XHR.
]

---

### Example 3: reject request (CORS)
[Image: Diagram.
Browser on foo.com sends HTTPS request with `Origin: https://foo.com`.
Server on bar.com responds with `Access-Control-Allow-Origin: https://boo.com`.
The browser blocks the XHR because foo.com is not boo.com.
]
**Note:**
Server will respond…
... but browser won’t honour the XHR (if the origin doesn't match or isn't wildcarded and the server doesn't allow the specific origin).

---

### Example 4: fooling the server? (CORS)
[Image: Diagram. The `Origin` header in the HTTPS request is shown as `Origin: https://boo.com`, but the actual request is originating from foo.com. The Resource A box on foo.com is highlighted with a red dotted line, implying this is where the manipulation would need to happen if possible.]
Server on bar.com responds with `Access-Control-Allow-Origin: https://boo.com`.
*(This scenario implies trying to spoof the `Origin` header. However, the `Origin` header is a "forbidden header name" and is set by the browser; client-side JavaScript cannot change it directly for an XHR request. An attacker would need to control the browser or use other means to send a spoofed Origin header, which is outside typical XHR behavior from a script.)*

---

### Worked example using Flickr (CORS)
*   Follow-up reading
*   Code example from *CORS in Action* (Manning Publications)

Chapter 1. The Core of CORS - CORS in Action: Creating and consuming cross-origin APIs

---

## WebSockets
[Image: Two elephants, one inside an enclosure and one outside, touching trunks through an opening in a wooden gate.]

---

### WebSockets vs HTTP AJAX
**HTTP, AJAX**
*   Uni-directional communication: client makes request, server makes response
*   Stateless
*   Relatively less efficient (for real-time, high-frequency updates due to overhead of new connections/requests)
*   Good for retrieving resources
*   Must implement polling to get updates from the server

**Web socket**
*   Persistent 2-way communication
*   Maintains state (connection state)
*   Fast, lightweight and can maintain much higher load of connections
*   Good for real-time communication: chats, games, etc.
*   Server can push data to client

---

### Polling vs pushing
[Image: Two diagrams.
Left (Polling): Client sends GET polling request to Web Server. Server responds. Client waits, sends another GET polling request. This repeats.
Right (Pushing/WebSockets): Client sends GET ws (WebSocket handshake) request to Web Server. Connection established. Server can push data to Client at any time. Client can also send data to Server.
]

---

### How are web socket connections made?
**Handshake mechanism**
1.  Client send initial HTTP GET request to the server.
2.  Server responds with information on how to connect to socket server (including an upgrade header).
3.  Client sends HTTP GET with header “Connection: Upgrade” and connection is upgraded to a socket connection.

---

### Handshake messages
**Request**
```http
GET /chat HTTP/1.1
Host: server.example.com
Connection: upgrade
Upgrade: websocket
Origin: <http://example.com>
Sec-WebSocket-Key: NnR1ZW4gYn10ZXMgbG90LCBEXMgaG9uZXM==
Sec-WebSocket-Protocol: html-chat, text-chat
Sec-WebSocket-Version: 13
```

**Response**
```http
HTTP/1.1 101 Switching Protocols
Connection: upgrade
Upgrade: websocket
Sec-WebSocket-Accept: 5TJpHv9RoAl7w8ytsXcXWT0ZQ9o==
Sec-WebSocket-Protocol: new-chat
```

---

### Open connection sends data frames between server and client
[Image: Diagram of a WebSocket data frame structure showing bits for FIN, RSV1,2,3, opcode, Mask, Payload Length, Masking key, and Payload data.]
*   **FIN** - last frame of message boolean bit
*   **RSV** - extension bits
*   **opcode** - how message is interpreted (data frame or control frame)
*   **mask** - data encrypted boolean bit (client-to-server frames are masked)
*   **masking key** - key used to encrypt data

---

### Web socket API
[Icon: Yellow highlighting "Web socket API"]
*   Web sockets are now supported in most browsers
    *   https://caniuse.com/websockets
*   Implemented in npm packages, e.g. `ws`, `socket-io`, `websocket`, and `express-ws` (express integration with ws)
    *   Some libraries implement fallback (emulates socket connection in http when not supported in browser)

---

### Sample server (Node.js with `ws` package)
**Simple server**
```javascript
const WebSocket = require('ws');

const wss = new WebSocket.Server({ port: 8080 });

wss.on('connection', function connection(ws) {
  ws.on('message', function incoming(message) {
    console.log('received: %s', message);
  });

  ws.send('something');
});
```

---

### Sample client connection (Browser JavaScript)
**Sending and receiving text data**
```javascript
// Assuming this code runs in a browser environment
const ws = new WebSocket('ws://www.host.com/path'); // Or wss:// for secure

ws.onopen = function open() {
  ws.send('something');
};

ws.onmessage = function incoming(data) {
  console.log(data.data); // Message data is in event.data
};
```
*(Note: The slide example `const WebSocket = require('ws');` is for Node.js. For client-side, you use the browser's built-in `WebSocket` API.)*

---
---

# SENG 365 Week 11
## Web Storage and Progressive Web Apps

[Icon: Lightbulb]

---

### Assignment 2
**Submission requirements**
*   Zipped project
*   Use username as zip filename e.g., `<usercode>.zip`
*   Without `node_modules` to reduce size
*   No server code

**During the test**
*   Preparation
    *   Download .zip of apps
    *   Download latest version of server, install it and run it
*   For *each* application
    *   Reset the database
        *   First `/reset` and `/resample` database using Postman
    *   Install and run the client-side app
        *   `npm install` and run
        *   Open Chrome: `localhost:<port>`
*   Run tests

---

[Image: Screenshot of a fragment of a test script from 2017. It's a table with columns for "1. Can the application be run?" (YES/NO), and "2. Project views" with "Precondition", "Steps", "Expected", "Pass/Fail", and "Comments".]
**Fragment from 2017’s test script**

---

[Image: Two screenshots of a Google Forms page used for application testing. The form has sections for "Project Views" with steps like "Page or scroll to see all the sample projects" and "Action: find a search box, and search for 'farm'". Testers would mark Pass/Fail/Can't answer.]
*(This shows an example of how manual testing might be structured for an assignment.)*

---

### This week
[Icon: Thumbtack]
*   Web storage
*   IndexedDB
*   CacheStorage
*   Progressive Web Apps
*   Service Workers
*   Web Assembly

---

## Web Storage
[Icon: Yellow circle]
**Session Storage, Local Storage, IndexedDB**

---

### HTML5 Web Storage
[Icon: Yellow highlighting "HTML5 Web Storage"]
*   Cookies have limitations
    *   Size limited to approx. 4KB
    *   Send to the server with each request
*   HTML5 web storage
    *   Allows up to approx. 5MB (depends on browser implementation)
    *   Two types:
        *   **Local storage**
        *   **Session storage**
*   Not more secure than cookies, however (susceptible to XSS)

---

### Local Storage
[Icon: Yellow circle]
*   Stores **permanent** data for your site (i.e., no expiration date unless explicitly cleared)
*   Stores data in **key, value pairs**
*   Keys and values are **Strings**
*   **Setter** and **getter** functions:
    `localStorage.setItem(key, value)`
    `localStorage.getItem(key)`

---

### Local Storage example
[Icon: Yellow circle]
```html
<script>
  // Check if the localStorage object exists
  if(typeof(Storage) !== "undefined") { // More robust check: if(localStorage)
    // Store data
    localStorage.setItem("first_name", "Peter");

    // Retrieve data
    alert("Hi, " + localStorage.getItem("first_name"));
  } else {
    alert("Sorry, your browser do not support local storage.");
  }
</script>
```

---

### Local Storage + Zustand
[Icon: Yellow circle]
[Image: Code snippet showing how to integrate Zustand with Local Storage for persistence.]
```javascript
// const useStore = create((set) => ({  // Original line from slide, assuming create is from zustand
const useStore = create(persist( // Using zustand/middleware for persistence
  (set, get) => ({
    collection: [], // Initial state
    setCollection: (newCollection) => set({ collection: newCollection }),
    // Example: initialize from localStorage
    // initialize: () => {
    //   const storedCollection = getLocalStorage("collection");
    //   if (storedCollection) {
    //     set({ collection: storedCollection });
    //   }
    // }
  }),
  {
    name: 'my-zustand-storage', // unique name
    getStorage: () => localStorage, // (optional) by default, 'localStorage' is used
  }
));

// Helper functions shown on slide
const getLocalStorage = (key) => JSON.parse(window.localStorage.getItem(key));
const setLocalStorage = (key, value) => window.localStorage.setItem(key, JSON.stringify(value));
```
*Read `collection` from local storage when the Zustand store is created, or default to `[]`* (This logic would typically be part of the Zustand store setup or a hydration step).
*When `collection` is set in Zustand, also update local storage* (Zustand's `persist` middleware handles this automatically).
*Wrappers for Local Storage getters and setters*

*(The slide showed a manual integration. Modern Zustand uses middleware like `persist` for easier localStorage integration, as shown in the corrected example.)*

---

### Session Storage
[Icon: Yellow circle]
*   Stores **temporary** data for your site
*   **Deleted** when the session ends (browser or tab is closed by user)
*   Same **getters and setters** as Local storage (e.g., `sessionStorage.setItem()`, `sessionStorage.getItem()`)
```html
<script>
  // Check if the sessionStorage object exists
  if(sessionStorage) {
    // Store data
    sessionStorage.setItem("last_name", "Parker");

    // Retrieve data
    alert("Hi, " + sessionStorage.getItem("first_name") + " " + sessionStorage.getItem("last_name"));
    // Assuming first_name was set in localStorage or also in sessionStorage
  } else {
    alert("Sorry, your browser do not support session storage.");
  }
</script>
```

---

### IndexedDB
[Icon: Yellow circle]
*   Web API for creating indexed NoSQL databases in browser for a web page
*   Can create multiple object stores
*   Primary keys
*   Indexes
*   CRUD requests are asynchronous using promises
*   Follows same-origin policy (see CORS)
See: https://developers.google.com/web/ilt/pwa/working-with-indexeddb

---

### IndexedDB (Structure)
[Icon: Yellow circle]
[Image: Diagram showing a large blue cylinder representing "IndexedDB". Inside are two smaller cylinders: one green ("Database" with "Object Store" boxes inside) and one purple ("Database").]
One or more databases
Each database made up of one or more Object Stores

---

### IndexedDB elements (in DevTools)
[Icon: Yellow circle]
[Image: Screenshot of browser developer tools (Application tab > Storage > IndexedDB). It shows:
- **Origin**: e.g., developer.microsoft.com
- **Databases**: e.g., WebAudioDemo
- **Object stores**: e.g., configs, author, genre, name (these are nested under the database)
- **Indices**: (nested under object stores)
- A table view of an object store showing Key, Primary Key, Value.
- A context menu with Refresh, Delete item, etc.
- Object store entries list.
]

---

### IndexedDB Object Store
[Icon: Yellow circle]
*   Conceptually similar to database table, but NoSQL
*   Records - key, value pairs
*   Create indexes on object stores
*   Read/write is transactional

---

### `indexedDB.open` callback functions
[Icon: Yellow circle]
1.  `onerror` - handles an error when opening database
2.  `onsuccess` - should execute your transactions in this callback
3.  `onupgradeneeded` - executed when a new database is created or version number changes
    a.  Create Object Stores here
    b.  “New database” includes a new version number

---

### IndexedDB opening a database
[Icon: Yellow circle]
Check if the browser supports IndexedDB
```javascript
if (!window.indexedDB) {
  console.log(`Your browser doesn't support IndexedDB`);
  return;
}

const request = indexedDB.open('contacts-db', 1); // db name, version
```
Note: `indexedDB.open` returns an `IDBOpenDBRequest` object, not a Promise directly (though it can be wrapped in a Promise). `await` cannot be used directly on it without a Promise wrapper. Event handlers (`onsuccess`, `onerror`) are used.

---

### IndexedDB `onerror`, `onsuccess`
[Icon: Yellow circle]
```javascript
request.onerror = (event) => {
  console.error(`Database error: ${event.target.errorCode}`);
};

request.onsuccess = (event) => {
  const db = event.target.result;
  // do db transactions here
};
```

---

### IndexedDB `onupgradeneeded`
[Icon: Yellow circle]
Create a new object store called Contacts and give it an auto incrementing key
Create an index on the email field and make sure that each email is unique. It will throw an error if you attempt to add 2 records with the same email.
```javascript
request.onupgradeneeded = (event) => {
  let db = event.target.result;

  // create the Contacts object store
  // with auto-increment id
  let store = db.createObjectStore('Contacts', {
    autoIncrement: true
  });

  // create an index on the email property
  let index = store.createIndex('email', 'email', {
    unique: true
  });
};
```

---

### IndexedDB `onsuccess` populating the database
[Icon: Yellow circle]
```javascript
// (Inside request.onsuccess event handler after db is available)
// function insertContact(db, contact) { ... }

insertContact(db, {
  email: 'john.doe@outlook.com',
  firstName: 'John',
  lastName: 'Doe'
});

insertContact(db, {
  email: 'jane.doe@gmail.com',
  firstName: 'Jane',
  lastName: 'Doe'
});

// Function definition for insertContact:
function insertContact(db, contact) {
  // create a new transaction
  const txn = db.transaction('Contacts', 'readwrite');
  // get the Contacts object store
  const store = txn.objectStore('Contacts');
  let query = store.put(contact); // or .add() if key is not auto-incrementing or you want to ensure new record

  // handle success case
  query.onsuccess = (event) => {
    console.log(event); // event.target.result will be the key of the new record
  };
  // handle the error case
  query.onerror = (event) => {
    console.log(event.target.error);
  };
  // close the database once the transaction completes
  txn.oncomplete = () => {
    // db.close(); // Closing db after every transaction might be inefficient. Manage connection lifecycle carefully.
  };
}
```

---

### Cache Storage API
[Icon: Yellow circle]
*   Stores pairs of `Request` and `Response` objects
*   Cache can be hundreds of megabytes in size
*   Access cache:
    `const cache = await caches.open('my-cache');`
*   Adding to cache
    *   `add` – Fetches and caches.
        `cache.add(new Request('/data.json'));`
    *   `addAll` – Fetches an array of URLs and caches.
        `const urls = ['/weather/today.json', '/weather/tomorrow.json']; cache.addAll(urls);`
    *   `put` – Manually add a request/response pair.
        `cache.put('/test.json', new Response('{"foo": "bar"}'));`
*   Retrieving from cache
    `const response = await cache.match(request); console.log(request, response);`

---

## Progressive Web Apps
[Icon: Yellow circle]

---

### Progressive web apps (PWA)
[Icon: Yellow circle]
*   Web applications designed to appear to be ‘installed’ as native applications
*   Begin life in a browser tab…
*   … then can be ‘installed’ as native apps
*   Rely on **Service Workers**
    *   Notifications
    *   Background sync (offline cache)
For more:
https://developers.google.com/web/progressive-web-apps/checklist

---

### Service Workers
[Icon: Yellow circle]
*   Proxy ‘servers’ that sit between web applications, and the browser and network
*   JavaScript that:
    *   runs on its own thread: not blocking
    *   is headless (no access to DOM)
*   Rely on HTTPS, for security
*   Associated with specific server/website (scope)
For more:
https://developers.google.com/web/fundamentals/primers/service-workers

---

### Devices running SPAs / PWAs
[Icon: Yellow highlighting "Devices running SPAs"]
[Image: A desktop monitor, a laptop, a tablet, and a smartphone, showing a consistent blue screen, representing unified app experience.]
*   Many form factors and connection types
*   All have browsers, but also apps
*   One option is to develop web sites and native apps in parallel
*   Alternative is progressive web apps

---

### Twitter PWA
[Icon: Yellow circle]
[Image: Twitter logo.]
*   On mobile originally had separate **website** for in browser and an **installable native app** from app store.
*   Migrated to **progressive web app** on mobile in 2020
*   **Advantages** cited:
    *   Much smaller size
    *   Adaptable (no need for app store approvals when making changes)
    *   Automatic updates
    *   New operating systems (Broader compatibility by being web-based)
    *   Faster, more efficient development

---

### Criteria for Progressive (Web Apps)
[Icon: Yellow circle]
*   Responsive
*   Connectivity independent
*   App-like interactions
*   Fresh
*   Safe
*   Discoverable
*   Re-engageable
*   Installable
*   Linkable
https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/

---

### PWA “Good to haves”
[Icon: Yellow circle]
*   Mobile-friendly design
*   Near-instant loading
    *   Interactive in less than 5 sec before Service Worker installed
    *   Once Service Worker installed should load in < 2 sec
*   Work across devices & browsers
    *   90%+ of all users in market
*   Fluid animations
    *   Visual transitions
https://infrequently.org/2016/09/what-exactly-makes-something-a-progressive-web-app/

---

### Technical definition of a PWA
[Icon: Yellow circle]
*   Originate from a **Secure Origin** (HTTPS)
*   **Load** while **offline**
*   Reference a **Web App Manifest**
    *   W3C spec defining a JSON-based manifest
    *   Web app manifests | MDN
    *   `name`
    *   `short_name`
    *   `start_url`
    *   `display` (e.g., standalone, fullscreen)
    *   `Icon` – at least 144x144 px in PNG format
https://infrequently.org/2016/09/what-exactly-makes-something-a-progressive-web-app/

---

### Example manifest
[Icon: Yellow circle]
Deployed in HTML using a link tag
`<link rel="manifest" href="/manifest.json">`

[Image: A JSON manifest file example.
```json
{
  "short_name": "Weather",
  "name": "Weather: Do I need an umbrella?",
  "icons": [
    {
      "src": "/images/icons-vector.svg",
      "type": "image/svg+xml",
      "sizes": "512x512"
    },
    {
      "src": "/images/icons-192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "/images/icons-512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": "/?source=pwa",
  "background_color": "#3367D6",
  "display": "standalone",
  "scope": "/",
  "theme_color": "#3367D6",
  "shortcuts": [
    {
      "name": "How's weather today?",
      "short_name": "Today",
      "description": "View weather information for today",
      "url": "/today?source=pwa",
      "icons": [{ "src": "/images/today.png", "sizes": "192x192" }]
    },
    // ... more shortcuts ...
  ],
  "description": "Weather forecast information",
  "screenshots": [
    // ... screenshot objects ...
  ]
}
```
]

---

### Service Worker
[Icon: Yellow circle]
*   Javascript that runs in the background
*   Can be used to execute long-running processes
*   Must be started/registered by a web page
*   Allows websites to run offline by serving cached data
*   Must be served over https

---

### Service Worker lifecycle
[Icon: Yellow circle]
[Diagram:
No Service Worker -> Installing -> Activated -> Idle -> Terminated
Installing -> Error (if installation fails)
Idle -> Fetch / Message (when events occur) -> Idle
]

---

### Registering a Service Worker
[Icon: Yellow circle]
*   `serviceWorker.register` registers the service worker (js file) for this site
*   `scope` defines subset of content that Service Worker controls
*   Max scope is the location of the worker

```javascript
const registerServiceWorker = async () => {
  if ('serviceWorker' in navigator) {
    try {
      const registration = await navigator.serviceWorker.register(
        '/sw-test/sw.js', // Path to your service worker file
        {
          scope: '/sw-test/' // Optional: scope of the service worker
        }
      );
      if (registration.installing) {
        console.log('Service worker installing');
      } else if (registration.waiting) {
        console.log('Service worker installed');
      } else if (registration.active) {
        console.log('Service worker active');
      }
    } catch (error) {
      console.error(`Registration failed with ${error}`);
    }
  }
};

// ...

registerServiceWorker();
```

---

### Worker Install event (inside service worker)
[Icon: Yellow circle]
*   When `install` event is triggered, the worker can cache files in its scope
*   `self` refers to the worker

This code is inside the worker: `/sw-test/sw.js`
```javascript
const addResourcesToCache = async (resources) => {
  const cache = await caches.open('v1'); // Open a cache
  await cache.addAll(resources);
};

self.addEventListener('install', (event) => {
  event.waitUntil(
    addResourcesToCache([
      '/sw-test/',
      '/sw-test/index.html',
      '/sw-test/style.css',
      '/sw-test/app.js',
      '/sw-test/image-list.js',
      '/sw-test/star-wars-logo.jpg',
      // ... more resources
    ])
  );
});
```

---

### Serving data when offline (inside service worker)
[Icon: Yellow circle]
```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request) // Check if the request is in cache
    // .then(response => response || fetch(event.request)) // If not, fetch from network - common pattern
  );
});
```
[Image: Diagram showing the fetch event flow with a service worker.
1. Client (Page under scope) makes a request.
2. Service worker intercepts the request (hijacks).
3. Service worker can respond with cached data, or fetch from network, or construct a custom response.
]

This example listens for `fetch` and returns the cached data, but you can return anything you want in `event.respondWith!`
If data is not cached, it could make network request and update the cache.

---

### Data storage in a PWA
[Icon: Yellow circle]
*   Web Storage (Local storage)
*   IndexedDB
*   Service Workers and cached resources (using CacheStorage API)

---

### WebAssembly
[Icon: Yellow circle]
[Image: WebAssembly (Wasm) logo - WA in a purple block.]
*   Binary code that is pre-compiled to WebAssembly (wasm) from other languages, incl.:
    *   Emscripten (C, C++)
    *   Rust
    *   AssemblyScript (TypeScript)
    *   TinyGo (Go)
*   Ahead-of-time or Just-in-time compilation in browser
*   2019 W3C recommendation
*   Can be a supporting technology for PWA, but designed for any high-performance web page

---

### WASM applications
[Icon: Yellow circle]
Support for languages and toolkits
Image / video editing.
Games (e.g. with heavy assets)
Peer-to-peer applications
Music applications
Image recognition
VR and augmented reality
CAD applications
Scientific visualization and simulation
Interactive educational software, and news articles

Platform simulation / emulation
Language interpreters and VMs
POSIX user-space environment
Developer tooling
Remote desktop
VPN
Encryption
Local web server
Fat client for enterprise applications (e.g. databases)

---

### WebAssembly bytecode
[Icon: Yellow circle]
[Image: Table comparing C source code, WebAssembly .wat text format, and WebAssembly .wasm binary format for a factorial function.
**C source code:**
```c
int factorial(int n) {
  if (n == 0)
    return 1;
  else
    return n * factorial(n-1);
}
```
**WebAssembly .wat text format:**
```wat
(func (param i64) (result i64)
  local.get 0
  i64.eqz
  if (result i64)
    i64.const 1
  else
    local.get 0
    local.get 0
    i64.const 1
    i64.sub
    call 0
    i64.mul
  end)
```
**WebAssembly .wasm binary format:** (Hexadecimal representation)
`00 61 73 6D 01 00 00 00 ...`
]
More examples: https://wasmbyexample.dev/home.en-us.html

---

### Web Technologies (Modern Landscape)
[Icon: Yellow circle]
*   Client-side tech is now much more than HTML/JS/CSS

[Image: Complex diagram showing the "Developer machine", "Server (e.g. Node.js)", and "Browser" columns.
**Developer machine -> Front-end code:**
  - TypeScript (.ts/.tsx) -> tsc (typescript compiler) -> ES? (.js)
  - ES7 (.js) -> Babel -> ES5 (.js)
  - JSX (.jsx) -> Babel -> Hand-written JavaScript (.js)
  - C/C++ (.cpp) -> emcc -s WASM=1 -> WebAssembly (.wasm)
  - SASS (.sass, .scss) -> sass (compiler) -> CSS (.css)
  - Plain HTML (.html)
  - Markdown (.md) -> Markdown processor -> HTML (.html)
  - Various template languages -> Page templates -> Page generator (Node.js, PHP, etc.) -> HTML (.html)
**Bundler/Minifier (optional)** takes JS and CSS.
**Styles** (CSS) and **Content** (HTML) are processed.
**Server** can also generate HTML, JSON, CSV.
**Browser** (Chrome, Firefox, Safari, Opera, Edge, IE) receives HTML, CSS, JS, WebAssembly, Data. Communication is via XMLHttpRequests.
]

---
---

# SENG 365 Week 12
## Bundling and Front-end testing

[Icon: Lightbulb]

---

### Topics this week
[Icon: Yellow circle]
*   Modules and dev/deployment pipeline
*   Automated testing
*   Webdriver
*   Client-side JavaScript testing
*   Final Exam

---

[Image: A complex origami structure made of yellow and red paper modules, resembling a cube or a complex geometric shape. Text overlay: "Modules and the Development / Deployment Pipeline"]

---

### Downloading Single Page Apps (SPA)
[Icon: Yellow circle]
*   A SPA usually consists mostly of JS and HTML templates.
*   Critically, the ‘preferred form’ of developing SPAs is not a good format for downloading:
    *   Many small files
    *   Data that is not needed at runtime (ie, good function names, comments)
    *   Often the preferred coding language is not JavaScript (e.g. TypeScript)

---

### Bundling
[Icon: Yellow circle]
*   Bundling is the process of taking the preferred form of web code **for developers** and putting it into the preferred form for a **browser to consume**
    *   Analogous to compiling a C or Java program
*   What does a browser/user prefer?
    *   Fewer network requests (fewer files)
    *   Smaller network requests
    *   Parallel network requests
    *   No network requests at all (caching)

---

### Simple Bundling (fewer files)
[Icon: Yellow circle]
*   Concatenate all required `*.js` files to one big file
*   Do the same for `*.css` files
*   Tools like Gulp, Grunt, RollUp follow this basic pattern:
    *   Sweep up a bunch of files without knowing about file content
    *   Perform some transform on them to generate (fewer) output files

---

### Simple Bundling (smaller files - Minification/Uglification)
[Icon: Yellow circle]
*   Browsers don’t care about JS function names (much)
*   We do care about data sent over the network though
*   Shorten var and function names

[Image: Code snippet.
Before:
```javascript
function globalFunctionName(input) {
  function nestedFunction() {
    input = input + 1;
    console.log(input);
  }
  nestedFunction();
}
```
After (conceptual, using uglifyjs):
`$ uglifyjs foo.js --mangle --compress --source-map=map.out`
```javascript
function globalFunctionName(n){!function(){n+=1,console.log(n)}()}
```
]

---

### UglifyJS, Terser, ESBuild etc. (Minifiers)
[Icon: Yellow circle]
*   Code is **name mangled**, some **optimizations** are applied
    *   Mangling can only be applied when we are **sure** that all instances of the name are renamed
*   Result is **difficult to read**, but very **easy to reverse engineer** – so this offers **no intellectual property protection**
    *   Anything you send is public knowledge
*   To aid debugging, **sourcemaps** can be created:
    *   Browser loads mangled code + sourcemaps and the dev tools presents the code as it originally was
    *   Learn more: https://github.com/ryanseddon/source-map/wiki/Source-maps%3A-languages,-tools-and-other-info

---

### Bundlers: Webpack, Rollup, Parcel, Vite, …
[Icon: Yellow circle]
*   Bundlers are the current best practice
*   Understands the input language (JavaScript/TypeScript)
*   Configure with
    *   Where to find input files
    *   Where to start from (app entry point)
*   Will recursively follow imports
    *   Import -> `import foo from "module_name"`
    *   Export -> `export foo = 42;`
    *   Only the files that are used get pulled into the final output
    *   Unused (dead) code can be removed (tree shaking)
*   Final output will be something like `main.9789bf1740765e50e459.js` (with content hashing for cache busting)
    *   Might contain more than raw TS size because of 3rd party modules

---

### Lazy Loading
[Icon: Yellow circle]
*   Break your SPA into **logical chunks**, eg
    *   Login (likely the main chunk)
    *   Settings
*   Only download the chunks you need
*   Typically loading is triggered on router changes
    *   `/login`
    *   `/settings`
*   The framework and the bundler need to agree on how to **split the import graph**, usually done with bundler plugins or framework features.

---

### Lazy Loading in React
[Icon: Yellow circle]
*   Vite will do automatic code splitting with `React.lazy` (Webpack and other bundlers also support this pattern)
```javascript
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./LazyComponent'));
// './LazyComponent' will be a separate chunk

function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

---

## Automated testing
[Icon: Yellow circle]
**Web Applications**

---

### Brief overview to testing
[Icon: Yellow circle]
*   Many different **types of tests**
    *   Unit tests, behavioural tests, acceptance tests, regression tests
*   Many different **kinds of system to test**
    *   Safety-critical, embedded systems, real-time systems etc
*   **Particular challenges for testing web applications:**
    *   Different browsers (FireFox, Chrome)
    *   Different versions of browser (IE6 vs IE8)
    *   Differences in versions of HTML, ECMAScript (JavaScript)
    *   Differences in APIs e.g. how XHRs are handled by different browsers
    *   Differences in the handling of the DOM, JavaScript etc.
    *   Differences in libraries and versions

---

### Advantages of automating testing
[Icon: Yellow circle]
*   Automation means you can offload testing to machines (rather than rely on humans)
*   (More) frequent testing e.g. regression testing
*   Quick and regular feedback to developers
*   Virtually unlimited iterations of test case execution
*   Support for Agile and extreme development methodologies
*   Disciplined documentation of test cases
*   Customized defect reporting
*   Finding defects missed by manual testing
*   Supports continuous integration and continuous deployment

---

### When not to automate (and manually test instead)
[Icon: Yellow circle]
*   **On the client side:**
    *   If the user interface is rapidly changing
    *   e.g. HTML elements are changing
    *   Will need to keep changing the tests to match the interface
*   **On the server side**
    *   If the API is rapidly changing…
    *   Tight timescales
    *   Don’t have time to develop the tests

---

[Image: W3C logo.]
**Automated testing of clients: WebDriver API**
https://www.w3.org/TR/webdriver/

---

### WebDriver API
[Icon: Yellow circle]
[Image: W3C logo.]
*   Intended to enable web authors to write tests that automate a user agent using a separate controlling process
    *   May also be used to allow in-browser scripts to control a (possibly separate) browser
*   Provides a set of interfaces to:
    *   discover and manipulate DOM elements in web documents; and
    *   to control the behavior of a user agent (a browser).
*   Provides a platform-neutral and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.
*   Forms part of the W3C Web Testing Activity

---

### WebDriver API (Questions)
[Icon: Yellow circle]
[Image: W3C logo.]
*   Intended to enable web authors to write tests that automate a user agent using a separate controlling process…
*   Provides a set of interfaces to discover and manipulate DOM elements in web documents; and
*   Provides a platform-neutral and language-neutral wire protocol as a way for out-of-process programs to remotely instruct the behavior of web browsers.

**Questions**
*   Any implications relating to the DOM here? (Tests rely on DOM structure; changes break tests.)
*   Any concerns relating to out-of-process programme controlling web browsers? (Security, performance overhead, complexity of setup.)

---

[Image: Selenium logo (Se with a checkmark).]
**Selenium**

---

### Selenium-WebDriver | Selenium 2.0
[Icon: Yellow circle]
*   Automates a browser
    *   Use to automate testing
    *   Use to automate routine web tasks e.g. some admin task
*   Selenium WebDriver: drive the browser (automatically) the way a user would
    *   Automate what you want the user to do
    *   Automate what you want the user not to do
    *   Automate unintentional behaviour, accidental behaviour, stupid behaviour, risky behaviour (e.g. security attacks?)

---

### Selenium-WebDriver (Dynamic Pages)
[Icon: Yellow circle]
*   Developed to better support automation of **dynamic web pages**,
    *   Dynamic pages: elements of a page may change without the page itself being reloaded. (What is a webpage?)
    *   Single Page Applications generate dynamic web pages
*   WebDriver relies on the browser’s built-in (native) support for automation
    *   You’ll need an up-to-date browser
    *   Harder to automatically test older browsers

---

[Image: Diagram showing Selenium WebDriver architecture.
Left: Web Server (cluster of computers). Arrows point to and from Browser.
Right top: Selenium Commands (Java, .Net, Python, etc.) - user's test script.
Two-way arrows connect Selenium Commands to Browser.
This illustrates that Selenium commands directly control the browser.
]
**Selenium Webdriver**

---

### Cross-browser testing
[Icon: Yellow highlighting "Cross-browser testing"]
“When we say “JavaScript” we actually mean “JavaScript and the DOM”. Although the DOM is defined by the W3C each browser has its own quirks and differences in their implementation of the DOM and in how JavaScript interacts with it. HtmlUnit has an impressively complete implementation of the DOM and has good support for using JavaScript, but it is no different from any other browser: it has its own quirks and differences from both the W3C standard and the DOM implementations of the major browsers, despite its ability to mimic other browsers.”
http://www.seleniumhq.org/docs/03_webdriver.jsp#htmlunit-driver

**Implication**: automate your testing on **different** browsers

---

### Example automated testing (Selenium WebDriver with JS)
[Icon: Yellow circle]
```javascript
const webdriver = require('selenium-webdriver'),
    By = webdriver.By,
    Key = webdriver.Key,
    until = webdriver.until;

const driver = new webdriver.Builder().forBrowser('firefox').build();

driver.get('http://google.co.nz')
 .then(_ =>
   driver.findElement(By.name('q')).sendKeys('university of canterbury', Key.RETURN)
 )
 .then(_ => driver.wait(until.titleIs('university of canterbury - Google Search'), 1000))
 .then(_ => driver.quit());
```

---

### Example automated testing (Highlights)
[Icon: Yellow circle]
[Image: Same code as previous slide, with parts highlighted:
`require('selenium-webdriver')`
`By`, `Key`, `until` (from webdriver)
`'firefox'`
`'http://google.co.nz'`
`By.name('q')`
`driver.wait(until.titleIs('university of canterbury - Google Search'), 1000)`
`driver.quit()`
]

---

### Summary of what you can do (with Selenium WebDriver)
[Icon: Yellow circle]
*   Fetch a page:
*   Locate a UI (DOM) element
*   Get text values
*   User input
*   Move between windows and frames
*   Popup dialogs
*   Navigation and history (may be harder in SPA)
*   Cookies
*   Drag and drop
*   Check out the details:
    https://www.selenium.dev/documentation/en/

---

### Example of what you can do (Selenium WebDriver)
Fetch a page:
`driver.get('http://www.google.com');`

Locate a UI (DOM) element By ID:
*   `let element = driver.findElement(By.id('someID'));`
*   Compare with JavaScript `getElementById();`

---

[Image: Diagram of Selenium Server (Remote Control Server) architecture.
Multiple browser instances (Selenium Core in IE, Firefox, Safari) on different machines/OS (Windows, Linux, Mac) are controlled by a central Remote Control Server. The test script (Java, Ruby, Python, Perl, PHP, or .Net) communicates with the Remote Control Server.
A "Machine boundary (optional)" line is shown between the test script and the Remote Control Server, indicating they can be on different machines.
]
**Selenium-Server**

---

### WebDriver vs the Selenium-Server
[Icon: Yellow circle]
*   You can use WebDriver without Selenium Server
    *   Browser and tests will all run on the same machine
*   However, there are reasons to use the Selenium-Server, e.g.
*   You are using Selenium-Grid to distribute your tests over multiple machines or virtual machines (VMs).
*   You want to connect to a remote machine that has a particular browser version that is not on your current machine.

---

### Test Utilities for JavaScript frameworks
[Icon: Yellow circle]
*   Vue, React, Angular, etc. all have test utilities
*   **JavaScript testing**, *not browser testing* (Selenium-Webdriver)
*   Allows you to run **unit and integration tests**
*   JavaScript test runner:
    *   Agnostic about the framework
        *   **Jest**, https://jestjs.io
        *   JavaScript test runner that lets you run tests of DOM interaction (Jest with JSDOM, or tools like Testing Library)
*   **React Testing Library**
    *   https://testing-library.com/docs/react-testing-library/intro

---

### React Testing Library (Example)
[Icon: Yellow circle]
```javascript
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import Fetch from './Fetch'; // Assuming Fetch component exists

test('loads and displays greeting', async () => {
  render(<Fetch url="/greeting" />); // Render the component

  fireEvent.click(screen.getByText('Load Greeting')); // Simulate a click

  // Wait for the greeting to appear
  await waitFor(() => screen.getByRole('heading'));

  // Assertions
  expect(screen.getByRole('heading')).toHaveTextContent('hello there');
  expect(screen.getByRole('button')).toBeDisabled();
});
```

---

### Final Exam
[Icon: Yellow circle]
**When:** June 11th, 2:30 pm
**Time:** 2 hours
**Format:** Mix of short answer (incl. code), multiple choice

**Where:** In CSSE Computer Labs.
Exam password will be shared on Learn before exam starts.

**Closed book**

---


LECTURES:

SPEAKER 0
Yeah So So All right, hello everybody.

SPEAKER 1
Welcome, welcome. I, um, my name is Ben Adams. I'm the lecturer for this course, assuming you're in the right room, so this is the web computing architectures course, um, 365, uh, so this is, uh, a course, uh, that I think I'm I'm guessing many of you are either computer science or software engineering students, but we might have a few other students here. Just a show of hands, how many of you are software engineering students? Yeah, so this is a required course as part of the program. How about computer science? All right, so it's about half and half actually, uh, and maybe a few others, um. So, so yeah, this is a course, uh, that builds off of some, uh, kinds of content that you, you've covered at 200 level, namely databases, uh, but it really goes into um some whole other areas, um, it's. Uh, course about programming web applications, obviously, um, but it covers aspects both in terms of the server side, um, where we might build services on the web that other applications use and. as well as uh the kinds of interactive uh single page applications that we've come to like get used to in in our everyday web usage um and so this course, uh, is a course that will probably have a lot of um practical um results for you like so we're gonna learn a lot, um, going through different kinds of assignments and and programming. Uh, problems where you're going to actually develop an application both on that back end side and the front end side that I was talking about, um, and so it's the kind of course where I think you might find a lot of practical skills that you'll develop. Um, that you know might go directly into the work that you do for the software engineering students, um, if you do any kind of fourth year project that focuses on web development of any sort, um, it'll also, uh, come in handy, um. So this is the learn page obviously I don't need to give you like a whole spiel about the learn page, but um just so you're aware, we have the, the course outline is here on the course information tab. Um, so this course outline, uh, I will just open it up real quick, um, you know, covers, uh. Basic information about the team which I'll I'll talk about in a moment uh as well as um the schedule of different topics that we're gonna cover in the course so I'll cover that in on the slides in in just a moment as well, but you can always refer back to this as well. It also has information about. The labs, the assignments, and so on. All right, uh, so also on the learn page, um, I'll share all the lecture slides obviously, but also we have the labs as well. So labs, I think kick in, uh, tomorrow, um, and, uh, so the first week of labs, um, are kind of pre-labs so the idea here is that that we have a series of three pre-labs that are. Trying to kinda get you up to speed if there are any gaps you need to fill in before getting into the main content for the course, um, so just out of curiosity, um, how many of you have ever done anything with HTML or CSS or anything of that sort? OK, maybe about half, uh, how about JavaScript? Right about the same, um, so this course, um. Has like pre labs give you a little bit of basic information on you know some things around HTML and so on and so forth, but that's not really the crux of what this course is about we do go into a rather bit of depth about. JavaScript and also TypeScript as programming languages. If you already know them, then maybe that'll be somewhat of a review, but we also dive in a little bit deeper than just learning to program JavaScript but also to talk a little bit about how. You guys sort yourself out. Yeah, squeeze it. Yeah, so then, so we're, we're gonna dive into a little bit about what's unique about JavaScript as a language, um, early on in in the lectures, um, as, as we continue through, but the, so, so if you have had some experience, um, you know, I think you there will be some new information, um, oftentimes. Web programming, JavaScript, things of that sort, those are the kinds of topics that people oftentimes get introduced to, um, you know, early on when they're learning program even, you know, they might get online, do some tutorials, just kind of search around, uh, look up questions on Stack Overflow or now chat GPT or whatever, you know, and, but, um, it's. It's easy to kind of learn how to program poorly uh with web programming so one of the goals that I'm trying to do with this course is to to give you the foundation to be good web programmers, um, and so part of that is is learning something about these languages, um, but then also the underlying. you know, structure of how to construct uh robust web applications. So in, in doing so we're also gonna talk about other topics that maybe don't relate directly to the assignments and what you will be doing in the labs, but a bit more of the kind of conceptual material in in the labs as well, um, so. The first half of the of the course is really gonna focus on the back end, the server side, and the second half is gonna be about like actually building, uh, a web application, like a browser application. Uh, but I'll talk about more of that in, in, in some more detail, uh, just a moment. So, hopefully you're all in the right place, and hopefully you'll um find this, this course like enjoyable and um and, you know, we can. Uh, if, if at any point you're like, um, feeling like you want kind of to give me feedback either about like the pacing or anything of the other sort, I'm always happy to have that as a lecturer I'm, I, you know, oftentimes like with a large course like this, it's hard to kind of pick up on, you know, the feedback of how people are kind of interpreting, you know, the information that I'm conveying. Um, and so I'm, I really want to encourage you from the outset to, to engage and ask me questions at next year, feel free to stop me at any point, you know, that's totally fine, um. All right. So On the learn page we have um the different tabs that we'll talk more about assessment that you can always find the lecture slides here and the labs as well and the labs, um, when you go into the labs, uh, this week, the focus will be on those kind of pre-labs. Those are all, um, here on, on this page, and, and you can start to go through them. The first one is just some background concepts, um. The second one, is a little bit about like front and web development, so very basic kinds of things, uh, and then the third one is, is really about, uh, version control with Git. So the other element of, uh, what you're going to be doing is you're you're gonna be developing these, um. Essentially codebases that you're gonna upload to Eit, um, which is our, our, uh, GitHub style repository. So how many of you have used EGit already? Oh good, great. So most of you have. So, so, uh, you'll be familiar with that, but if you're not, there's the pre la. See a little bit of tutorial. So that's the focus for the first week in the labs, um, and the lab tutors will be there available to answer any questions. If you feel like you can just breeze through the stuff, by all means, you can start looking at the next week's lab material that's right here, uh, down here, lab one officially we kind of start that next week. All right. Any questions so far? Yep. OK, cool. I'm just gonna OK. So this week is really going to be introduction and I'm going to start to uh kind of give you some basics around the JavaScript uh language as well. So. Let's just dive right in. So. What I wanna talk about, um, to begin with is, um, first of all scoping out what we actually mean by web applications within the context of this course. It's not like web applications are like some formally defined thing um we often refer to things as uh web applications or not, um, and we need to kind of understand sort of for the scope of the course like what we're actually talking about so we understand what we're trying to, uh, learn about, um. Once I kind of do that brief kind of context setting, uh, I'm going to give you an outline of the course and then for the remainder of the first week, um, I'm giving you preliminary information about HTTP, which is the main protocol, uh, that kind of underpins all the web applications as well as digging in into JavaScript. Um, all right. So, what is a web application? Does anybody have an idea when I just try to define it? Don't be shy. Any thoughts? So it's gotta have an idea of what a web application is, right? We use them all the time. Yeah. All right, so an application that you can interact with on the web, um. Yes, that is, is something that a web application has, but within the context of the like how we're talking about it, we have a little bit we're gonna try to break it down a little bit more than that, so. You could think about it maybe it's like what makes application a web application rather than a desktop application or a mobile application or an embedded application and the important thing to know is that all of these other things, the desktop application, uh, the mobile application, and the embedded application can still interact with the web, right? There's, I mean if you have network connections, uh, you can do that, um. And in some sense, the things that we're gonna be covering in this class, um, will have relevance to those other types of applications like a desktop application or mobile application. That uh say interfaces with a web service, um, but what really distinguishes the web application is we're we're talking about applications that are running inside of some browser environment, um, you know, like Chrome or or so on, um. But it's still like when we get to mobile uh computing, like if for example, if you were to take mobile computing. Next, um, semester, uh, then that one, you know, you'll see that in fact there's even some overlaps between what we will cover here in web applications and and what we consider a mobile application, um, but let's just think about, you know, these different kinds of applications so I think probably we could agree that TradeMe is a kind of web application, right? So if you go on TradeMe, uh, you. It runs in a standard browser, um, you know, so it's using kind of the de facto technologies of the browser it's using JavaScript, uh, it's using CSS, it's using HTML, uh, and in fact it's using all kinds of APIs that the browser provides for the application, um. So things that you don't maybe not aware of yet but like XHR and local storage which we'll we'll discuss about all of these things, these are parts of, uh, you know what is are used in an application, uh, like a trade. It also communicates over HTTP, which is a, um, protocol, uh, for communicating, uh, over the web, um, it, uh. Sometimes they will use other third party services, um, other APIs and so on, uh, to collect information and connect to things, um, probably something like TradeMe doesn't use that so much. They maybe have just like their own kind of, you know, database that they service, you know, through some web web service to their application, uh, solely. Um, but you know it's possible that they hook into other, um, services that are provided by, for example, advertisers and and other sorts of things, um. And, uh, and so on. So TradeMe is definitely what we're gonna consider something like a web application. Uh, I would also say Gmail, uh, running in something like Chrome is, uh, so Gmail actually it was sort of like the archetype of like, uh, the single page application which we're gonna talk about like it was like the original, uh, application to, uh, like really combine certain types of web tech technologies together, uh, in a new way that allowed you to build browser applications that behaved somewhat like desktop applications, um. But, um, probably you know just for the sake of sort of the context, of course we're gonna say, you know, Gmail apps running on Android or iOS that's that's not, that's not within the scope, um, you know, we're not, we're not talking about building native applications on a mobile device, uh, in this class. Facebook and a browser. Now Office 365, I mean that's sort of like a desktop application. It still interacts with the web like you can, you can, um, have it, you know, interact with files, um, in cloud storage and so on and so forth, but it's still not like, uh, it's not living inside of a browser application. And same with Dropbox, Google Drive, all of these things are sort of technologies that are built upon the Internet and making, you know, connecting to services, but it's not like what we're gonna talk about, uh, here, um, so you can kind of think about maybe it's like thinking about the line also being the distinction between the World Wide Web and the Internet, uh, where, where these applications, uh, kind of sit. Um, but you know, this is just a way of scoping out sort of what we're trying to, where we're trying to go with the course. Um, I wouldn't claim that these are like clearly defined, uh, categories in any, in any sense, um. So, I mean the other thing that also blurs the line a little bit is that. Historically, and I'll have an example in a moment like historically like web applications or if you could even call them web applications we're not super interactive, right, but there's all kinds of technologies that are built into the browser now including like kind of the various APIs that allow us to. Have really sophisticated input and interaction with a web application and a browser that approximates the experience similar to like what we think of as more like a desktop application. So, um, in the talking about like what things used to look like, here's a, a, uh, a slide showing the million dollar homepage. Has anyone heard of the million dollar homepage? A couple people, uh, for all those who haven't, um, back in 2005, uh, there was this guy who just decided, um, that he was going to create a web page and he was going to sell. Individual pixels on the web page as advertising. Um, and this was one of those kind of like self fulfilling things, right, because he had this idea, it then became sort of, uh, it got picked up by some newspapers like I think it was like put on like the front page of different things. I, I don't know I can't imagine why, you know, nowadays you would think it's like kind of crazy but it was sort of like this, you know, innovative way of thinking and. It because it was getting the attention, then it became a good place to advertise and so he's the person sold like all these like a million pixels made a million dollars on the home page right? um and this is back in 2005 when a million dollars is worth even more, um, so, um, I mean next time you think there's like, you know, the craziest like crypto scam or whatever it's like really nuts. I mean this stuff has been going on for a very long time in terms of wild ideas that make a lot of money and then. Uh, fall apart, um, but anyhow, like the, you know, back then, you know, this was an application that people that lived on the web in some sense and they could interact with it. So if you look at the web page, um, I mean it's kind of hard to see and it's such a blurry image, right? But there are actually things you can click here, uh, and interact, uh, with, um. But the iPhone wasn't around. I mean there were no mobile applications or anything like that, um, and but it was like a sensation at the time like it even had denial of service attacks put up against it and and so on. You can actually read all about it there's like a Wikipedia page about the phenomenon of it, um, so this is a kind of, uh, web application, but let's try to tease apart a little bit about. Whether or not it in fact it was because you know there's something to do with putting information on the web like say create an HTML page that's a static page where you wouldn't really think it's an it's an application per se, right? It's just a just a web page and maybe it has some links uh and so on, um. So if you were to go now, I actually don't even, I mean, I didn't, I haven't tested this, um, recently. Um, but as you know, sometime much later, right? If you were to go there and click the buy button, Um, this is what would happen to you like you would, uh, basically get a not found error, uh, and it would, um, you know, it, it basically is broken and no longer allows you to follow, you know, the action, you know, the service to to buy the pixels that you want, um, but. I mean there's a few, a few things to consider in this. I mean, first of all, I mean it is a demonstration of what the phenomenon of link rod or system decay or however you wanna, uh, to, um, uh, characterize it like even best for like 2014, you know, uh, like a quarter of the, of the links within the like you could click on the pixels and it would take you to a you know like it would link to the person's homepage like most of those were were dead. But the more interesting thing about all of this is really. Like what you, when you look at the the URL here, so. You go to the homepage, you click on a link and you can see that it is, it, it's not only the homepage, the Million dollar homepage.com, but then it has the buy.php. um, so what is that? So PHP, uh, we used to teach this classes using PHP. We don't anymore, but PHP is a scripting language that sits on servers. Um, and essentially what you're, what you're doing when you go and make a request like that is you're asking the server to execute this PHP script in the language PHP. That script generates sort of dynamically some HTTML and sends it back as a response to the browser, which then renders it inside of the inside of the browser. So we're gonna talk about uh a concept around application programming interfaces a lot and like endpoints and so on. This is not really an end point in the sense that we're gonna talk about in modern uh web computing, but we're kind of it it's a little bit it's got some of the features of of uh kind of like a web web program in the sense that there's some service um. That by clicking, you're interacting with it, it's going to, uh, essentially, um, you know, dynamically generate some, some information. What we're gonna see is that as we get to the notion of single page applications we don't actually go through this process of going to a new link we don't, we don't navigate more sort of within um the file system of the server. In instead, what happens is this is replaced by some kind of abstracted routing. Um, that, uh, causes in some cases like a dynamic re-rendering of the web page, you know, on the client side without even necessarily going to the server, so it's a lot more sophisticated now, but we're, we're getting this is hinting that like, you know, early on we're starting to say we're not just asking for HTML but we're asking for a script. That's gonna create some kind of content, uh, that the, the browser can then. That uh render. Um, so that's sort of like, uh, maybe think of that as like a Jurassic, uh, web application or a proto one, but we're gonna talk a lot more about what, what those, um, you know, what, what kinds of, uh, kinds of, um, architecture you need to actually create, um, modern web applications and what kinds of, of technologies work together, uh, to do that. So, so that's just kind of, you know, setting the stage a little bit, um, uh, you might ask why bother taking a course on web application architecture. I mean, I just said earlier that you could probably do, you can learn a lot about web programming by just searching around on the web, right? Um, so, so why, why take the course, um, well. I like to use this example as maybe a motivating example of why, why it's, what kinds of things can go wrong if you just try to like wire together, um, you know, a web program. Without really knowing what you're doing, right, um, and, and try to hack it together, so. This is a prey card page from a while ago. This is not at all you know how it is now, but Pre cards, you know, those are the things you can basically get gift card for people. And so they have a, a web page, uh, or they had a web page here that was like a login page, um. And there's several things wrong with this user interface, um, and part of, you know, the reason potentially that it's, it's it's so wrong has to do with the fact that there's not kind of a consistent and coherent way of handling the state. Of the application both in terms of sort of the state of the application as it's running in the browser or the kinds of, um, you know, the representation of the information and the schema of the of that on the server side um and so what you end up with is an application that breaks horribly, um, like I mean. You might not be able to see this, but so, for example, this is a login page. This is a real page that that was, was there, um. So, you're entering your card number, I guess you're like kind of um. This is, you know, your credit card code. Well, the first thing is there's two sign in buttons like what's up with that, um. Doesn't make any sense, but, um, you know, then it has an error message saying date of birth, uh, field cannot be left blank. I don't know about you, but I don't see a date of birth field here at all. um, so what's happening here I mean I can speculate what's happening is that there was an API or like an application programming interface they had on the server side that took some kinds of um, you know, requests in. And those requests um were specified in such a way as they're supposed to be a date of birth field then the user interface designer came along and they didn't bother to look at that spec or or try to match it at all, but they just created their own, you know, what they thought, uh, made sense and then the message, the error message is probably an error message that's coming back from the server. Saying some piece of data or some field in your data is not set. And all the user interface is doing is printing the error message that's coming from the server without thinking about it. So Long story short, the reason why you take an a course like this is to try to think about, uh, um, understanding, you know, how to build good web applications that don't end up like this, and I think, um, part of that is about. What we're gonna be talking about in terms of designing application programming interfaces matching those up to a uh to a a web application, uh, and the data representation that goes alongside uh the application how you manage state between, uh, you know, both computers and so on. So this is just sort of a silly example of how it can go horribly wrong, but web computing or web programming is, um, it's actually extremely like complex, um, and it gets it gets really complex, um, in the context of, uh, you know, big enterprise applications or applications where you have heaps of different users and there's all kinds of challenges uh that go into that, um, so. The different challenges that you have is that if you think about a web application, and it's, it's, and uh I'll kind of present this a little bit more formally in, in the poet, but if they want a web application, I have my browser sitting on my computer. And I open up the browser and I go to a web page. What's happening behind the scenes is it's the browser makes the network request to uh some system. In fact, it probably in any kind of, you know, sufficiently complex um web application it's probably making like up to dozens of different requests um to all kinds of services so it's taking a request maybe to like um to get the fonts from one server, maybe it's pulling, you know, some information, you know. An authentication, you know, server here, so on and so forth so web applications have to consume services from another system, so you need to have those two, computers be able to talk to each other and really kind of work together well. this is can be a lot more um complex than you might imagine because those services are also potentially evolving over time. Um, That the flip side is you need to provide services to another system, so we're gonna talk about APIs and sort of having web services so you will create a service running on your on your um server and then you might have who knows how many different computers, um, anywhere on the web attaching to your server and your service and and consuming. So you don't know who those people are, you don't know how they're using your services necessarily. And so you need to be able uh to do that. Um, Applications web applications become very complex, uh, very quickly and so it's you need to figure out some way to kind of modularize your application uh to manage the complexity partly that's around kind of the programming and the design of of the application but it's also, um, just in terms of, um, you know, understanding how uh like what components of the of the applications communicate with with each other. Um, the more you can modularize, you know, the better, more robust your, your system is going to be. So one of the things that you're gonna find that's the biggest difference in web programming from what you might have done previously. Um, I don't know, I'm guessing, so I'm thinking like you've probably done some Java programming, right? Um, you've done some, you know. Different kinds of, you know, uh. Basically, lots of scripting uh different kinds of applications. I don't know how many. Uh, you know, really large applications you've built, but. One of the things that is unique really well maybe not unique but it's it's sort of indicative of web programming is the fact that it's dealing with overlapping asynchronous requests all the time. So what does this mean? Well, it means that like if I'm interacting with my browser, not only is the the user potentially interacting with different elements of your application in all different orders of operation. But you make a request to a server to get one piece of data and then you make a request to another, you know, server, those things are asynchronous in the sense that your application has to keep on running. It has to keep running. It has to be interactive. Oh well, you're waiting for that first piece of information and that second piece of information to come back and then once those things actually happen, then you need to update your user interface in response to that. Um, and it that can get extremely like complex to like model and and and and conceptualize. Um, the other, another challenge is that. You If you've ever built your own application, right, it's easy to sort of maintain the state of your application, right? You can, you can either kind of have some variables and you store your data in it, or maybe you like store the files on the file system. Next time you open the application, you read the files, or if you use a relational database, you might store some information in the tables on your database. Um, but you know, for, uh, a, a web application you've actually got different components with potentially different like states going on, so you might have a server that's got a database, but you also have the user interacting in real time with the interface and so you need to sort of figure out ways to persist those changes uh in in some way. And this is really, you know, gets more complex, like the more distributed and large your system is you're talking about. Um. So another big issue with web applications. Is that you need to know how to allow and restrict user uh access to things. So when you build your applications, your assignments, you're going to have to have user logins, uh, you're going to have to be able to know kind of manage the state, the session state of your application. And, uh, you know, for, for many cases, these are kind of like well-known patterns that you follow, but It's not the kind of it's not something you maybe would have to think about in in other contexts, you know, but because you're dealing with uh you know a system potentially where you have like a large global state uh in the database and you've got different users you need to be able to manage all of the access and permissions um for that now that we're gonna really focus on that in this course from the from the perspective of a user logging in. Um, It's kind of outside of the scope of this course to talk about server admin. That's not really what we're going to be like sys admin type stuff, um, which is still very important for building a web application, but we're just not really going to cover that. Um So, of course, you know, it's not just about taking data and you know, managing access to data and information, but of course there's the whole visual kind of user interface side of of any web application, you know, so you need to be able to to develop that. Um, And an important thing is that you also, um, in many cases have to synchronize information, you know, that's in different views. So we're going to talk in term two about building applications that have essentially a state. But then the views will be attached to that state, um, but you need some way to make sure that they are synchronized so that for example if one view has an input that changes the state, then the other view needs to be able to automatically update in response to that. Um, Another kind of more general challenge, um, you know, if you're like developing an application, uh, that you have lots of real world users for is that you also need to think about how the user experience just in terms of how responsive your application is, um, so this will come into play. Less so in kind of your what you're developing here, but it's something to think about like, you know, in the larger scope of building uh web applications. So like if you were, for example, if you're, if, if, if you need your web page needs like 10 seconds. Gets to load or use China need to change some piece of information um in the database and the turnaround time for that is multiple seconds that's basically going to kill any commercial viability of your application um so you need to to manage all of that and there is also responsiveness sort of just in terms of the user interface itself. Um, Another key point, and now this is not no longer like specific to web applications this also relates to mobile applications, but it is a it is an important thing and that is that um. When you design the interface for your application, you never know kind of what environment the user is going to be looking at your application. I'm, I might be opening it sort of in a little like window, um, on my, you know, on my laptop or I might have it on a huge, you know, widescreen display, um, and so because of that, um. The layout and the interaction of your application has to be responsive to that. Um, and then also increasingly important is that if you are using any kind of user data, you need to manage that securely, um, as well. So, all of these things, oh, yeah, there's one more here, and that is, you have to, I mean, the flip side of that is you protect the user data and you also protect your own data. The point here is that building like kind of a complex modern web application is actually really difficult um to do well. It's very easy to mess things up, right? And so. For sure you know there's all kinds of different strategies and approaches to doing that um but I'm hoping in this course you will kind of learn the fundamentals, um, enough that you kind of understand kind of the key concepts, um, uh, involved in kind of reaching, you know, some solution towards all of these different challenges, um, but. Moder web application development is extremely uh complex uh and it's partly to do with that complex system of multiple services interacting as well as not having the control over the environment itself. The only thing that you know is that there are different kinds of browsers really, um, but you don't know anything about the users' kind of environment. Um, and so you really need to, to be keeping in mind all of these things, of course, in a normal like software engineering project with like many developers, these different aspects of your program would be handled by different specialists in in one way or another. Um, any questions about uh any of these things that I covered? Nope. OK. Um, So Let's put it, let's kind of flip this a little bit and look at it from the perspective of sort of the components of the system. So, um, we're gonna use a very simple reference model in this class as a way of. Sort of knowing where we're sitting and what parts of the web application we're working on at any given point. Um, so this reference model just has 4 pieces, right? So over here on the left, um, is the user. Your left is the user, um, and so that's kind of your, your end user who is sitting in front of their computer looking at the browser. So they will, uh, interact with the machine. And for that, um, we're gonna call it the machine or, um, and sometimes we're going to think of that as the HTTP client, um, so. I'm gonna talk about HTTP in a moment, but this is the client that is kind of consuming, uh, it's basically making requests to some other computer and getting the responses and the way that that those responses are interpreted, uh, is they do they have some data that's in HTML format. They have some data that's in CSS format they have some other data that's in maybe, uh, JavaScript, uh, and. There, the, the browser, this box you can think of is inside the browser, the browser also itself has a bunch of built in, uh. Application programming interfaces. These are just libraries essentially to do different kinds of uh execute different kinds of um. Uh, different types of programs and, and, and, and, uh, any kind of thing that you might action you might think is valid within within the browser. So for example, making a network request or manipulating the uh the what's showing on the screen and so on. So, so these things sit here. And the user simply interacts with them. They don't, it doesn't kind of uh do anything obviously directly with the server, but then the client itself is gonna have a bunch of uh uh back and forth uh connections to another uh machine. So that machine is the HTTP server. And so that server, uh, perhaps runs different um technologies uh in the context of our course. We're gonna be focusing on, um, a, a particular JavaScript engine called No GS. It's using some APIs, uh, libraries like called Express. These are just samples. There's actually many different ways you could do this. You could write your server, your web server could, could be in written in Python, be written in PHP, it could be written in all kinds of different things. It exposes an API, but this is an API that you build as the server. Essentially, when you're writing your server. You're thinking I might be getting all kinds of different requests from a computer. What kinds of requests am I going to accept? What's the format those requests are supposed to be in? What kinds of, what should the data look like, you know, and then how should I respond to those requests? That's something that you, you build, uh, here, um, so the browser. And the, the the client, you know, which is, which is the, the, the system, the, the application running in the, in the browser is interacting with a server. Now behind the server. Can also be a relational database, um, so. Uh, we're going to have a relational database that's sort of like the stores the state of the application, um, sort of. Basically, the, the server's perspective on the state of the state of the application. So The server can make SQL queries to the database, get results, uh, and so normally the way it would happen is the, the user say clicks a button. That button executes some JavaScript, which makes an HTTP request, uh, to the server. The server, uh, then says, oh, I need a piece of information from the database, so it makes an SQL query. It gets the result. It compiles together the response. The response is sent back to the browser and the browser renders the information in however whatever way you've defined in in your application. So that whole that that whole cycle is sort of, you know, you have to connect all of those pieces and you're gonna connect all those pieces uh through your assignments, uh, in the semester. Now there's more about this, about like kind of the kind of data being sent back and forth and so on and we'll we'll we'll kind of get into each of these things um. As we go through the course, uh, but the key point is that in, in the first term we're really focusing on this part right here, uh, and the interacting with, with the, the database, um, so you're building an API, um, that's going to take some, you'll be able to take different kinds of requests in term two, you shift over and you build the, the application that sits in front of that. So the application that you're gonna be building is a game review site. So, um, it's going, you're going to have basically a bunch of users that can. Post new games, uh, you can have users that can review those games, they can rate them and so on and so forth, and sort of all the data about the ratings and the games that are uploaded are going to be stored in the database, uh, in the back end, and then the front end is going to be the application is basically the game, the game reviewing application and it's all going to work together once it's all done. Um, So any questions about that? So in reality. This is way oversimplified for anything that you will see in the real world. In the real world, you would have. You know, maybe multiple servers, you may want to balance the load because you'll have thousands of users trying to connect at any one time. And so if they all connected the same server, it would cause everything to crash. So in reality, you might, you might have some robustness built into there. Same with the database, you'll probably shard your database across multiple, uh, you know, uh, database servers and so on and so forth. Um, so in reality this side of the picture, uh, you know, the right side is much more complex in any kind of real world application with a large user base, but you know, for a small application and the purposes of the course this is simple enough, um, and in fact you can build this entire thing I mean the. HTTP client, the HTTP server, and the database machine can all be the same machine, right? So that's what's called running it on local host. You essentially will you could install a database server you could run your HTTP server, uh, and then open up your application in the browser and have it all connected all running on your own computer. In practice we're going to, um. We're, you know, we're gonna have a MySQL database that you can use, um, you know, that's set up by the department so you can, you know, you're gonna be connecting attaching to that, uh, from your, your server, but most of your development you probably would be doing just with these two on the same machine, um, so you're making the request but you're, you're just making the request to you to your own machine, um. All right, um, We only have a couple of minutes left. I just wanna real quickly, um, give you a little bit of, uh, admin stuff before we head out of here. So, um. Like you already met me. I'm the lecturer course coordinator. Um, I'm in Erskine, Jack Erskine 314. Um, did you ever, did you take any courses with Maths? I just took over his office, so yeah, he, I'm in, I'm in his old office, um, so Kush and Locky are the two tutors, um, so they kind of handle we have 4 lab sessions we handle those lab sessions, um, you know, they each take 2 of them, but sometimes they might double up a bit. Um, they both took this. last year, so it's all fresh in their minds and uh they're there to help you and support you as you go through things so ask them questions if you have any, um, they're great. I'm sure they'd be happy to help you but also feel free, feel free to contact me as well. You can send me an email if you need um that that's fine, um. Just real quick, um, you know, you can look through this, but, you know, this gives you an overview. The, the key thing, the thing that I guess keep in mind is that this was an odd odd semester because. This is one of those ones where we have 7 weeks in in term 1 and 5 and term 2, but the first assignment, which I will, I'll go into a lot more detail on, uh, starting next week, first assignment is due at the end of week 6, so just keep that in mind. All right, I'll just end it there and thanks everybody. I'll see you tomorrow.

SPEAKER 0
No. Yeah I. Yeah. for. Hey, out of curiosity, how many assignments will there be? So there's 2 assignments. I, I was planning on today there's 2 assignments, and the final exam which show the, the cover. Thanks. Oh. Yeah. you wanna do. Well Hello. Oh no awkward, but um. OK, I mean they record. Yes, all the lectures are recorded, so you're fine if

SPEAKER 1
you want to do that, but I mean if you

SPEAKER 0
have, uh, yeah, yeah, yeah, totally, everything is recorded, but

SPEAKER 1
you know if at any time, yeah, if you have questions about what it's covered everything, you know, just feel free to follow up.

SPEAKER 0
That's fine. Should be good, yeah, hi. It's crazy how much is 60, I might need to click the button, but yeah, it should, it should pop

SPEAKER 1
up there. Oh, you mean like in real time or in Oh just like recordings, yeah, yeah, I'm pretty sure it should just pop up there, um, but if it's, if you don't see it, um, just if it's, if you still don't see it like by tomorrow or whatever, just send me an email and let me know and I'll double check it, yeah, OK, yeah.

SPEAKER 0
Yeah Yeah. Uh Thank Yeah. I. I. And this is. OK. That. So OK I feel like. Because. I. I don't. I I. Right. Yeah. I.


SPEAKER 0
Just. All right, uh, welcome everybody.

SPEAKER 1
uh, thanks for coming. Let's go ahead and get started. Um, so, uh, so yeah, um, I'm just gonna pick up where I left off, but before I go into that, any questions about anything so far? So I did have a question about somebody I think maybe already in the in the first, uh, lab session this morning. um, in the third pre-lab there is a bit about setting the and get, uh, repo. I'll get those set up, um, but just a little bit later, uh, in the week. I wait for the, for all of the, um, you know, registrations to settle a little bit before running the script to create all of your repositories that you're gonna be using for the first assignment, but. Um, Apart from that, I didn't hear anything else, uh, there were any issues. All right, um, cool, so, uh, so yeah, so this is the overview of the topics that we're going to cover, um, I think I'll just briefly, you know, just go over them so you can have an idea of what to expect, um, so the beginning of the first term is there's some basic concepts of things like HTTP and around JavaScript and how it works and in particular with JavaScript, how, uh, we do asynchronous programming and how it works within the JavaScript engine. So then we switch over to TypeScript. um, TypeScript is actually JavaScript. um, it's just kind of uh something built on top of JavaScript, um, that is, uh, makes it a more modern, uh, programming language and whenever we use TypeScript, in fact, it's always being compiled down into or trans piled I should say down to JavaScript, um. So we'll also talk about data persistence, which is a very important part of, uh, anything to do with building, uh, web applications. Uh, then res 45 and 6 kind of touch on some other, um, other topics as well related to sort of the, the back end of building APIs or building services on the web for others to consider. Uh, so then week 7 is, um, normally that would be in the 2nd term, but because of the way the semester is set up, it's gonna be the last week of the 1st term. Um, that's when we kind of switch over to the front end, uh, and we cover in general, uh, this concept of building single page applications, um, then a week say 9 once we're back from the April break, we'll be, uh, talking about React, um, which is a JavaScript framework that we're gonna be using in this course to develop our, our front end application, um, and then weeks 1011, and 12 are some other, uh, topics, um, that kind of round out the course. Um, So Sorry. seem to Excuse me, the wrong window open. All right, cool. All right, in terms of assessment, um. There's two main assignments. Um, assignment one is due at the end of week 6. Assignment 2 is due sort of just before week 12. Uh, assignment 1 is they're, they're kind of go together assignment one, you will be developing, uh, an API, and, uh, application programming interface for, uh, a particular type of, of game review site. Um, and assignment 2 will be you're developing the front end web application that utilizes, uh, the API. So those are the two assignments and then there's the final exam, uh, which is, uh, at the end, uh, and the final exam is sort of comprehensive over the entire semester. I used to have assignment ones to be equal waiting, but um, I've gotten the feedback that you know, well, assignment 2 is the kind of one that I think people kind of get really stuck into and spending lots of time on because it's a little bit more open ended assignment one, although there's a fair bit to do. Uh, you know, the requirements are really kind of laid out very, very, very specifically. There's a little less kind of, um, I guess creativity in terms of how you'd go about implementing it. And so as a result, assignment too, people, some people get really stuck into it and spend more time and so I've, I've adjusted the waiting a little bit to make assignment 2 worth more, um. So all the assignment resources will be on there. I haven't yet put them up yet. I'll put them up by the end of the week, um, but that will describe, you know, everything about the assignments, um. And what you will have in that is an API specification. So this is the specification so for your first assignment this you're gonna have a specification that defines exactly what you're supposed to build, uh, and you will build it to that specification if you build it to that specification, uh. That you can be guaranteed to get, um, good marks along with that is what we call skeleton projects so this will just be a repository that we put up on Ege get that um it will just be generated for all of you. It's sort of like the basic skeleton to start with, um, so that you don't, you know, everybody's starting with the same, same basic thing. So in terms of the infrastructure, um, there will be a HI project. Like I said, um, there's also a MySQL database, um, which you will be, you know, set up with, um, basically an instance you, you'll have a, a script that will allow you to upload or generate the, the database, uh, from the schema that that will be provided to you. And then some tests, sorry, that should say Bruno test. We switched from Postman to Bruno. They're just two, kinds of API testing, uh, tools, um. We switched from Postman last year because they decided to take what was originally just an open free product and start to monetize it in a way that made it not very useful anymore. So we switched over to Bruno. I'll update the slides. All right. So what is assignment one? I just want to lay this out for you now, um, even though you will, you know, as we go through the, through the labs, you'll start to get build up to all the pieces like the labs 1 and 2 are really intended to kind of, you know, build up the scaffolding so that by the time you get to the point of doing the assignment, you'll, you'll really, uh, be able to, to do this. But the bottom line is you're building what we call it HTTP server, so it's like a little web server. Um, uh, and, uh, for a particular type of application and so. And these are some of the different features, um, and things that it's going to have to uh take into account and it looks like a lot of things, um, and it actually is, but like I said, it's a very kind of. The specification that we give you and we'll kind of take you through that, uh, through the labs and through the lectures the specification should explain sort of how you go about each of these things, um, but so you know, and all of these topics will be discussing starting from today in the lecture, so it will make sense if you're just looking at that and thinking what does all this mean, um, so. HTTP is the protocol for making requests to your to a server, um, and so you're going to be writing a server that can take those requests, uh, and respond to them, uh, with an answer. I it's going to need to, uh, understand what kind of request or like what form of message is coming in from the, from the client, uh, based on a URL. You're going to have to understand something about the headers and the body of of these messages, um, that's all in here and you're gonna have to know something about the types of methods uh that those um messages have. I'll explain all of this actually, you know, right next in the lecture, um. But it also so it's got that side of it, but it's also going to have to deal with authentication authorization I mentioned you know we this is an application that is going to have users those users are going to need to be able to sign in the password and so it's going to have to do that in the in in a in a correct way, um, in a secure way, uh, for, for your application. Um, I, I might just point out here, and I might highlight it again, you know, later on, but one thing that we are not doing here. Is actually sending the messages over from between the client and the server in any secure way. We're simply using HTTP any modern application on the web we'll use HTTPS which you will sometimes see like when you type it in in the URL you'll see the S. That S means that there's an additional layer of encryption on top of that. So we kind of ignore that for the time being just because for in order for that to work you need to set up a certificate for your server and all this other sort of stuff so it's a little bit outside of the scope of what we're doing, uh, but nevertheless, yes, you're, you're sending the, the messages themselves being sent between the client and the server are going to be open and if somebody were observing the, the messages over the network, they could actually see them in plain text, but. That aside, uh, you know, in other senses, we're going to have like an authorization, and authentication system. It's going to have to deal with the synchronous requests and we'll talk about it's gonna have to connect to the database to make those requests. And it's going to finally have to conform entirely to the specification that we give you. So all of these pieces together, um, you know, looks like a lot. um I mentioned the skeleton project. Well, that actually sets up all the basic stuff for like helping you like know how to do things like the database connectivity. From your server and has kind of the framework for handling all those requests and responses so it's, it's a bit less than you know doing all of this from scratch um but it but it does add up to a lot. So, uh, another thing I might say is that, you know, don't wait until the very last minute to do this because there're within that specification there's a lot of different kinds of requests and responses that your server has to be able to do. And if you just wait until the last week, um, then you're probably gonna run out of time. Um, Oh, and that reminds me one thing that I didn't highlight here. There's no extension apart from, you know, special considerations from illness that sort of thing. There are extensions either on the deadlines, um, the end of the week 6 and the end of essentially week 11, um, for 1 and 2, and the reason for this is that. Assignment one, when that's done, we need to release the reference implementation of that so that people can have like a proper working version of, you know what you're building assignment one to be building off of for assignment two. We don't expect you like to build off of whatever you necessarily built because you know not everybody's going to have a 100%, you know, coverage necessarily. So that's the first reason segment one. And the second one is for segment two, we're going to be doing in lab testing. So we just need to make, you know, and that's actually during the lab sessions in week 12, uh. So just bear that in mind. Don't expect it like you're gonna hit that and be able to get an extension, um, of course, barring, you know, the circumstances outside of your control like the illness. So the assignment 2, you've done, so assignment 1 will be term 1. Assignment 2 is like, OK, you've built this kind of server that can take requests to get information, and in our case, it's going to be a You know, a game review site and everything like that. So it's gonna allow you to have requests to store new games, um, you will allow you to make reviews, uh, to rate them, and so on and so forth. Especially defined kind of requests to the server, that server will store things in the database, so on. But then side 2 is you are just building the front end application for that, um, you know, so this is the application that you as the user in the browser are going to be interacting with, um, and so this is where we get into, uh, technologies like HTML, CSS, the JavaScript application on, on the front end, um. And so for this um we have a specification for assignment one for assignment two we're going to have, um, basically user stories so we're gonna have a list of user stories and your application is going to satisfy those user stories. So you know, for example, I am a, you know, um. I'm a game developer and I wanna, you know, store my game on this and da da da da da so we'll have those kind of user stories and then as long as you implement those user stories, that's essentially how we're gonna be testing, we'll be testing against kind of coverage of the various user stories, um. That also requires the authentication or authorization sort of on the front end side, the asynchronous requests, and making the API calls restful API calls. We'll we'll, we'll dig more into rest um in week 4, those kind of calls have to be made from the front end to the server. All right. So that's just a quick overview of the assignments. We'll get into more detail as as we go through. So in terms of the labs this week we have the 3 pre-labs, um, and I will get for the 3rd pre-lab there is the, you know, the, um, the bit about your and get repo I think, well, um, that will, that will, uh, uh, all be up and available to you, um, by the end of end of the week, um. But then weeks 23 and 4 are the labs. Lab 2, I mean, it says lab 2 for week 3 and 4, but lab 2 is actually quite long, um, so that's why it's 2 weeks. Um, so we, we anticipate it might take you 2 weeks to kind of. Uh, get through, um, your best bet is to really engage with the lab tutors at this stage and going to the labs if you've got questions rather than waiting for the assignments because what happens is in week 5 and 6 it's just assignment support for the, you know, you're developing your assignments and. You're coming up with issues and you want to talk to the tutor. Uh, the problem is that like by week 6 the labs get very busy, um, and you know because they're busy, the tutors only have limited amount of time for any one person, um, so you know if you want to get, you know, extended time, you know, and help, then you probably want to try to start, you know, as early as you can, um, then, uh, week 7 we and on we go on to the next so one thing I just highlight now in case you're planning ahead. Um, because we're doing testing. Um, for assignment two, we're gonna do kind of, uh, a thing where everybody's everybody's a final product is gonna be tested by 3 or 4 other people in the class, right, randomly selected, and they're just gonna kind of go through the user stories, of course there's a there's a second kind of, you know. Uh, check by, you know, tutors and myself on top of that, but, but that's we're gonna get kind of a general kind of testing, uh, uh, thing in, in the, in the last week. And so the attendance is mandatory for that and the way, the way we make it mandatory is it's just, uh, um, it'll be like a small percent of the of the mark that you that you actually participate as a tester as well now if um. If for whatever reason you can't make it, um, I mean, obviously it's the same sort of thing as if you are like, you know, sick while you're sick, that's fine, but if not, I mean, you could, we could also arrange like if you're if you're in your particular lab session, you would not be available. You need to go to a different lab session. It's OK, we just need to make sure it's relatively well balanced because obviously we have to have enough space, um, in the labs when we do the testing. All right, any questions about any of this before I continue? OK. So now I'm gonna kinda finally get into some of the actual content of the course. So first thing I wanna talk about is uh the HTTP protocol. So this is what we, um, I've I've I've already mentioned it many, many times, um, and so this is, uh, the protocol that essentially underpins the World Wide Web, um, and it's the thing that's going to be. You it it's basically the protocol that describes the messages that are sent between a client and a server. So if you remember the reference, uh, implementation, you know, the client is going to make some requests to a server, um, and then the server is going to send back, uh, responses, uh, based on that. So, the responses are, I mean, the requests and the responses are encoded using the HTTP. Uh, but it's also there's a, there's a certain kind of development principles called REST that will go into more detail in in week 4 that sort of describe how you are best supposed to use HTTP as a protocol when doing application development. Um, so they're a little bit, so HDPA and REST are kind of tied together, but they're not exactly the same thing. So, so REST is like a set of principles, um, that is sort of designed on top of HTTP, but it's also those principles can be applied to other kinds of web services that don't actually use HTTP as a protocol, um, but. Today I'm just gonna talk about HTTP itself. um, we'll get into rest a little bit later on. Um, but the API that you're developing, so your first assignment is gonna be this, you know, you're building this, this API. And that's gonna be the thing that takes in an HTTP request. And you know, based on, you know, the contents of that formulates a response and sends it back, um, so. Uh, it's not, I guess not a requirement that you have taken, you know, a networking course as part of, part of this, uh, class, uh, for those of you who have, um, I guess mainly like 264, um, you might have come across the protocol layers, um. So there's several different layers, uh, to, you know, what what is now the modern internet, um, and this is the layer cake model that we see, um, used again and again, um, and so if you take a networking class, probably, you know, you might be looking at these lower layers, um, you know, somewhat you might look at the physical layer which is like the actual medium over which the bits are being sent, you know, the actual wires and so on and so forth. Um, but, um, also, primarily you're probably looking at the, um, transport layer. Uh, so the transport layer is the is the layer at which, uh, things like, um, the TCP and UDP, which are these kind of protocols for, you know, sending messages across the internet, are, are defined so. We're not looking at anything at that level in this course, um, we're all the way up here at the application layer. Um, everything in this course is up there at layer 7, and so HTTP as a protocol is defined way up there at at that level, um, so all of these other things sort of how, how the actual data gets transmitted through the network, um, how it gets, you know, to, you know, a. Computer how that's how how the actual you know communication between the machines is established all of that is sort of at the networking level um but once you're up into, you know, web computing you're up at the application layer and that's because browsers are defined essentially only to allow um messages using uh protocols like HTTP which are defined up at this application layer. Um, so that's just to contextualize for you a little bit, you know, where this information sits in, you know, in contrast to maybe the kind of stuff you would have learned in a, in a networking course. So what is HTTP? Um, so, They're just there's, it's a protocol that defines um so it's the hypertext transfer protocol so it's basically um how data is exchanged between a server and the client. So this is the thing that was really, um, the main kind of development of the initial what became the World Wide Web was the development of this protocol, uh, by Tim Berners. and others to define how messages get sent between a server and a client, um, and so there's there's just, it's really rather simple. There's two types of messages there's requests, requests from client, uh, trigger action on the server and then once the server gets that request, uh, it sends a response, which is the answer from the server back. And it's all text, um, I mean it's more or less Asky. I mean it has a, there's a it's a little bit outside of that a little bit more than asky, but for all intents and purposes it's Asky so we're just talking about plain text messages. It's not binary data or anything like that. Um, so, this is early times. Now, there are more advanced versions of HTTP, uh, like HTTP 2. Uh, which, uh, has some binary formats and so on. But for, you know, in this class, we're just dealing with these like, um, textual, uh, messages. So I'll talk in a moment about what those messages look like, um, but the way that you, um, like, like messages have to be sent somewhere, right? Like there needs to be some addressing scheme, some mechanism to know where you're sending your message to and that's actually I mean you've seen this all the time in the browser you put in your URL you type it in and the URL uh is a. Um, essentially a way to address, you know, some place where you want to be sending messages, uh, to. Uh, there's a little bit of nuance in terms of the terminology around this, so. The larger category are of of these kind of names are uniform resource identifiers uh so these are just, um, any strings of characters that identify a resource and when we say a resource that could be like a file, um, you know, something like that. Um, a URL which stands for uniform resource locator, that's probably the term you've learned more often, um, specifies, I mean, it's not just any string of characters, so like in, in a URI like data. HTM would be a URI, um. The URL has to specify the means of acting on or obtaining the representation, so that's in other words, it has to describe sort of the protocol that is used, uh, to access the information at that location. So if you see here in the URL it's um right here. It has a protocol HTTPS and then it has some additional information. So that's telling it so that's encoding that there's actually like a mechanism, uh, there as well as a location. Um, in this example it's FTP, which is the file transfer protocol. It's a different protocol than HTTP, um, so, uh, URNs are a bit derecating, you might come across how it's just a uniform resource name. Uh, and that's sort of like a location, but it might not have the protocol, but I mean, that's just for completion sake to include that. So when you build your API you are going to be building an HTTP server. So what this means is it's going to be taking HTTP requests in and it's going to need to know what to do with that based on the. Uh, actual, uh, uh, URL that is being sent, that's gonna have the information that tells your API what kind of action it should be taking, um. So, in other words, it should look something like this. Um, so, Uh, you will, uh, have all of these different components potentially that your er your server is going to get something that looks like a URL like this along with the, with data, um, and. You know, based on the, the, the structure of this, you're going to be taking different actions. So let me just break that down. So the first thing is the protocol. So we're just doing HTTP in this case, so that's just uh, that's just kind of built into it, um. The second bit of it is the domain name. Um, the domain name is basically maps to an IP address and a domain name server, but for your development, that's probably just gonna be a local host, so because you're probably gonna be running your server on the same server as you're developing your client, um, and so, you know, you'll, you'll, you'll start up your server and it'll be running there and it will, you know, uh, do its thing. After the, sorry, after the domain name, which is that bit there, the next bit after the colon right there is the port. So we don't normally specify a port um on when we go into a web browser. And that's because the default port for HTTP is port 80, so if you don't include it and it knows the protocol is HTTP, it's gonna default to port. This is the port that your server is running on, um, you know, accepting requests, uh, that is open to the Internet. Um, if you know, if you ran your HTTP server on a different port than 80, then you would need to specify like the colon and the port number. Um, HTTPS, um, normally default is port, uh, 443, um. So, uh. Yeah, that's the OK, that's. Sorry. Uh, OK, so these are port numbers. HTTP is port 80, HTTPS is port 443. Um, So this is a different port than all the other services that may be available on your server. So if you have, for example, MySQL server that's sitting on the same server as your web server you've created, then. Uh, it will, um, be listening on a, a different one, so like my SQL's default is, uh, 3306, but all of these things are configurable. You can set ports, um, when you start up your server to be running on different ports. These are just sort of the the defaults, um, for various services, um. The next thing is the, is the path. Um, so. Historically, the path was at the actual, I mean you could just think of it as like a a as going into a directory structure say in a Unix file system and you're, you know, it's like slash home be some file or whatever right? Like I, I, that's your path, uh, you know, in a directory structure but. In almost all kind of modern web applications that's now an abstraction you know what happens is instead of sort of taking, you know, whatever path is sent in from the user, it's not you're not saying I literally want to go to that directory and that on the on your server and grab a file uh what that's now used is some kind of abstraction. Uh, that leads to, um, you know, some kind of action that you wanna take when we talk about it building an API, normally the path is sort of, you know, a series of different kinds of actions that you wanna be able to take, uh, so in this case. You know, this is a path to a particular HTML text file on the, on the file system potentially, but that's not really how you're probably not going to have like to a file name, you're probably just gonna have a path that that ends. Uh, It's not, yeah, so it's not the same thing, right? um, and even, even if you have a path to an HTML file like we have there in reality that might not be the the path structure that exists on your server, um, it could be, you know, that you are directing like your home, your root, um, folder for your for where you serve up your HTML files might be different than the actual root directory on your server, um. Uh, so the API endpoint, which is what you're gonna be building, it uses the structure, um, but it does something different, so it, it's, it's gonna be like usually you could think of it as like parameter information, um, something like, you know, say for example I want to, uh, request a certain ID value, uh, then I might, um. You know, have the number ID be part of the path. We'll, we'll, we'll set examples to all of this as well. Um, the other thing it might have in the path, um, is that we'll, we'll talk about building your API and the idea that you, if you're building sort of a public service on the web for different users to use you, you need to build it in a way that's robust that if for example you change your service and you want it to become like, um, have a new version. And it has breaking changes then it should also still support all those services out on the web you might not even know about that that use the older version and so because of that you you wanna kind of create your path potentially to have all that versioning information of the of the actual API built into it so that you know people that are using the older version of your API can still use it um. So here's an example of what an API endpoint path, uh, looks like. Uh, it's a little bit different. Um, So The first thing has the versioning, so in this case. API V1, you know, version one of my, my API and we're saying that there's gonna be an endpoint. Uh, students, so you can imagine this is some, say, say you had like a a. API that was sets uh information stored in the back end about various students and the classes they're taking and you want to make a query about that and understand what's in the database. Well, you, you make a query about, you know, like a student's, uh, uh, end point and then you might include, uh, a variable itself in the path and sort of the way we. You know, tend to refer to things like variables in the specification is we'll say like a colon ID so that that means is that that colon ID is something that's it's a variable essentially it could be anything it could be maybe a number or a string, uh, that you would replace with that so that if you put that URL in there that said APIB1 students 7 right, then it's going to get. Make a request for information about student #7 in our database or something like that. Um So how are they handled? I mean how do you use this handled by the server? Well, that's totally up to you as the server developer. I mean it's it's completely open ended. You can also pass uh query parameters, um, which are additional things so these are kind of the, it's just um. In a in a URL anything after the question mark you can actually pass in things in like as key value pairs like that um so you can write a server that either takes information sort of within the path to kind of give you a parameters or you could define your specification to send in various parameters based on kind of these uh key values that are are sent um. That's after the question mark. Um, But it it all depends on how you define it, so it might be redundant, yes. I wouldn't say so the question for the recording is what's the most common and there isn't really a most common. The most important thing is that when you develop your API specification you make it very clear about what is done, but even the, the API versioning, um, as we'll talk about it, like it's done in completely different ways. Some people do it using, you know, query parameters. Some people do it using the path, you know, it's, there's, it's, there's not really rules about it. Um, so there's all of this, however, there's also more information. So when you make your request, obviously you're making your request to the server and you have. You have the URL and you can encode lots of data and information within that URL. They can tell you about like what kinds of things you want to to get what kind of request you wanna make. It can tell you what a whole bunch of parameters are when you want to do that, but um there's also within the request the thing called the body, and from the body you can basically send any data you want, right? And so the. So it could be that, you know, all of the information within the body of your request is actually what your, your servant cares about. Um, So yeah, these are the query parameters. If you want multiple query parameters, then you, you make it, use an ampersand between them. Like this, um. If you need to do like send characters like question marks and ampersans within there, there's a special encoding, uh, that you could do for that. Sort of like escape character but not exactly, um. So, you could accept parameter information based on the, like I was saying, you know, the query parameters, the path, and the body of the request. Um, for example, JSON data, which we'll, we'll talk about, um, Or it could be a combination of all of these. So, it's all of these things are, are totally uh legit. Um, so what goes into those, well, that's up to you as the, as the, um, developer and the specifier of your. Of your um of your API. Right, just checking the time. There's one last little thing called anchors, um, so this was anchors are things after uh a hash character you can also use that if you want, um, that's additional information what anchors were designed to do, um, in the, in the initial like creation of of the specification was the idea that you might have a. You want to kind of go down to a particular point within a page. So if you go to an HTML page and then you put an anchor at, um, you know, some page down then if you, if you like, you know, go there, then it'll scroll down to a particular location, uh, but as an API developer, you can, you can just use it for whatever you want. Um, so the classic thing is that they're like bookmarks, um. Like a subsection. We're not gonna use anchors in our API requests, uh, in the, in the class, but you know, of course, you know, if you want to be creative, you know, feel free to, that's, that's totally fine, um. All right, so. So, when you build your server, it's going to essentially pull apart these URLs and, and handle the, the quests depending on, on what you've got. Uh, so, you have, uh, HTTP then that's actually coming in. So when you have an HTTP. And this is a bit of an overview and we'll go into more detail on each of these, so. The ACT is built on built out of headers and bodies. The header is like an initial information in the in that text, and then it has some body. There's different kinds of headers. There's general headers and there's things called entity headers. So general headers are kind of like predefined header types, uh, that are sort of just used all the time. Entity headers are going to sort of like your custom headers that matter for your for your application. It applies somehow to the body that you're, um, that you're sending. Uh, the headers for requests and responses look different, and we'll show that. And so, uh, something called cookies that will go into more detail, which is a way of storing session are implemented within the headers. So when you um when you get a response from the. Server, it's going to set a cookie, and then when the user makes a subsequent request, I mean, the client, they will add the cookie. We'll, we'll go into more detail on all of this sort of stuff. So, The bottom line is that headers help to sort of maintain the session as well as personalize the content and in some cases kind of track, uh, data and information. But we'll, we'll, we'll go into more of that in really week 4. But this is the, the bottom line of like what the actual text file looks like. So, it's just has sort of this format. So the way you can read this is that you make a request, um, It's going to have basically the header is the top part and then it has a basic an empty line and then the body so the SP means the space character, uh, CRLF just means uh carriage return, um, so you have an HTP method. With the space, the request, the URL that you are requesting space, the version of HTTP uh that we're using. And then it has 0 or more. This is just a regular expression for you, folks, um, the 0 or more additional headers. Um, there's a blank line. The blank line is the indicator that you've now transitioned from the header to the body, um, and then in the body it can be anything. There's no no required structure. It's just whatever data you want to send. So here's an example of what we call a get request. Um, so you have the HTTP method, get. It has wants to go to a particular URL called blah. HTML. It's sending a HTTP. It's saying the version is a version 1.1. Uh, here's an additional, uh, header, uh, that we want to send. Um, a post message, it's another kind of HTP method. Uh, we'll go into more detail about this, especially as we talk about rest, but this is just another example, um, where it's instead of wanting an HTML file, it's, it's requesting a PHP file, uh, but it also then below it has a body. So in this case maybe you've entered in a form. Uh, and, and in that form, you've had, there's certain field data that you want to send, so you kind of, you put, you encode that somehow inside the body of, of the post as some text. Uh, so those, these are the HTTP verbs that you can use, um, you know, there's, there are, there's more than what's just listed here, but these are the main ones, uh, get put post, delete and head, um, we'll talk more about these when we get to, to rest, uh, later on, but gets are generally speaking kind of read only requests, uh, put post and delete our, our both are all requests that can, um, write information as well as read. He is a special one that just kind of gets initial information, basically just pulls back the header of a of a request without, without actually getting requesting the whole body. Um. So that's a HTP request. HTTP responses are, so the, the client constructs their text request, puts together, it gets sent to, you know, via the browser sends the request, uh, to the server. The server reads that response, does some things, and constructs a new text file called an HTTP response. And they have this uh structure so it's it's something it's something similar but but you know has a few differences. I mean it also I mean instead of there's no verb associated with it, it just sends the HTTP version space a status code so there's a number of different status codes that you can send as a response along with a textual reason for your status code, um, and then additional headers if you need them. Uh, with a, uh, carriage returned and followed by the response. So below here is an example of an HTTP response, um, from like, uh, basically this looks like a response for somebody requesting a web page. So if you, this is actually what your browser gets if you were to type in, you know, a URL to something. uh HTML or something like that. It what the browser receives is a text file that starts with the HTTP version, HTTP 1.1, a status code 200, which I'll talk about what the two codes mean, but the reason for that status code is OK. So basically things went OK. Um, and then the server has decided to add a whole bunch of additional information that may or may not be useful, uh, to the browser. It has a, a date header, a server header, so Apache is is the server that is serving the information, um, some additional information about how many bits of information to you will expect to see in the body, um. Should it close the connection, you know, or that it's closed the connection, um, it tells it has a thing called a mime type which tells it that that this is coming in as an HTML format that's what we would expect to see in the body, uh, it's something about the character set, it's UTFA. So it has all this information. The browser is able to interpret all of this information and then it takes the actual HTML that's sent back and then renders your web page from that. Well, So that's what it looks like. So in terms of response codes, there's general categories of response codes. Um, there's 100 level. These are very rare, these are like informational ones, um, you almost never see them. The ones that you see the most often and in the context of class are the 200, 400, and 500 level. So 200 level are different kinds of success codes, um. If you're just making a get request to get some information, um, usually it's gonna be a 200 OK. Say you're making a request though to write some new piece of information, uh, say you might respond instead with a 201 created code, um, and so on and so forth. There's, there's a whole, there's specifications about all these different things like what, what the different options are. There's, there's heaps of them. Uh, but the key thing is that when you build your API in our specification we're gonna tell you exactly what response code you should be sending back and you need to make sure that you're sending back the right number, um, so there's success codes, redirections we're not really gonna touch, but that's just sort of like if the server's redirecting you to another server. Uh, 400 errors are errors, um, that the client has made. So what this means is you've, you've made a request but you sent malform data somehow, for example, or you've forgotten some required field for those kinds of things you will get some kind of 400 error, and there are different categories of them. So there's like bad request is 400, meaning it's not the request is not formed right. But there's one for unauthorized. So for example, you're trying to make a request, but you have to also include some authorization information, you would send that 404 you've probably seen lots of times, um, because that's the standard one when not, you know, it's not found. 500 level errors means something went wrong on the server. So the only time really that we can expect 500 level errors probably. Would be if you throw some exception in your code. So for example, you make a request to the database and the database connection is broken, that's a server error. The the client didn't make any problem in their request, but something broke on the server, um, and so that's usually just a, you know, generic for those we don't specify that a particular code, you would just send back a 500, any 500 level code that's appropriate, you know, when an exception is thrown. We'll talk a bit a bit more that time. All right. So that's HTTP in a nutshell, um, it's really not that complicated, um, it's just being familiar with sort of the structure of how, how they're set up. And when you make your request, you're going to be able uh to do that. Um, so we are only a couple more minutes left, uh, in the lecture. Maybe before I go on to anything else, I want any questions about what I covered on, on HTTP. Yeah. Yeah. Yeah, so the question is, um, is it I talked about API end points and is that something defined by the path? So yes, so an endpoint is effectively some type of method you think about it as like a method call, um, and so. The path is used to sort of tell the server which method you want to invoke on the server. Uh, so yes, that, that would be sort of what we would normally think of as an endpoint. Of course I mean that's sort of the how we're gonna talk about it here there's variations of course where you could even include that in the body of the request you maybe just have one thing and there's newer kind of um technologies like graphQL that kind of operate that way as well so yeah that's a great question. Any other questions? All right. So we only have a couple more minutes. So what I'm gonna do just in terms of just get you introduction into JavaScript real quickly and then we'll just quick, really just like one minute. So JavaScript is the language of the web. So if you not use JavaScript before, you're gonna get lots of experience using it, uh, but because it's the language of the web, it's also the language that people think about when building front end, you know, web applications. There are heaps and heaps of resources online to learn. I've just put one link here that it's free if you want to learn, you know, dig into syntax and all this other sort of stuff, and that's all fine. The key thing that I want to highlight right before we end here is that there's a distinction between JavaScript in the browser and JavaScript on the server, uh, and that they run in JavaScript engines that have different capabilities, um, and most of the things when people get introduced to JavaScript in sort of like learning online it's sort of JavaScript in the browser because. That's where most of the early examples come from, but we're gonna start with actually using JavaScript on the server side, um, and I'll dig a little bit more into that, uh, starting next week about what the differences are about that. All right. uh, thanks, everybody. I'll just end there.

SPEAKER 0
For Yeah. Yeah. OK. Thank you. It OK. And she means nasty. What do you mean?

SPEAKER 1
Oh, it just means that it can take some characters that are outside of those like the for the most part it is just so as I'm I'm not. Actually, I'm sure off the top of my head I just remember looking into it that there's a little bit of like there's there's some characters that in in school Ay don't, don't are actually, um, that are allowed in an HTTP request in terms of, um, you know, the what what's what's allowed, but, but yeah, I mean I would have to actually look and see exactly which ones they are. I'll, I'll, I'll look it up and I'll let you know if the next time.

SPEAKER 0
Ah. That Yeah Yeah. No, no, I OK. Yeah That's what they. Like President Oh, Yeah I. You should Yeah Yeah I You know. Yeah I know


SPEAKER 0
Yeah Yeah. Yeah. Mr. Yes.

SPEAKER 1
All right, hello, everyone. Welcome. Hello. So, um, I'm gonna go a little bit out of order on the slides today, uh, from what I have uploaded just because I didn't quite get as far as I intended on the week one slides, uh, so I'm gonna talk a little bit on my the week two slides. I'm gonna jump back to week one and back to week two, so, uh, I guess I'll start off with is there any questions, uh, either on the lecture material or on anything in the lab so far? Uh, oh, OK, uh, so, um, I wanna start off, uh, by, uh, talking a little bit about the first assignment, um, because, uh, you will be getting into that by about week 4 in, in the semester, uh, but it's good to know kind of where you're headed, um, and. Uh, you know, to have a sense of, you know, what, what the scope of, of the assignment is gonna be. So the first assignment is, um, due at the end of week 6, and the first two weeks of labs, like proper weeks of labs, not last week, but for this week and, and, uh, next week, uh, and the following week, those 3 weeks are gonna be really, um, sort of preparing you, scaffolding you to be able to do the first assignment. Um, so, first off, um. For many of you, although not all of you, I have, uh, created, uh, an Nate, uh, repository, uh, so the people who have not got Ngit repositories are people that who have never signed into Nate before. So if you, uh, go to, uh, it's just like n-it.cterbury. A.nz, um, you can find the link on the course materials. If you've never taken, so if you take a cent to a 1. I think you get, um, but if you haven't taken that, if you've never come across it, um, then, uh, you will need to go there and just log in with your username and password. Once you do that, then I can create the, the repository for you. uh, so I'll send through some, uh, emails if there's still some people that it doesn't seem like that's worked for it, but it's just a handful of you, I think, um. So The skeleton project is basically the starting point for everybody to begin working on the first assignment, um, so when you go in to start working on your first assignment, you will you'll clone down from your repository. You're going to install some node modules which they'll become clear, you know, once, once we get into it, uh, you're going to have to create a. EMV file, uh, in the directory of your projects. So the dot EMV file is, uh, something that doesn't get pushed up to your repository, uh, but it is something that has basically the information for how to log into your, uh, MySQL, uh, instance, um. So when you put that information in there, uh, and then say you push to, uh, push to repository, that information isn't going to get stored. Um, that's just good practice. Uh, you always have some kind of environment variables that have private keys of different kinds like API keys or whatnot. You put those in a file like. EMV, then you add that to the dot ignore, um. File and so when you push, you know, your code changes, it doesn't get pushed up there. Um, so, uh, the information is in there. So all of what you're gonna be building is you're gonna be building an API that has a specification, uh, that we define, uh, and there's a readme file in there. So the readme file is very important in the repo it kind of explains exactly, you know, step by step what to do and hopefully by the time you've gone through lab two by that point, um, that will start to be very clear you'll kind of understand, you know. What's happening at that point. Uh, so, What's the assignment in essence? So there's a briefing on learn. It doesn't really, it just basically shows the scope of the of the assignment and what you're doing, uh, but the most important thing is you're that you're gonna be using to understand like what it is you're actually going to be developing is that you're going to have to implement uh a specification. uh, I'll go through and show more detail in the specification at a later. Uh, lecture once we're kind of a little bit closer to when you're working on the assignment, um, but the API specification is designed, you know, to sort of basically describe all of the types of HTTP requests and we talked about HTTP last week, all of the HTTP requests that your API. Uh, can receive and it describes the format of the responses, uh, for those. So when we test your API we're going to be basically assessing your implementation against, uh, some automated tests, um, based on that specification. Um, so we cover sort of how much of that spec you've implemented, uh, and whether or not it's actually correct. So you know, once an end point that you're basically a particular type of request that your API is supposed to receive. Doesn't correctly uh respond and correctly responding can be either you know returning the correct answer or returning an error message depending on the context. So for example if the user sends invalid data um then we would expect a suitable error message to be returned, um, so. There are automated tests in the repository, uh, those automated tests, you know, available for you to work. We use a tool called Bruno, uh, which is a way to essentially, you know, make a bunch of, uh, like, you know, uh, network requests, uh, to a service, HTTP requests, and so those tests are in there. There's information in the read me file that explains how to do that. Um, and so you can use those tests as a way to kind of test for yourself how well you're doing, like how much of the API have I, you know, gotten, uh, implemented to this point, so that those tests cover a pretty broad range of the different elements of the specification. However, they don't like they're not like 100% coverage, um, so, uh, you know, there will be some tests that are based on what how the API spec is written. That aren't actually covered in your set of tests. I mean, you're free to, of course, implement your own tests if you want. You're looking at spec. You could look at how the tests are built. I'm not expecting that you would do that, but generally speaking, if you were to kind of go through all of those tests, um, and making sure and you're getting really good coverage on those tests and probably chances are, are good that you're gonna get a really good grade overall, um, but the bottom line is it's the, it's the. Uh, spec that you're implementing against, not the tests if that makes sense, um, and the second thing is that we preload a certain data, uh, in the test, so the data for certain, you know, um, elements within your database are gonna be preloaded for all of your tests. So don't hard code your application to assume certain things are gonna be in the database, uh, you know, particular rows and things like that. Uh, in order to pass the test, because if you do that, you're basically gonna fail because we use different data in your database if that makes sense. So we, we have had this in the past where sometimes people optimize for the tests that are given. Uh, and so instead of actually doing the action that's intended, so for example taking a request in, making a query to the database, getting some information and constructing the response, uh, it kind of just hard codes of response in there, uh, and then obviously that will work great for the tests as they're written, uh, but then as soon as we run our own tests everything fails, uh, so just don't do that. Um, But, uh, this will all, um, you know. This you can start to look actually if you if you have access to your repo, uh and and you you'll, you will see it, uh, there, um, in fact, maybe I'll just if I have Wi Fi, unfortunately I, I don't know about you guys but my Wi Fi has just been on and off like, yeah, it's, it's horrible. Um, anyways, I, I'm gonna give it a go and see if it works it works. Uh, it looks like it's working at the moment. That's to do two-factor authentication though. Uh So this requires both my phone and my laptop to be connected. OK, um. Alright, so. I just pull this over here. So this is what, uh, you should expect to see, uh, in your in. So it, it'll be under a group called SE 365-2025, and each of you has a repo that where the repo is your user I you know, like your basically your user ID, uh, that's the name of it, um. And so, um, you know, this is the read me. You can read through this in more detail, but, um, the read mes here, the, the Bruno tests are here, um, but, um. There's also like additional like basically the skeleton of the project is all here in in the source, uh, files and so on. Um, there's SQL queries for sampling the database and so on. So, as you go through, you'll see, um, it's basically ways to kind of, you know, uh, create, create a database and reset the databases as you go. Um. And um The API spec itself is, is this, uh, EML file. So I'll go in a later lecture, I'll go through, uh, um, I'll actually pull up the, the API specs so you can see, you know, what all the end points are and we'll have a little bit more detail on that. But I just want to wait a little bit on that until you've had a chance to move a bit through the labs, um, so you're a bit better primed for that, I guess. Um, so all of, you know, this is the starting point for your, for your application and you're just going to kind of, uh, build off of this. Any questions about this so far? I know it's not all the detail, but. OK. Yeah, so make sure, um, I, I would recommend sort of push regularly. You know, as you're developing, um, so you have a history, you know, don't wait until the very last minute to first make your first push, uh, to the repo. Um OK, let me just see. All right, so. Um, I'm gonna hold off on, on this until I, uh, go, I'm gonna go back and start to introduce, um. Uh, JavaScript, uh, no, so just bear with me for a second. I'm gonna move back to the slides. And we'll catch up with this part again. So When I was um finishing up, I, um, last time. I, I got, I covered HTTP and I started to talk about, uh, JavaScript a little bit, I think, uh, but I didn't get very far, um, so. Like I said last time JavaScript, um, there's heaps and heaps of material online to help you learn the language, so I'm gonna introduce JavaScript as the language and then after that we're gonna move to TypeScript. So TypeScript is the language that you're actually gonna be developing in for your um for your assignment. TypeScript is essentially. Just, uh, a refinement on JavaScript, uh, that makes it uh a typed language and so on so it it basically makes it a safer and more robust language to program in, but the bottom line is that everything compiles down to JavaScript, uh, or trans files to JavaScript and then runs, uh, in the browser as JavaScript. So Last week I was going into this and and I was really, I, I just briefly talked about how there's really two kind of types of JavaScript now. So there's JavaScript that runs in the browser and there's JavaScript that runs sort of in some other environments, right? JavaScript as a language is not um. Like, like most programming languages will have some kind of standard library, uh, with lots of, uh, different functions. So for example, maybe it has operating system calls, uh, you know, to read files to like, you know, engage with the network and so on and so forth. So JavaScript is a language is designed to run inside of a JavaScript engine and the and then it might have a series of other APIs that are provided by the external kind of context or environment that that engine is running in, uh, but when it was originally designed, it was designed as a language to run in the browser so the JavaScript engine that runs in the browser essentially is restricted from doing. Certain kinds of things, um, it runs in this in an environment for security reasons it's like sandboxed away from, you know, accessing all aspects of your operating system, which makes sense, right? So if you're trying to, if you open up a web page that has and that web page. Has some JavaScript and it starts to execute. The last thing you want is some arbitrary web page to have like access to your file system and just to do whatever you know other programs normally do, um, that would be a very bad idea. So when you run that in the browser, um, so there's gonna be an engine, it does, you know, different uh browsers will have different engines, so Chrome has the V8 engine. Firefox, uh, has another one and so on. Edge is actually Chrome. Now, Microsoft gave up on writing their own browser and just took it followed in Google's, uh, footsteps, uh, but. Then like when the when it's running, it's running in the sandbox environment uh for security reasons so JavaScript is primarily in the browser is is used to sort of create interactivity in the user interface and to handle different kinds of user events. So like for example, if you have a web page that has a button like a HTML button in it. And you want to trigger some action to happen, um, well, you're probably going to have, it's gonna probably execute some JavaScript, uh, in there, um, it has access in the browser to various web APIs, um, just I list a couple of them, fetch local storage and so on. We'll talk more about this in term two when we get to sort of more up front end development. Um, but it has limited, uh, resources. Um, it can make network requests because you can make network requests through the browser, but they're limited to HTTP requests, so you can't make arbitrary network requests like if you were, um, I don't know, making like other kinds of, uh, you know, uh, connections like, uh, you know, trying to open up a UDP, uh, connection with somewhere, something like that you can't do that. So it's very, it's very scoped in terms of what it can do. And it can't directly access files or databases except as I'm gonna cut databases, um, except as what is provided by these kind of web APIs and it's all sort of stored within the context of the kind of the browser data itself. On the server, so it used to be that all of the JavaScript, everything that was done was on the browser side and so usually when you go online and you're learning JavaScript, you're just doing browser stuff, um, initially, uh, but at some point, uh, no JS was developed, so people would buy web servers in all kinds of different languages so PHP was a very popular language, some things you're gonna see like Perl. Uh, scripts running as web servers you can write them in Python. You could do it in all kinds of different languages and so these are all different basically programs that just exist on a server, uh, you know, receiving HTTP requests and, and sending back responses. So at some point, no JS was developed, um, and it was like previously all of the work had been done on sort of like load balancing lots of requests by creating kind of parallel. Uh, processes, um, so you might, for example, have a Java server that maybe has multiple threads and it's all handling different requests in a multi-threaded way and so on and so forth. But then when New Jazz was developed, that was the first time that JavaScript was sort of became a language for the server side, and it has, um, when it runs on the server side, it's running it also in a JavaScript engine but it because it's not running it's no longer in the browser it can interact with file systems it can interact with databases and networks. It's basically a programming language like any other language, so now you can use JavaScript on both sides. You know, basically across the stack of your of your application, uh, but it has all the stuff that you would normally expect in any other programming language. It uses a particular kind of non-blocking input and output system for handling multiple requests. We'll talk a little bit more about that when we talk about asynchronous, um. Uh, connections, uh, it has, uh, but it has access to all kinds of server side modules like a file FS module for file system handling HTTP for server creation, um, and then once they're built on top of that we're using one called Express, uh, in our, in our, uh, project. You can also do things like execute background tasks without any interaction with the user, um, but if you want security on top of it, I mean, it's just like any other programming language, then you have to implement those yourselves like you're not like in the browser, the browser kind of implements the security or basically limits what you're capable of doing in JavaScript. And thereby, you know, enforcing certain security measures. If you're using JavaScript on the server, that none of that's there anymore, it's sort of up, up to you as as the developer to do with it. So We're gonna focus on the server side even though you know oftentimes the the front end JavaScript is is things that people get uh introduced to first but um I what I wanna do is just I, I, I wanna kinda introduce JavaScript as a language kind of. Given the context that probably most of you have learned a few different languages already, I mean this is a 3rd year computer science class, right? So you've, um, you certainly know Python, many of you know Java, uh, many of you might know languages like C and so on, and, and some of you might have already been introduced to JavaScript, but there's not like an expectation that you would have. And so in doing so it's not like kind of introducing a language from scratch where I kind of. You know, go through every different feature of the language. I mean, I figure you can kind of pick up a lot of the, the pieces in between as as you're learning this language. I mean there's unique syntax, the syntax is somewhat similar to sort of like a Java type, uh, syntax, um. Uh, but you know where it uses like kind of the curly braces for blocks and, and has, you know, the standard sort of uh constructions, you know, for like ifs and and for loops and and all of these other sorts of things, but I figure you can kind of fill those things in yourself and then there's a link to a learn JS page, uh, when I, you know, a few slides back you can, you can go there. That's got, that's one of many excellent, uh, resources for that. But what I wanna do is instead of like kind of doing that kind of step by step, you know, introduction of language I wanna really highlight certain things that distinguish uh JavaScript from other languages partly because this is just interesting and worthwhile to know as a new programming language but also because there are things that are probably you might or may not kind of come up against as you're starting to develop um. And so if you're aware of them, uh, then that's good. So, there's a list of different topics. I mean, I wanna talk a little bit about scoping, how that works. Sort of, you know, where scoping where variables are, um, I, I wanna, uh, talk about objects, methods and functions, um, so objects are a. Uh, it's not like a strictly a, a strict object oriented language like, uh, Java, um, but it has some interesting features, um, related to the relationship between functions and objects, and then it's just a bunch of other, you know, topics so like, you know, how expressions work and so on. So I wanna kind of go through those, um, and that actually stuff I'm gonna go through rather quickly that's all week one stuff, uh, but then I'll just, I'll just continue on into the to the other things. All right, so let's just dive into it. Any questions so far? Oh, OK, so. First off, in terms of scoping, um, so all languages always have certain some notion of scoping, uh, where it basically. Describes where what is the scope of a variable, you know, uh, once you've defined it and where you can access it and references. So, uh, one thing that's interesting is that, uh, JavaScript is quite different than languages like that you might be familiar with like Java and C and C++. So if you scopes, if you define the scope of, uh, or sorry, declare a variable like uh integer X inside of an if block. Uh, in a language like Java, it's only available within the F block, um. But in fact, if you, uh, declare a variable in JavaScript within the block, it's actually available outside uh to the uh the whole function um. That's one interesting, uh, uh, difference. So here it's basically declaring X is a variable, uh, inside of this if block, but you could access it, you know, outside of the if block and still reference X. Over time and this is part of the complication I guess in learning JavaScript is because you'll look at different examples from different eras, but over time JavaScript has become more and more of a mature language so it was actually built, um, as a language in a few weeks, like in 3 weeks or something it it was, uh, I think Netscape was the company they wanted to. Kind of, uh, have a scripting language inside a browser and so they whipped it together. Java was very popular, so they called it JavaScript even though it really doesn't relate to Java at all it's a programming language and they just threw it together and so it has all these crazy quirks because that's what happens when you write a programming language in a matter of weeks. Over time though, there've been improvements and so on and so forth and and and so if you look at um. Sort of Actually JavaScript now is officially called ECMA crit, um, so they have different ECMA script versions, and so ECMA cript 6 was like a really important one where it introduced lots of new language features that made it in some ways a better language. Uh, there's actually subsequently been more more versions, so I think, I think they now do the version numbering based on year, so it's probably like ES instead of ES6 for ECMA script 6 it's like ES 2020, you know, 4 or something like that. Uh, but, um, initially you could do all kinds of things in, in JavaScript, um, like you could, uh, you could basically have variables that aren't declared and just reference them, um. Without like the VAR keyword and so on, um, you really shouldn't use them in the code, um. There's ways, so there's a, there's certain kinds of um. Basically, uh, markups that you can do to your code to tell it, um, whether sort of how strict it should be in the semantics of your interpreting your JavaScript code, um, so for example there's this statement like if you write you strict and like actually like as a string semicolon at the top of your file, it's basically telling. Uh, the JavaScript that it should, uh, it shouldn't kind of, it should throw errors when, when you do some of these like old style features like, um, you know, undeclared variables and so on. Um, so. Now, uh, like var var was the thing that was basically a way to just define a variable. They replaced it with let and cons as as two keywords. So let basically is how you declare a variable now const is how you declare a constant value, uh, that can't be changed, and the scoping changed. So the lexical scope here that we had here. Bar which said basically you could access X outside the block that changed. Uh, so if you're using lettin const, the scoping is more Java-like, um, now. Um, So, uh, so it's been kind of evolving and, and you know it's it's, it's mostly highlighting this because we're gonna use things like let in constant or code but. You know, you could very well look at code examples online that use VAR and you know and the thing to be mindful of is, you know, maybe it doesn't make a difference in terms of just maybe you could just swap in Latin cons or whatever and you think the code's the same, but there's actually some nuanced differences in terms of the meaning of these and how the program gets compiled and and so on, um. So Uh, Another thing, uh, is that there is a notion of a variable uh hoisting. Um, So Uh, So if you make, if you declare a variable, uh, here, um, it's actually um does something where it. The interpreter will actually move that up to the top. Um, it won't assign the value, but the, the variable itself will not be like uh undefined at that point, um. Uh So you can actually invoke a function before they're declared, um, so you'll see things where like you'll have a function that's declared lower on and you can, you can then actually, uh. Uh, use it, um, like that. It doesn't work with something called the signing functions don't worry about that. I can, uh, it'll be a bit clearer when I talk about functions as objects in a moment, um, but the point being that where when you're probably writing your code, you're probably better off just trying to declare your variables at the top so you understand sort of where they, where they live, um. So JavaScript is is object oriented in the sense that it is objects but it's not a strict object oriented language like Java um that means it's not compulsory that everything be classes um obviously you can just write a script without any classes at all um and basically an object is just a collection of properties that's the terminology so where we would think of properties is sort of your fields or your variables inside of your object. Um, so you've got these, you know, just think of it as like a bunch of keys and, and values. So, um, you know, it's sort of like a dictionary in a way, right, like, so in Python, so you know how you've got like some various, uh, kind of keys, and those keys can have different values where the property itself can also be an object, so that means basically the. You know, you can have nested objects, uh, in that case, um. A method is just a function that's also associated with an object, but. Um, You can kind of think of it as a property that happens to also be a function so it's so that it turns out that functions themselves are objects in in JavaScript so you can kind of think of them as um just another kind of like nested object within within the uh um. Within that object, uh, so. Well, we'll have a few. I'll, I'll talk about that a little bit more detail. So another thing that I wanted to highlight just in terms of um sort of language features because you'll see this a lot in the kind of code that we do both in terms of maybe the examples, but you know other things is that they have um a notion of destructuring, um, so this is the idea that if you have an array or you have an object. You can destructure those into different, um, sort of, uh, variables like reassigned variable names for those different properties within the object or those elements, uh, within an array so. Here's an example like. Of an array, um, let's say I create a constant array of animals. With 3 strings in it. Uh, you can destructure it using something like this where you define, use the constant keyword to say it's, you could think of it as sort of like a pattern matching, right? um, so you're saying I want to create a bird, parrot and reptile, um, cons um, and you said it equal to animals and what it does is it destructures each of the elements into those different things. So then you can refer to. Like bird, and if you were to log out the bird console log is just like kind of the print line for for for JavaScript, you can. You know, you're, you basically are referencing the first element here and the second element here and so on, um, there's other kinds of syntactic sugar you can do in the sense that like you can, you can reassign rename them, um. Oh sorry, that's not what I'm doing here. This right here, this is like default values, um, so in this case, um, you know, you might have, you're destructuring this array into. Uh, these variables, but since this array is missing an element, I mean it doesn't have a second element in it, then, uh, this one has a default value. So you'll see that first, um, has this default value of Kakapo, but because there is a value, it will take on that value, and second, uh, because there is no value to take, uh, it takes on the, the default value.

SPEAKER 0
Yeah, so if you had specified for that 2nd 1 to be a perfect over that and just like throw in the.

SPEAKER 1
Like if you don't, uh, specify this, oh, it would probably be, um, uh, undefined. So in, in, in JavaScript, there's an undefined type. So, That's a great question. So objects work the same way. You can destructure them. Um, this, you'll see this a lot. Um. You know, so for example, say, so, so the way you divide an object is with a curly brace, um, and so this, this is an object, uh, it has no methods. It's just remember an object is just a bunch of properties. So in this one it's got like, um, name population and known for its three keys and the values are a Wellington, which is a string, uh, you know, population, which is the number, and then known for which is another string. No, none of nothing here is typed really like strongly typed like you can just declare variables and it kind of it will infer the type, uh, once we get your type script, you'll see that you want to actually like all of these, these will be be typed, uh, so that like things like name will be defined as having a string type of population and number type and so on. But in JavaScript, none of that exists. uh, you can just create your object like this. Um, so it's a, you know, city has these three things, and then you can actually extract them, uh, directly and you can actually rearrange the order of these, um, if the names match, um. Like they don't, this isn't like an ordered list like the, the array, um, you can also, um, rename properties if you want so. Uh, for example, here's another one. This, uh, city info has, you know, Auckland population and, uh, nickname, uh, and in this one, you know, we're going to rename. The name field to city name, uh, rename population to city population, and the nickname stays the same so that then we reference them, you know, but based on their renaming. Um, so this is just some nice like features of the of the language, but you'll see this kind of thing a lot, and I just want you to be able to, you know, look at the look at the code and understand essentially what's happening here. um, so destructuring is, is, is happens a lot. When we got to doing react later on in, uh, term two, you'll see a lot of destructuring happening there. Um, you can do it in function parameters as well, um, so. Uh, here is a function describe animal. It's and basically it's takes one parameter that's an object, but you that object, uh, type is being destructured. So it's almost like the, it doesn't actually assign a variable name to the objects that's passed in it automatically destructures it into the two, properties, uh. So that you can just, you know, have a type like this like animal has a name and a habitat you pass an animal and it will automatically like pull those fields out, um, and then you can reference them. If you were to send this just as a regular object, like if this was just, uh, an animal or whatever, then you would have to say animal. name and animal do habitat inside of the function that makes sense. Uh, All right, so destructuring is something that you'll see a lot as a language feature that's uh maybe not in so many other ones. So I'm just kind of going through these at a clip, um, but feel free to stop me at any point if you got questions or anything like that, um. So the next thing that I wanna talk about is sort of functions and how what they are in JavaScript is like as a language because it's a little bit odd actually. So, um, you know, normally you would think about a function, it's just like a code block, right? that you can execute, you can pass in parameters, and it has a return value. But in JavaScript functions are first class objects, so a function is an object like any other object. It can have properties, it can have methods just like other objects, so functions can have methods, um. And it's just distinguished from other objects in that they can actually be called. You can't call a regular object, but you can call a function object. So technically speaking, functions are function objects. There's a lot of really interesting like deeper stuff you can get into this and I, I'm, I, I can't really explain sort of the, well I mean it could, but there's a lot to sort of the design of this and and why this was done the way it was, uh. Uh, first place, but it, it has some really, um, practical implications because you can start to do things like past functions as parameters for other to other functions and things like that which we will see happening all the time. Um So In terms of the language itself, excuse me, like, you know, if you think about when you've got a programming language, um, we don't often like break it down into, I mean maybe if you took like uh the programming languages course, um, that, um. Uh, you know, maybe, maybe if you take that one, I'm not sure actually what's covered in that one, but you can start to get a little bit into sort of the semantics of, of programming languages and understanding sort of how, how the how the language is actually parsed into different components, but. One of the things is that. In JavaScript, um. You know, there's a distinction between things that are expressions, uh, things that are statements, uh, and things that are declarations, so. An expression is like it's like something that produces a value. So if you have some kind of line in your code. That produces some uh. Some some value so for example if you, uh, you know, to were to execute a function and the return value is then assigned to a a variable. That's an expression, right? Um, you can also have statements that which are things that kind of uh do things um you know, so like, you know, um. You know, and if statement or something like that. And then you can have all declarations, um, so declarations are sort of like. VA X or something like that. You're, you're basically declaring that there is an X that you're going to be using at some point. Um, but. JavaScript has these notions of expression statements it's like quite odd. So basically every time JavaScript expects a statement, so something that does something, you can also, uh, write an expression which this means is all statements can kind of return values, uh, essentially, um, and. There's more on this, but the reason why I'm kind of laying this out a little bit is to, I want to talk about functions and what's actually happen because because we use functions in a way that's a little bit different maybe than you've you've encountered in in other languages. So Uh, you can, so, so see here, let's take a look at this example here, um. We're saying we're creating some variable called result. And we're setting it equal and then you see the function keyword. And then the name of a function and then sort of the declaration of the you know of of how the how the function has no parameters and then here's the block of of the parameter and we'll say a function is a it's a function that returns. -1 is its return value. Um, so does any idea what result holds? Like what is, what is the value of result after you? After you uh execute this, yeah.

SPEAKER 0
And Yeah, it's an object and in fact it's a

SPEAKER 1
function object. So what result holds is this function that you've declared because not only is it. A statement, the function, you know, defining a new function, but it's an expression so it's actually returning this, the result of all of this here is a function object. So this means we can use result. In the exact same way as a function, so we could, we could call result we could in the line below we could say result, you know, parenthesis, um, and it would execute this function, um. So, yeah, all right, so this is. Basically, um, the example, so in, in this case. This is the same here. We have results, uh, executing set equal to this function. Result one becomes a function object and then we can now say I want to set food equal to. Result by calling result one and the end of, and the result of that is that food will equal -1. So you can basically set variables equal to functions, um, and then pass those around as if they're regular uh objects and this will become really handy because we're going to be using things called callback functions that we want to pass into uh essentially once something is done happening we want to be able to execute it. Um, So This is a very similar situation, but in this case you are both kind of, you know, creating the function and then immediately executing it, right? So what happens here is that result one will equal -1 because it's, it's creating the function object. It's executing it, taking the results of that and putting it in there. Um, and in fact, you don't even need this label right here at all. You can just create an anonymous function if you want, um, and it will work. Um, so then you get into like really funky stuff like this, and now you won't be writing code like this, I promise, uh, but, uh, this is something that you will see, and the reason why, uh, this stuff happens is that. You know, people were trying to they they would end up a kind of scoping an entire module inside of some construction like this, uh, because it would essentially um. Create it was basically a way of of declaring like variables could not could not break out of this module um because there's this problem where if you had global variables and you import a module from another one it would then you know, suddenly your code's incompatible so they would do things like create a variable inside of this kind of construction here um so what this is doing is this is actually um. Uh, creating This becomes like a, a, uh, an expression that produces a value and it automatically just runs, runs all of the code that's happening in here. So Uh, I'm already at 246, so, so just thinking about this a little bit like you have to think about like what's going on here to understand what's happening with the brackets. So I mean brackets kind of used in different ways so you can use a bracket as to execute a function, right? That's a normal way to do it, um, but it's also used to force like precedents, uh, in something. So in this example what's happening is it's forcing precedence on this part here and then it's executing and um and so this is something that's called an immediately invoked function expression it's really mouthful uh but essentially it it the outer brackets uh close sort of this thing called like an an anonymous function and then it's executed um and so what's what this does is it creates a scope and so variables that are defined here. Uh, cannot be accessed outside of it. So you, if you look at old JavaScript code, this is less of an issue now, but um, you know, give you a little bit of context, old JavaScript code use this a lot like if you would download modules, you see everything was inside of this crazy statement and so now you understand why. Why was this, was this done? Um, But if you do something like this, this will actually not work and the the so what's happening here is um. I created a function. It's an anonymous function. There's no name to it. It has some statements and I execute it. If you type that in the web console and not that won't work, and the reason it doesn't work is because. If you don't with the function keyword, JavaScript doesn't really know how to handle it unless there's something else in front of it, um. So like if you, if you add in a plus or uh like kind of a not or something like that then it knows that it's supposed to treat it, it knows whether it's a statement or an expression and it and it knows how to how to handle it um so you'll see all kinds of funky like stuff like this. I promise you're not writing code like this, um, but you will certainly if you dive into enough JavaScript on on the web, you will see stuff like this, uh, guaranteed and so at least you understand. A bit of what's happening um. So, uh, the last thing I wanna say about functions, uh, before I quit is that. Functions um. are, are, are, are not actually. The scope of a function is not actually the just sort of what's defined inside of the function. It's kind of an odd notion. So. When you, when, when you've got a function, it has, it uses the the scope of variables at the time the function is is defined, not when it's invoked and so. Um, what that means is if there's any variable that exists in your code. Um, whenever you kind of like define your function by that mean I mean where you type, you know, the function, put the name in da da da da, you can access that variable, uh, so the scope of the function is not just the variables inside, but it's something, something bigger like whatever that thing is bigger and that thing that's bigger is called a a closure and so. Closures are important because they are sort of how. You can kind of access um sort of um variables that are maybe managing some state like if something happens in a a synchronous way and you need to uh you know have a call back and it wants to respond to that state once certain things have completed. It's all based on sort of that that scope, um, so. Basically the idea. Well, I more or less said this, but the there's some kind of record that's held, um, as you, as you're programming that when you write a function that it holds basically a function together with its broader environment, um. Uh, so you can use variables locally that are defined in, in, in the, in the scope, uh, a bit wider. Um, all right. I think I'll just leave you with that kind of really kind of, uh, weird, uh, concept, and then we'll dive into some concepts and we'll do a bit more about JavaScript, uh, tomorrow.

SPEAKER 0
All right, thanks everybody. I I. Yeah. I. Yeah. OK. Yeah So. Yeah, uh I'm gonna have to log into my I'll get lost and error message. OK, um, can you, um, you know, yeah, it's just,

SPEAKER 1
uh, it's just the IT for the, the computer science

SPEAKER 0
department. Let me just see. Yeah.

SPEAKER 1
Yeah, can you write an email to the it's TAS at Cosk. Canterbury.ac.nz. So just, just let them know that you're just send them their message and help you out.

SPEAKER 0
No problem. Thank you. OK. Mm. Well No. Uh I can say Yeah. I come out of those. So Yeah. Because I've just been. Yeah that significant.

SPEAKER 0
Yeah. I. I this one. I Yeah All right, uh, let's go ahead and get

SPEAKER 1
started, um, so I yesterday I was starting to introduce JavaScript. um, I ended by very quickly just introducing the concept of closures we'll talk about a bit more about those, uh. As we get into sort of how we handle events, uh, in JavaScript because um closures are the concept that like a function is essentially not just uh isn't just its own kind of scope but it has an external context uh associated with it and so we'll come back around there it's a bit of a confusing concept when you first uh start to. Dive into it, but as we, as we come around to, uh, some examples with JavaScript, it'll become clear um so today what I wanted to do is I'm gonna plan to continue, uh, talking about more of just kind of the overview of JavaScript, uh, uh, but before I begin, any questions about the material that I covered, uh, yesterday or anything in the labs or about the assignment? Anything. Nope, um, OK. So, um, before I did kind of dive back into some JavaScript stuff, um. I do wanna just uh show an example of what it's going to look like inside of your assignment um inside of your node JS uh application which is what you're developing your API that's gonna be for assignment one, so in that skeleton project, uh, you know there is some source files already and as you go through the labs you'll you'll get a sense of how to actually, uh, work with that. But I wanted to just, uh, show you here in the lecture so you kind of know what you're looking at, um, some examples of how, uh, we have some JavaScript code. It runs on the server so it's not in the browser, but it's like it's gonna be running sort of on your in your in your case you're probably testing on your on your own machine but it it sits on some server somewhere and it's going to, uh, essentially, uh, handle HTTP requests so it it's a server that is meant to take those requests that we talked about, uh, last week, like the, the get and the post requests and that sort of thing. And it's going to take those, handle them in some way, um, and then send back a response, um, and so the way that we do that using OJS is we usually use some kind of library, uh, that exists for handling HTTP, um, and so, uh, it's in our case we're using, um, sorry, get my mouse over here we're using the HTTP package which is a an external library, uh, that you will that is installed in your. Uh, into your, uh, project, uh, along with the express package, so these two packages work together, uh, and they basically have all, you know, they make it easy to handle HTTP requests and, and, and so on, so, um. Sorry, see Too many windows open here. Just give me a second here. All right. So This is what it's going to look like at a point in your code when you're essentially handling requests in from an API. So, so what happens is you're gonna be writing, you know, a a client application in term two that is a, a game, uh, sort of review website. And so for that that we're gonna have a set of different kinds of requests that you wanna excuse me, that you wanna make back to the server and so when you make those requests, um, each one of those is going to have a certain path, uh, that's defined in that URL, uh, if you. How we had like different you know URLs that you could kind of specify and as you look through the path of that URL that each sort of however you kind of define that is going to map to some method or some function within your within your API um so the way this works with Express, uh, which is the library um. Is that you can define uh an app object. all of this is in the source code, so there's there's a few lines ahead of time that like kind of set it all up, um, but in that then you just define a series of routes, um. And each of those routes is going to be made up of different components that correspond to kind of the elements of that of that URL, um, that is specifies what kind of method you want to call, um, so. For all of them there's gonna be some kind of basically route to the URL that defines sort of the, the beginning of what all of those um URLs look like um so that's just gonna be stored in this uh constant uh value. Uh, which is defined higher up in your code, so the root URL is just kind of the, the root of that path. Um, in our case, it's going to include some API version number, uh, information like, um, it'll be like something like slash API slash V1 slash and then at that point. The, the rest of the URL is going to be sort of whatever method you're defining. So in our case, uh, we have an end point called users, um, in this example. So this is like the extension and so you're gonna have a bunch of these different definitions of a route app. route. route where you're defining different end points for your for your API and what these end points are meant to be, well, that's all defined in the specification, um, which I'll show next week in lecture. I'll go through that in more detail. So here you're saying, I want to take a particular, essentially a URL pattern. So any requests that HTTP request that comes in with that pattern. And then I want to define what kind of um HTTP method um I'm handling at this point uh and in this case, you know, if you recall last week we had different kinds of HTTP methods. There was get um there was post, there's delete and so on so. Depending on how the spec defines, you know, which methods you're supposed to use, you know, that's just gonna correspond to another, uh, you know, method here method called it'll either be dotpos or dotget or something like that and then the, the, um, thing that you actually pass in here. Is this is actually a function. So users.create is a function. It's a callback function that that we want to, um, execute, excuse me when. You get that kind of request in. So it's inside this users, uh, create function that you're going to be writing all of your, your code that actually handles, uh, what happens with, with the message when it comes in, um. So as you go to the labs, this will also become clear because you're gonna get to kind of try this out and, and use it with a, a test example. um. So there's nothing in here about sort of ports or domain names or query parameters um so like those things are kind of defined in the app uh when you create app you you define things like the port that you're listening on, um, you know what your domain name is and and stuff like that. So that's you'll you'll see that, um, but that's sort of set for all of your end points like for for each individual endpoint, what you're really interested in is this part right here. OK, so when you get into your, you know, function that's gonna handle that request, then you want to actually execute some code, right? Um, and so inside of that, so inside this function like a users.create function, so imagine we're inside of that function somewhere. You're going to. Uh, do some more, um, sorts of operations on that. So I'm not showing the whole function here, but. It passes in the request as a as one of the parameters. So the request has is the actual HTTP request. so it's gonna have some, I mean express does handles this all for you. It's basically taking the HTTP request, you know, that text, uh, file and it's, uh, parsing it all up and it puts it into an object, uh, and that's gonna be this REQ object and so in there you can access the body, the headers and so on and so forth as you need. So in our case, we're gonna grab the body of that. And call another function called create which actually is the function that's going to uh sort of manipulate your back end model. So what what I mean by that is that when you create a user, you need a function that's actually gonna make a request to the database. It takes a request to the database gets a response, and so on so. In this, um, I, you know, we'll, we'll cover what all this notation means, uh, as we go through the, the lectures, but you're essentially going to wait for that to be created in the database and then that action returns back the new user ID that was created. Uh, and then now in REQ is the request that came in now you have to construct your response. So in HTTP you have a request and you have a response. Well, you're the server that's now going to create this, uh, response that's gonna be sent back, uh, to the client and so for that you just are gonna be setting various, um. Uh, fields for that. So, um, for example, uh, you can set the status message, the status code, if you recall, every, uh, response has a different sort of 3 digit response code or 200s are sort of like success codes, uh, 400s are error codes, 500s are server error codes. So you are going to have to kind of look at the spec and see sort of like what kind of what kind of code do you expect to return, you know, for what kinds of uh uh messages and then the actual data that sends back the body is the response is gonna be sent back as some JSO data so we'll we'll cover that, uh, later on, um. So this is, you know, the basic structure you'll notice that this is inside of a try catch block. So try and catch is sort of how exception handling is work is, is done in in JavaScript. So if there's like, uh, you know, for example, if you execute something and it throws an exception, um, and it's going to catch it in this error thing, uh, here. So that would happen, uh, because this function here could also throw an exception but most likely that's gonna happen things when things happen like for example, you try to connect the database and the database connection throws if that'll throw an exception if there's an error and then that will get propagated out and then inside of here you might return like a 500 status code or something like that, right. Um, So the body of the request. Uh, is all gonna be dependent on the spec that how it's defined. Some requests have a body, some don't, um, you know, they don't necessarily have to have a body, it's all defined in the spec. So like, for example, you know, it could be, um, you know, that some get requests, uh, where like, so imagine you have an end point that's like, um, some like slash, you know, your root, whatever it is, APIV1. And then the end point is users and then it's slash like and then you put like the ID number for the user like one like if you have something like that, everything is encoded in the URL there's no actual body associated with with the request that's totally fine. I mean, you could have get requests that look like that. But if you are in other cases, um. You will, uh, send, you know, some additional data in the body. There's different kinds of bodies, categories of bodies. Um, so, uh, with HTTP you can have these single resource bodies. Because since you have a single file no length, um, and so in those you basically when you construct your request when you're making it, um, you can you actually specify the content linkth sort of like, you know, in bytes and the type. So for example, it might be, uh, uh, a string that indicates it's a, it's a JPEG or it's a PNG file or something like that, right? um. We'll, we'll have examples of what this all looks like, but the point is, is that like sometimes you're going to need to, uh, put some information in there. There are two other, uh, types single resource bodies with a file of unknown length and multiple resource bodies. Basically you're not gonna be using either of those that I just wanted you to be aware that like when you make HTTP requests you can have that, but like the kinds of requests that you're gonna be making are like. You know, some piece of maybe some data, uh, with some field information or potentially, um, like when you're doing something like uploading an image, uh, you know, you would actually encode in the the body would have the, the image data in there, um. So those bodies can have all kinds of content, but we're generally going to be using JSON except for with respect to the image files. So that'll be a special case, and we'll come back around to that, um, yeah, we'll cover it in the labs, but we also see it in the, in the lecture. Um, OK, so that, that's all I really wanted to say right now about the assignment, but any questions about that? Yeah, just from what I've covered so far. That makes sense. OK, um. The labs should kinda kinda give you scaffolding to kind of get into that um as we go. And we'll come back around to it again in the lecture as well. um, all right, so, um, I just wanna continue now with just more about JavaScript, um, so we can kinda get through sort of the fundamentals, um. So I'm, I'm now gonna continue with a few more things, um, so. When, um, When we cover when we talked about um sort of uh JavaScript being object oriented um but it's not it's sort of like object oriented in the sense that you have objects right and those objects can have um. Essentially, like, you know, functions that are properties, so those are the methods on the object and all of that. So in any kind of object oriented thing like whether you're doing like Python or you're using, you know, Java or something like that, there's some sort of like way to reference the object in question uh for one of its methods, right? So you, you know, like you would say, uh, you know, Python Python or be like the self or like this, um. Is another way to do it that's common and so in JavaScript it's this is the keyword so uh that that keyword is used like when you're defining an object and you have a function in there, uh, that you wanna reference sort of the internal fields or properties of of the object. The thing is, is that Uh, that value of this, um, actually differs a bit, um, depending on the context of, of where. the context of a few different things, so it, it, it, it varies based on sort of whether you're running in the browser or you're running in the, um, uh, sort of, you know, in whether you're running in like uh some kind of engine like for for no JS so that makes a difference, um, but it also, uh, if you recall things like functions are also objects, um, so they have their own this and, and so on and so forth so it's something that it it. It can kind of lead to a few different behaviors that you might not, uh, be, you know, initially aware of. So, um, So you know whenever you're running a function you know you have the function's current scope uh you know and so. It has that, um, but then it's also uh includes. In the scope of whatever happens to be referenced by this at the current context of where you're executing and so that's different depending on where you are. So like in a browser, so say you're not actually say you're not actually in a, you know, defining an object and you're a function is one of the properties of that object, but you're just writing sort of your main block of code. You can still access this, but. There's kind of a default context for that so in the browser it's something there's a global object that's just created called Window, um, and so Window is populated with a lot of information, uh, that sort of allows you to uh access certain elements, for example, of what's in the current. Uh, document that's being kind of, uh, rendered in in in in the web page and so we'll talk more about that in term two, but it's just, just so you know, like if you were to say write this in the like say you go into the console in your browser and you just say this. You're going to get this window object and all this window objects, uh, elements, um, and know it's different, uh, there's just a different global object it's called global uh and it has different things available to it, um. So, uh, You, the, the other thing is that because. If you recall in that that example I talked about um last time about where you can kind of reas you can basically assign a variable equal to a function, um, if you recall like so in this example, like, let's say, uh, you know, u.bar. So food at bar bar is a is um one of the methods for this food object, right? So if you were to execute umu.bar. Then directly then it's going to um then then the the this that's defined inside of this function so so imagine bar just says like you know console log you this uh dot X or whatever like that, right? So basically it's, it's printing whatever is whatever this X field is for this Foo object. If you were to call that directly off of oo, then that's gonna correspond to that, that, that particular uh oo object. But if you reassign it to another uh thing, then at that point if you. This fee fee is no longer like part of that food object, right? It's just a function. Uh, it's basically it's a variable that maps to this, this function, you know, as you've defined it, but it's, it's been kind of extracted outside of an object. So, so that when you call, when you say console log this.x, it's going to depending on the context, it's going to look for window.X or global.X, um, so it's a bit, it's a bit fragile I guess you have to be aware of these sorts of things if you're. If you're using these things and you decide to kind of reassign. Uh, functions, um. So, um. Any questions about that? Does that seem to make sense or? Yeah, OK, um. So Because Because there's so many cases where um. Well, OK, so, so because every function is an object, right? There's lots of cases where you might want to define functions, uh. Like an anonymous function that you that you execute as sort of maybe like um so just give you an example so say you click on a button or something and that event you wanna define an anonymous function that's going to manipulate some values in in the surrounding object, right? That's great like that that in theory that would work and so what you would do is you would create an anonymous function that sort of describes the behavior. Uh, when the click happens, but then that when you, when you actually look in the code, you wanna be able to reference that surrounding objects, um, sort of properties, right? So you wanna be able to say, you know, if, if you say click a button, maybe you want to sort of say if you've got some flag this flag equals not this dot flag or something like that, right? You wanna do something that's going to change the state of the surrounding object. The problem Is that if you define that anonymous function that's an that's an object itself as as uh um and so so that if if you define it sort of like this notation of the function keyword passing things and and do something if you have this in there um that this is is gonna be sort of tied to that function it's not tied to the surrounding object um and so. This is a big problem because it you have to, you have to do all this kind of weird constructions of like um passing this in as a parameter like and calling itself and doing all kinds of stuff like weird kind of spaghetti type code stuff that people did and so a work around for all of this, um, and. Partially the motivation is work on for for this this issue but also just in general to try to make the syntax clear. Um, they created a new, um, way of describing anonymous functions with this kind of notation in ES 6. So instead of, you know, trying to, um. Uh, sort of, uh, uh, you know, instead of like declaring with function and all of this, it has this real shorthand notation where you just put like your parameters in, in these kind of brackets and do equals arrow to and then the result. Now this could have a curly braces, so this can have, this could be a like a compound statement if you want. Uh, but arrow factions are very, very handy in particular because we're gonna use those a lot. It's sort of like the like when we, when we have like an action sort of respond to an event we're gonna use something like an arrow function as, as the thing that's going to sort of uh manipulate the state of the of the object of that surrounds it, so. And it, it also leads to much kind of tighter, kind of cleaner looking code. You don't have all these like function keywords all all over the place. Um, so arrow functions are quite nice, um, and like I said, they don't, they don't have their own this, so this kind of gets around, it gets around the problem of it a bit. So here's just an example that's maybe makes it a bit more concrete, um. So imagine you are inside of an object, um, and you've got some function and in in that um in that object, uh, you have a field called color, uh, it just has some string, um, and at some point in your, in your code, you're going to execute, um, this color equals red, so you're setting the field value to red. Uh, then the next line here, um, calls the set timeout function. So, Set timeout is an API function, you know, that the JavaScript engine provides, which essentially is a way of, um, sort of saying, Create a time out so that it, you know, for some X amount of time after which that point after that time has elapsed, uh, execute some callback function so where a callback function is just some some function that we want to get executed, uh, you know, after some condition has happened. So the, the way the way this looks is that the first parameter, which is everything sort of from here to the comma, the first parameter is the function that should be executed once the timeout has, has elapsed, uh, and then the second parameter is just microseconds, um, so you know, this is one, second of time out. So So what this what this code is saying is that um uh you know, I'm going to set the color of my object to red. And then once 1 2nd has elapsed, I want to change the color field to green. Now, this works because we're using this arrow notation, um, and This error function notation. If we had described this as a, in the older style of a, an anonymous function, or use the function keyword uh parenthesis, then this. Dot color would be the this for the function itself, right? Like this little function it wouldn't refer to the same this as here, um, so it's you're, you're probably going to want to use these kinds of arrow functions, uh, a lot in your code because it just simplifies things a lot. Um, like I said before, it would have to be something like you'd have to actually pass in, uh, this as a parameter, um, and then, you know. Deal with it, so, so anyhow, um. So this is a, a very like, like handy thing and this, this can be used in either sort of on, on like no JS or or the kind of. Like in the website, but you're gonna use it a lot more in the website because that's really where you're dealing with events, uh, occurring a lot, um, is, uh, you know, like any time you have some event like a button clicked or you know some some changes because events are flying in all the time like the users doing things in all different kinds of, you know, unpredictable order like you need to have a bunch of like reactive, uh. Functions that changes the state of your application as needed. Um. So error functions are, are, um, important, um, and just keep in mind this, this thing about this, um. Another thing that you often see in uh JavaScript code is the notion of method chaining. So method chaining is just the idea that. Uh, you have, you, you, you're essentially gonna write some, some expression like this where you have a result and that result is going to be sort of the, the end value from chaining a bunch of methods together so. Each method, um, returns an object. So method 1 will return an object and then it calls method 2 on that object, uh, and then method 2 returns an object. And that object calls 3. So, so this kind of construction, um, is, uh, is it's often used in, in, in JavaScript and the important thing is that the returned object for each of these methods must have the subsequent method as one of its methods itself right? um, and so. The first method could sometimes create a brand new object, or in some cases you might have a variable at the beginning, uh, and call like the method on that, right? Um. Usually the way this works is that you do method training on the same object, so you might create an object and that object has 3 different methods in it and every single one of those methods will at the the very last line of its code will uh return this. So basically what it's doing is it's saying I'm going to do something, you know, to change my state. At the very end it returns this and then it calls the 2nd method and it calls the 3rd method and so on and so forth. So the important thing is you can't just arbitrarily chain methods together they have to make sense that like the return value for each of these methods has to then have that the subsequent method, uh, in there, um, and this, um, and, and if there's like a common object that has all of the methods together, then that's kind of usually how it's done. Um, So, uh, here's an example of an object, uh, where you could do something like this. Um, so I'm gonna create. Uh, Um, an object, uh, and that object made of a first name and a surname, um, and then we have different, um, Kinds of uh functions that you could call and so you could, you could see I mean the important point is that the last line of each of these, these methods, these could be error functions by the way, um, the each of these methods will return, uh, this and so if you're returning this on each of these, then, um. What that means is that now you could chain each of these methods together, like I could say another person do print first name, dot print surname, and that would work, right? Um, So why do we change? Well, I mean, it's, it's a way to kind of make your code more readable and just uh. Well, make it more readable and also like just. Less kind of verbose, right, because you don't have to have temporary variables in between them so you create like, you know, you're one you have one variable maybe and then you just chain in a bunch of of methods. Um, and then you don't have to kind of create, you know, each, a multiple statements saying like version one, version 2, da da da da, or keep kind of, you know, updating the same. The other thing is it's sort of it's it's expressive in the sense that you can if you if you think about treating the methods as sort of like verbs on your object then you can almost read the code like an English sentence right you can just start with your your variable and then take different actions on it um so it reads kind of like a uh a sentence you know in in that way. Um. It's used, uh, in particular, um, in using something called Promises, which I'll cover, um. You know, in a few slides, so there's these things like promises, um, and thenable functions are things that we, we come again to again and again. So these are essentially functions that sort of, um, sort of expect some process to complete at some point, um, and it's a method chaining like this is used a lot for that. Um, One, I guess, um, this is 11 last item, uh, that I wanna kinda hit on before I, I switch sort of into some. One of the more like kind of complex concepts around uh promises and so on is that it's just that I mentioned this this last time is that there's this because JavaScript is a language that's evolved a lot um you often, uh, will. Have to think about sort of what version of JavaScript you're actually targeting now you don't necessarily have to think about this in your code because the way it's going to be done is you're gonna be writing TypeScript code, uh, and TypeScript is gonna be transpied into JavaScript and it's gonna automatically add in some what what we call strict mode but. Just so you know, I mean the strict mode is a way to kind of deal with all these different versions of JavaScript that we have, making sure that. The semantics of your program actually makes sense with how you the way that you. Thought about it. So if you do things like use strict, um, then it actually changes some aspects of your code. So if you what this is is it's actually you just put this as a string character at the top of your JavaScript file, um, and it changes things. So for example this. No longer defaults to Window or Global. It actually defaults to undefined. Um, it will not allow you to do some of like the kind of older school ways of like doing very little declarations that are, um, not well defined. It throws, uh, some errors, um, for certain kinds of code. And there's other things as well, um. So like for example there's some like even an old older style JavaScript you can even reassign the meaning of keywords in the language, uh you know to make them functions which as you can imagine is highly dangerous um uh so so all of this kind of stuff, uh, is, is there, um, and it operates something like a linter if you're not familiar with a linter it's essentially like a way to sort of um make sure that you're. It's, it's a pass through the code to make sure before it's compiled, that it, it conforms to certain kind of standards for, for good coding practice. So, it's all there. OK. So That's sort of JavaScript in a nutshell, um, but it get JavaScript gets a little bit more interesting, uh, when we start to think about asynchronous JavaScript and so one of the things that really kind of distinguishes maybe what the kind of programming that you've done previously to the kind of programming that is all over the place in the web is the fact that things in general are uh asynchronous and so. Uh, let me, I'll just explain it a little bit more before I go to the next slide. So the, what is, what this means is that whether you're working on the server side or you're working on the the front end side, all kinds of sort of events are occurring and these events are going to be things that are going to trigger some execution of your code, um, so for example. Um, on the server side you might get in a request, um, and like, like a network request, um, and you don't know what kind of network request is going to happen. You don't know when it's going to happen, um, that network request might need to make an additional request to a database. You don't know how long it's going to take for that database to respond with an answer. And so the answer is asynchronous in the sense that you don't, it's not necessarily happening all at the like like your code needs to keep running it needs to keep sort of uh actually doing it needs to keep doing things um and not blocking the rest of the application while you're waiting for all of these other things to happen. It's the same on the front end. So if you're using the browser and you click on a button or you, you know, make some request like a network request to get some information from a server, you can't freeze your application and just have it sit there waiting for the response to come back. So you need to have a program that can flexibly, uh, respond to sort of this asynchronous, uh, way of, of operating. And so JavaScript is particularly, uh, well, well designed for this because it has built into it, um, any kind of JavaScript engine, this notion of an event loop, um, so the way that the. Event loop works is that. You know, when your program is running, um. You at any given point you're executing some function, right? And those functions have to be like so imagine you start with a main function, right? You start to like kind of execute some things and then inside that main function it calls another function inside that other function it calls another function and so on and so forth. The way that works is that every time you call a function, it's going to push and push and push those functions onto a stack. Um, so this is like a stack just recording like you know how deep into the function calls you, you bed, and this I guess is not somewhat different than many other programming languages, uh, in terms of how they, they operate, um. But the important point is that JavaScript is, you know, I mean, sort of, well, it's not entirely nowadays, but you know, in general you could think of it as, as being single threaded. So what does this mean? It means that like if you are executing and calling functions and calling functions you can't until you like could finish that that function and then popped it off the stack. You can't then go on to the next code and so on and so forth, um. So So it's single threaded in that way so you would think in that sense it would not be able to kind of uh facilitate this kind of asynchronous uh kind of model that I was just talking about where the program just keeps running and doesn't halt while it's waiting for some response from something else um. But it's able to do that because it has another uh thing called the message queue, uh, here. But before I, you know, go into that, I'll just say that there's also I mean in in the JavaScript model there's also a heap so the heap is kind of like a, um, just where the memory objects are, are held like vari you know, various variables and so on like that, um. So, so in addition to sort of the stack, you also have this message queue and so this is a list of messages that it's like weed that are waiting to be processed um so I talked about callback functions well, so a callback function is a function that you have sort of passed into maybe some other, uh, function as a parameter. You know, like those arrow functions and it's something that you want to execute once some process is completed. So for example, I make a network request. I'm waiting for the response and the response comes back, I wanna do something with the data. I wanna update some of my view or something like that and so. The message queue is actually the place where these callback functions uh get placed um so the way it works is that as you're executing your code, uh, you kind of are going through, you're adding functions to the stack they finish executing, they pop them off and so on and so forth and so in a JavaScript engine at any point. Um, it's always going to be executing the thing on the stack, but as soon as the stack empties out, it takes a look at what's in the front of the queue. Is there anything in the queue? If there is, it takes that from the queue and pops it onto the stack and starts to execute that. Uh, so the, the engine kind of combines together the stack and the queue to sort of handle messages as they happen. So what this means is that if you have like a call back, so like the example that I had before, let me just. This is a very simple callback. In this timeout function. So this time out. Has a callback function, this anonymous function here. So what's happening in the event loop is that you call it's in this function outer functions on the on the uh stack, um, it calls set time out which is um basically uh a function that's going to take this, this, um. Uh, callback function and it's going to put it into, uh, it's basically gonna hold on to it and then once the 1000 milliseconds, sorry, 1000 milliseconds, uh, uh, finishes, it's going to put this function onto like into the back of the event queue. When it gets to the stack emptying out, the event queue will will push that on the stack and then it will actually execute this. So what this means is that this operation, um, sort of. Well, I mean JavaScript will wait until sort of it's finished other things it sees that it's it's available to run something else it says oh there's this, there's this function that's ready to call it will execute it. What this also means is that this call back doesn't occur exactly at 1000 milliseconds. It just means that it happens at the very least, um. 1000 milliseconds from when it, when the callback was first executed, but there's no guarantee that there are other things in the event queue that kind of sit in front of it that need to be handled, for example. So, um, So this is sort of the event loop, it's kind of doing this, this stuff, um. And uh. Yeah, oh, sorry, I had the example here, but yeah, so essentially this is what's happening. So, so this actually illustrates it even better because in this case it's calling a set time out, but in this case the, the, the delay is 0. 0, milliseconds, so you would expect that in this case, um, if you were to execute this, I mean just looking at kind of the meaning of this code, what does it say? It says set a time out for 0 milliseconds and print out the string first and then print out the string second. Like that's what you would I mean intuitively that's what you would think would happen here, right? But in reality, this is what happens is that because you're inside of this function and this function is on the stack. Here it, it basically, um, you know, when you do set time out it will maybe add this anonymous function to the back of the queue, but meanwhile you're still inside of the function that you're executing and it's still on the stack so it's gonna print to the console second. Then once that finishes and it's in some kind of state where it doesn't have anything else in the stack, it's gonna say, oh look, we have this, this in the, in the event queue. I will pull that off and I'm gonna print first. So this code here, even though it says I'm only gonna wait 0 milliseconds and print first, it's actually gonna print second then first. Does that make sense? Yeah, um. So this is like the a key to sort of I mean it's it's it it it's kind of interesting because um even though this is like a somewhat simple structure uh this works really quite well um for handling a lot of concurrent operations um because it turns out especially. With any kind of like networked interactions or um or like user interface kind of interactions there's actually a lot of dead space you know time wise in the CPU cycles so it can clear out the stack fast and then and then pull things off the queue and you as a user don't really notice that you know uh the way way things are happening um. But, um, yeah, so. There's, here's a code example um that kind of goes through it in in more detail um. Let me see. I don't really have, uh, the time. So I think maybe in your own time, you can do this. Like, what you can do is you can go into, uh, a browser even, or any kind of JavaScript, um, kind of playground, but let me just show you here. Um, Just Right. So, so here I am. I've just gone to example.com. Because it's a nice thing. You can ignore these things. These are actually errors that are due to my Chrome extensions I happen to have in there. Um, but essentially if you want, you can just type code in here like you in Chrome, all you do is you go to, um, in the menu, you just go to developer tools and open that up, um, and it's there. Uh, the other browsers have a similar sort of thing, um, but you can try just kind of like, you know, just typing in code like console. Dot log, you know. Yeah, something like this, um. Yeah, so, so basically you could run through and and run this, uh, these operations and test them out as you want, but. Or you could like cut and paste the whole thing in and run it as as a block. Uh, but what you'll see is this is a, this example here, um, basically shows a little bit about the event cue and how it works, um. By defining different, you know, functions, and it sets intervals. So intervals are things that execute regularly uh like upon every interval, so. This would be like calling this, this ping, uh, function every 500 milliseconds. Uh, this one will say hi after, uh, you know, 1 2nd, so on. So you can test it out and play around with a little and just make sure you. The behaviors is how you would expect it to be, uh, for that. Um, so there's, um, I'll just end with this, um, so. I showed this is not just another picture um that I found somewhere of the similar thing and you have the stack, you have the heap and you have the event queue so that's the same sorts of things but in reality I mean you might be asking what's actually putting things in the queue, right? Like you didn't see that in the picture, uh, the reality is that this is the JavaScript run time. But you also have a number of, uh, basically the browser creates a number of API functions that you can use and things like set time out is one of those API functions. It's not in the core JavaScript run time and so, so that's actually what's these external functions are what are kind of, you know, actually putting things into the event loop as needed. This video is really great actually if you, if you wanna see kind of a visual kind of uh step by step run through how the event loop works, um, I highly recommend it. All right. uh, thanks everybody. And so in the labs, you'll be kind of digging more into all of this stuff.

SPEAKER 0
Uh, see you then. OK. I. Alright. Thank you. I'm pretty sure that's yeah. Yeah I think. You and Mr. President. I like aha. Uh. well Yeah. I. I. I. Um. Yes. Yeah Yeah. Yeah. Yeah. I So Thank the whole. Yes. Oh.


SPEAKER 0
That part of the. Yeah. OK. Yes. I Yeah. So Yeah So much.

SPEAKER 1
All right, hello, everyone. So, um, any questions about anything before I start the lecture today? Hopefully you have, uh, started going through lab 2 at this, at this point. I ran the script, um, just again today to see if anybody had. Uh, any needed, uh, I get repo set up almost all of you have it now, um, so hopefully you should be able to log into Iki and see there's a, uh, 365 2025 group and in there there should be a, a repository that has your user ID. So if you don't see it, uh, send us an email, talk to lab tutors, uh, we'll make sure you get set up for that. So any questions about anything I've talked about so far or or anything in the in the labs? No, OK, so, um. I'm, uh, kind of tracking a little bit behind if you're following the lecture slides, I'm, I'm still finishing up some slides from week two. It's fine. There's a little bit of padding in there, so, uh, we're OK with that. Um, so at the end of last week. I had talked about some things around JavaScript and you know how it worked as a language and uh the thing that I talked about at the very end was this idea of the event loop so we have an event loop, um. That uh runs in the JavaScript engine and so this is what uh basically allows for asynchronous programming to happen so it allows essentially for functions that have to be called back at a later point once some condition or some event occurs. So, for example, you make a network request, uh, for some information or a piece of data. Once that data gets sent back over the network back to your, um, browser, then at some point you need to update the view of your application and so. This is all facilitated with the um with the event loop and so the event loop is something that exists uh you know whether or not you're working on the back end, uh, working in no JS which is what we're gonna be using for the API and or whether you're working on like front end, uh, uh, web, uh, programming. So With this idea of the event loop, um, so then we now can start to talk a little bit about what is asynchronous programming actually look like in JavaScript, um, and so I'm gonna introduce this concept of the of call back hell. It's not a very technical term, but it's one that I think, uh, you'll find again and again and it's, um, and it has a kind of a. Another concept that goes along with that, which is called the pyramid of doom. And so I'm gonna introduce what that is. Um, so actually let me make this, sorry, it's not full screen. All right. So let's just imagine that we. Want to write some JavaScript code and in that code you, you have your program it's like running along it's taking in requests it's maybe handling information from the user, so on and so forth, but at some point you want to make a database query, so. To make a database query, uh, effectively what you need to do is you need to open up a connection to the database server. You need to send it the request, and then you need to sit there and wait for the response to come back. So you maybe have your SQL query and you wanna do something with the result, um, and so, uh, you can do that, um. Using a thing called promises, so promises are essentially functions that are, um, uh, they're, they're functions that are promised to complete at some point in the future, um, so what this means is that, um, you know, if. If you have a a function that wants to request the database um and you are waiting for the information, that function call should return a promise and that promise says OK once this has completed acting, then I promise that you're going to do this, take this action or or do something in the future so. Um, If you don't use promises, um, then you have to end up writing code that looks a bit like, uh, this, so. Um So in this code you've got this database object, um, we, we call get pools, that's basically it's just some existing object that's the database, uh, connection, um, and we're going to execute the query function and then the query function just takes some SQL. So this is going to be some code that is essentially just clearing off a bunch of tables in my database. So I wanna maybe, uh, delete the bid table, the photo table, the auction table, and so on. So, maybe this is like a, You know, a TradeMe or eBay style, um, auction, a website, and you wanna just clear out the data. So in order to do this, you would maybe set up a series of drop statements where you want to delete one after another after another. Um, and so you only want to do this, you only wanna drop one table what's, um, you know, the preceding table has been dropped in some specified order. So in our case we wanna drop bid first, then photo, then auction, and so on and so forth, um, if. When you call the query uh function here, you send it to the SQL that you want to send, and then the second parameter here is a function, uh, that should be, should execute on the result. So once you're, once, uh, you know, all of the, you know, you get back the results like a success, um, then you want to do something or, you know, if it's an error, you want to. You know, maybe um. Exit out of this. But what ends up happening here is that you see here this function here is actually this large function. It goes all the way down to here and it encapsulates this whole thing. So if you want to drop the bid table, then. You call this this function once you get the result. If the function is an error, you're just gonna return. Otherwise you can log out that you've dropped the bid table and now you can go on to drop the photo table next and so on and so forth and da da da da. So as I'm sure you can imagine, this code is probably not the ideal way to write a program, um, it's a bit kind of like a nest gigantic nested if statement. Uh, but even worse, um, because it's, uh, modifying things with your database, uh, you know, it could break out halfway through and at that point, you know. Uh, you could get into a situation where things are half, half deleted, half not deleted, and so on and so forth, but this structure is, as you can see, it's called the Pyramid of doom because it's a way you, you basically have to build some big nested structure to try to deal with all of these as turn all of this kind of asynchronous stuff into something that's going to operate in a some kind of synchronous manner essentially um. So, um, Before we talk about how you can kind of get around this or patterns for that, um, let's think about like why this happens in a more general sense I've given an example of uh for the uh you know for a database um but in general. Anytime that you have an API that you're making requests to, um, you know, like, you know, maybe your API that you're developing, uh, for assignment one. There is the chance that depending on how you've defined the API it might under fetch data, so the API as it was designed was not actually designed to provide all the information that you need in one request and so you actually have to make multiple requests, um, so this tends to happen over time also as kind of the API gets kind of out of sync with sort of. The needs of the front, excuse me, the front end application and so then you get into a situation where, where you, you might be like have to make one request, uh, follow it up with a second request based on the, on the results of the first one. So that's just an example here. Say you've got some API where you want to get the student information, the classes they've taken, whatever, so you might make a call to get a list of the IDs. So, you then select one of the IDs and then you make a subsequent API call to get the list of courses, and then another one, maybe to get information about those courses, because they're all in different tables. Now, you can imagine you could kind of construct. Some big SQL query that solved this problem, but, but as you can see there are all kinds of situations where conceivably you need to like sort of um make some kind of uh request to an API. Uh, based on some kind of intermediate information that you have, um, and each time you need to kind of, you know, know how to make the call if the call was successful or not, handle the error gracefully and so on and so forth, so. Um, in this kind of situation, you know, naturally if you build your code the way that I showed on the previous site, you're gonna get into this pyramid of, uh, uh, hell kind of period of doom, sorry, uh, situation, and then, you know, it's, it's not great, um, so what can we do about that? So Basically, What we, what we need to do conceptually is we need to take all of these asynchronous things that are happening. And figure out how to like in a concise way sort of characterize them or or describe them as synchronous operations in our code um so that we can kind of build up some kind of synchronous uh you know, step by step thing where only one thing happens, uh, once the previous one has, has, uh, completed and so on and so forth and so we do that using promises so all the promises is it's it's actually an object so it's a type of object that um. That we have, uh, in you know in provided in, in JavaScript and it's basically an object that kind of describes whether something is deferred or or it's like waiting to be completed and when it has in fact finished, um, happened. Um, so you can kind of use them to, to mix together synchronous and asynchronous, um, operations with each other so that, you know, for example, you can say I need a couple of different asynchronous things to happen, but all of that, all of that computation together I don't want that to block the rest of my program running. I still want my program to be operating, um, so. So a promise is. Uh, meant to be uh operation that has not yet completed, um, and so it has 3 states, it can be pending, so, um, so this would be like if it's, if it's pending and you expected to finish in the future, um, then it's just waiting to be completed then. If it's not pending. That it has been resolved, and when it's resolved, it's in one of two stages. It's either fulfilled or it's rejected. Um, so that's pretty self-explanatory. If it's fulfilled, it completed successfully, if it rejected, um, it means it failed. So This is a kind of a diagram of what a promise, the states of a promise, um, so. When you first create a promise object, um. It will be in a pending state and so uh at some point later it's going to either go into it's gonna either be fulfilled or it's going to be rejected. So on that fulfilled rejected promise you can then call the then method THEN. And so the then, uh, if it's, if it's fulfilled and you call then, then it will, um, uh. You pass in a callback function that is sort of the function that we want to execute once that promise has been fulfilled, um, and so. Uh, and, um, if you want, then it can also be, um, return that that fulfillment can return a new promise. So in effect you can create kind of a chain of promises and say I want this, then this, then this, then this, and so on and so forth so you can chain together these these functions like that. Um, if it, if at some 0.1 of those promises is rejected, then you can either, um, call, uh, then on it or you can uh call catch. So catch will just handle the error, uh, hand will do the error handling. So depending on what you wanna do, so like if for example if if there's an error, maybe you just wanna to short circuit the whole operation right and handle the error, um, if it's um. If it's, uh, in other cases, you might just handle the error but then continue on in, in the chain, in which case then you would use like a then statement. So there's kind of a, so these objects, um, then, you know, allow us to describe these, uh, executions that are either pending or fulfilled. Um, and so. Like I already started to describe, you can chain the promises together so we talked about function chaining before, which was that idea where it recurrence like a this and it, you know, you can chain chain, uh, methods. Well, chaining promises is it's uh it's the same idea. So you can, uh, sort of call a function that returns a promise, call, uh, then. And, and you know it will be either fulfilled or rejected, um, and then it could, uh, go into. Another method that returns a promise to another and another, um, and so like as you can see here it's saying that you can you can chain sort of dependent on a various asynchronous operations so so those data database queries you could do like query then query then query then query like that that kind of uh structure. Um, so then we get, you get code that sort of reads right left to right and more like a natural sentence, um, and each of those, uh, promises returns another promise, um. So at any point, if you have like a rejection, then you can catch it, um, or you can call then and and then, uh, you can take do nothing with the error if you want and just do the next call back. It's, it's sort, you know, whatever, whatever you want to do, um. So that looks OK, um, it looks better, but then there's uh an uh a even better kind of, um, way of handling, uh, promises in the code that you write, uh, that, that makes the code look even simpler and and tighter, um, and all this is is a form of syntactic sugar, um, by that I mean it's, it doesn't actually change, add anything new over problem. as they already exist, um, but it's a way of using some language, new language features in JavaScript to describe, uh, functions that will automatically wrap functions and promises. Um, and so that's called the async await, uh, syntax. So. Um, So, if you see a function like with this uh structure, where instead of defining it with the function keyword, you add the async keyword in front. Um, Then what you're saying is you're telling, telling the the JavaScript uh interpreter that in fact this function here, this function doesn't have a return value this it's just a void, basically a void return value, um, but in fact what you're saying is that this function F returns a promise uh object instead um oh sorry I'm. I, I shouldn't say it's void. It is actually returning a number, so it's returning a, uh, a one so it's returns like a number value, um, if it's a function. So if you just describe the function after it returned 1, that would be the immediate return value if you add a sync in front of it, basically what it's saying is it's going to um send back a promise object. And that promise upon being fulfilled will uh have the result of one so. The as sync function when you call F like kind of parentheses, like if you were to set a variable equal that what you're gonna get back is the return value is a promise object you're not going to get the number one, In order to, to sort of get pull that out that pull that number one out of your return value, you need to take the promise that you've gotten, call then on it. And then and and then the callback function in this case we're using one of those arrow arrow functions is going to take the result and uh log it, uh, log it, um, out. So, um, sorry, this should have um. I think that's a type of this should have a result in here. I should accept. Um, as a, as a parameter, um, because otherwise it doesn't know what result is here. But the point is, is that you, you, when you call, um, when you, when you call then only at that point do you get access to the, the internal value. The, the async the this when you have this keyword, it won't execute the function immediately when you, when you call it. So here's a um. Example of this, um. So, maybe I will just talk, uh, through it. Um, I could also show it, um, there, there's actually a JS fiddle if you want to look at this. This should still, this link should work if you want to, um, Let me just see if it's Sorry, I didn't. Actually, I'm gonna pull it up on the in the browser, so it's easier to see in person. Um, Yeah, OK, cool Uh So JS Fiddle is just one of these many, there's many websites where you can just enter in your, your, your JavaScript and play around with it and see what, what happens. Um, but. What's happening here is. Let me just walk you through the code so you can see. So it says, um, we want to log start. We're gonna define a function G that takes some input, uh, and it just increments the input. So this is a normal function. um, so. If we If we were to say I want like a function to equal G, so remember we can assign functions to other variables. If we were to log that, then what we're gonna get logged out is essentially a some kind of log of what the actual function is. It doesn't, you know, it isn't been executed, it's the function object itself. If we want to execute the function, then we call it so. Like the result of G2. And then we call GF 2. Oh, can you, can you see that OK? I mean, I know it's a bit um. Sorry, I don't know if I can turn the light down a little bit. Um Oh, actually, it was already down. Um, So So this is saying, uh, write out the result of GF 2 is, and then it calls the function and passes in. So that we would expect it to be 3, right? So you see. The result of GF 2 is 3. That's all good. Now, uh. Sorry, if I could make this uh. Light That'll be better. Can you see that better? Is that better? OK, sorry about that. Um, that's much better. OK, so. So we have, uh, you know, a normal function. And it behaves kind of like we've talked about before. Now, we have, we take the same function, we're going to call it F. It's exactly the same as G, it behaves in the same way, but we add the async keyword in front of it. Um, now, if we say let another function equals F. And we log it, then what we end up with is this thing. Um, so this is just a, a logging of the, um, It's just a shorthand representation of the of the promise object that was, uh, returned. So, so this function is returning now a promise object, uh, if we call FF2. Oh, sorry, I'm It's not the problem subject, it's the, it's the function, and then we call FF 2, just like we call GF 2. And that result is the promise. So this is a, a promise object that's being returned, uh, from, from the, uh, by calling it here. Um, in order to actually access the result itself, then we need to call the function like F of 10 to do then, so we're, we're waiting for this promise object, um, to that gets returned from F of 10 to fulfill. It will fulfill almost immediately, right, because there's nothing else happening and then we call this callback function that takes the result and. Logs it out. So then at that point, we get, um, you know, the result of F is 11. So that would be what we expect, right? Oh, So Hopefully that makes sense. Is there any, is that confusing to anybody or, I mean. Um, so if it is, um, you know, just play around with a little bit, it should be, you know. It it's basically you just need to think about that the functions are no longer immediately returning but they're just returning something that they're they're returning this object that says I'm gonna complete in the future. Now this is kind of a toy example and you think why the heck would you add all of this, but just imagine that instead of a function that's going to return an input inside of this function, it makes us, uh, a database query. And it's waiting for the result to come back and when the result comes back, um, it returns that so essentially you then have a promise, um, that of the result from the from the database query and at that point then you can handle it only after the result has actually come back from the database, right? So we're gonna use this, uh, a lot, um, in, in code that, that you do. I mean, basically any JavaScript code you do. Anywhere, you're gonna have to be dealing with this notion. Um, so, So along with a sync then there's another keyword called the weight and so weight is a way basically it forces that asynchrons code to to um become synchronous, right? So, so if you, um, say in, in this example here, if I said. A weight, you know, let, let X equal a weight F of 10. Um, then at that point, uh, it's basically going to just wait for that to be fulfilled and automatically unwrap the promise, um. And put the value in. So, so a weight is basically a way to take something that's asynchronous and make it um. Make it synchronous. But it, there's a, there's a key thing, and that is that you can only use a weight inside of an async function. It you're not allowed to use it outside because then that would basically freeze up your whole application, right? So you can have, you can have a synchronous functions that themselves return promises but inside of them use the await keyword to like block for a series of things to become synchronous. So in that example with the database query where I said where we had that kind of pyramid of doom thing, you could just do a bunch of await statements if you wanted in that in that case, right? Uh, so, That it's, it has to be done this way, otherwise you are essentially seizing up and locking your entire program if that makes sense. All right. So that's, uh, the sink away, um, now, I guess I should just point out that, you know, in a way, a sync away does kind of, um, Hide what's going on with promises. If you want, you can also. Like explicitly return promises from your functions you can create a new promise object as your return value, um, and, uh, you could, you know, handle it that way without using the same sync and away keywords and there are some people who claim that this is. Clearer and more transparent, but I think by and large like this succinct and we, uh, keyword usage has really become very popular because it just makes it allows you to write code in a much more concise way and it's what we use in the labs. So if you've been doing it in the labs, you will see it already, um. Any questions about this before I move on? No. OK. So a few other things that I want to talk about about JavaScript before I kind of move into the, the next thing which is actually we we step from JavaScript up to TypeScript and then we go into um other topics entirely other than JavaScript to TypeScript, um. So, um, One thing, uh, that, um, is something that, that you kind of will become aware of like as you developing with JavaScript is that. You need some way to manage uh modules and by modules I mean like individual JavaScript files will have, you can think of each one of those as as a as an independent module and of course you declare variables inside of those and those uh variables, you know, maybe a function that you want to make available to another one. So the key thing to be aware of is that it can be quite it can be different um kind of the the way that you access modules and you, you, um, essentially, uh, share library code, uh, depending on whether you're working in OGS, depending on whether you're in like a web environment and also if you're like, um. Uh, uh, like a few. Using different kinds of package, uh, um, managers can also lead to differences, um, so, so I just wanna hit on this a little bit. I mean, you're gonna see how it's done essentially in the labs or you have probably already, um, but I, I just want to point on like give you a little bit of like a grounding on it, um. So if you want like modular JavaScript files, you know, where you wanna be able to share things but not have everything be like global variables, um, then you need some kind of specification. So. So common JS is a specification that's um the one that is used in no JS um so if you're looking at things, there are sometimes you'll find other specifications for handling modules, um, and so if when you when you first generate a project. Uh, like you, you didn't actually, uh, do this, uh, because you started with a skeleton project, but you know, if you were to generate a project, there's all kinds of ways you can configure your project, including things like how you want, you know, what kinds of, uh, specification you wanna do for handling module dependencies and so on and so forth, but no JS adopts this common JS format. But it's not the same as the one that's used on the front end. um, if you wanna use that the same sort of way of, of, um. Uh, kind of Sharing modules that you need to use some uh some kind of tool that will kind of modify your your your package from a Node JS format into a browser format and so there's different tools like browserFI is one of them uh but there there are other ones, um. But the bottom line is that uh modules, you know, this is, this is also an area that's that's often changing so if you learn something, you know, in a couple of years you'll find there's there's new. New specifications, so it's the kind of thing you got to keep up on, um, over time, but the bottom line is that like you could think of a module as a single JavaScript file, so a file with like a dot JS whatever and then you. Can you basically decide how you want to export your, um, you know, what you want to export to other files like for example in your file system or to other code that might be importing your code as a library and so. You use the keyword module. The exports or exports um to uh to sort of say this is sort of my public interface to my code so maybe you have a lot of functions but you only want allow a few of the functions to be available um to to be exported so. Um, So if you assign them to this module that exports, it's basically an object, right? If you assign them to them, uh, then they're part of the public interface and then other, other, um. Uh, other JavaScript files can use the require, um, uh, command. To import them, um, so you wanna expose something, you add it to module exports, and then you can import it using require as a way to to to pull it in. There's examples of this in the, I mean, you, you already see it inside the code, so you, you already see examples um of how this is done, how you, how you, how you access, for example, um, some part of your model code. Uh, by, um, you know, maybe the routes and other, other parts of the code that, that's in your, in the skeleton project already has, has a way of sharing, um. Uh, values, uh, within, you know, from a module to the other, um. So So you could just create your own modules, um, you know, that's just like a module.js and then you have like module. exports, um, and then you put whatever in there. If you want to reuse the module and something else, then like if it's in the same. If it's in the same um. Uh, like directory structure, so you just want to go up a few, uh, you know, a few directories, then you would just kind of, you can actually import something this way like you create a new something variable, require, uh, module JS and then at that point. That that something basically is the value of this exports objects. So then if there were multiple functions in there, you could do something. that function, something. function too, so on and so forth, right? Um. Uh, so, That's just so you're aware, you can see how this is done in the code. Um, the other thing is that, um, in. When it comes to managing your your project, usually you're you know, almost always right, you're not writing just a pure application with just some JavaScript, um, that has no other imports or or other sorts of things, um, and so usually what you're doing is some you're using some kind of package manager um so MPM is the default package manager for node. JS, it's not by by no means is it the only one. There's many different package managers uh out there, um, and, you know, you'll see uh things like fight and, um, you know, other ones, so. There's lots of different ways to kind of import packages into your, into your project. Um, MPM was designed to be, you know, specific, but, you know. Since, so another example would be like Dino is a is another one that is is completely different from from uh MPM I'm working with with no JS. So, so there's lots of different options out there, but essentially what what way it works is that you know there are publicly available packages that you can install so I will show you the. Um, So MPM has a um. Package, uh, repositories. Let me just see. My Wi Fi is certainly not. Working Like if you go here to MPMPMJS.com, you can basically search through and there's heaps and heaps of different, uh, packages. So let me just Maybe there's cryptography, um, yeah, so if you needed like some cryptography tools you can search through and there's, there's literally thousands upon thousands of packages out there. So normally the way it works is that you know you just like PIP or something like that with Python, you're you're writing your program and you're installing, uh, packages, um, and. In your code here. Like Like MPM install will kind of automatically um sort of install that into your into the project and there's a file called package.JSO that collects all of those in there um and so then when you use that you can use this kind of common JS like dependency to import um uh new new functions directly from these, these libraries, um. So, uh. You will start to kind of, I mean, you will be using MPM and all of these things and. lab, so, so you'll see that, um, so, um, you know, for example here if you want to install a module that's in there, any of these ones that are, you know, in the. Existing then you install it and what will happen is MPM will download it from their online repository and it will actually put the source code inside of your packages folder so that when it cut, you know, when it bundles up your, your, your code, um, when it builds it, it's actually, you know, pulling the code, uh, directly from the library into your kind of like. Not compiled, but like your JavaScript, you know, bundle, uh, that is, is nicely packaged up. Um, so, you know, it's exactly the same. The key difference is that you don't put an explicit path. And like if you want to require a module within your file system, of course, everything's kind of based on your source directory and you'll find something that you've created, uh, but if you don't have a path in there, um, it's going to. You know, that's how you would access one of your, your modules that you've installed from MPM. Makes sense. Um, All right, so that, um, kind of rounds out most of what I wanted to talk about, about JavaScript in particular. I do want to now shift over to TypeScript because TypeScript, you will, I mean, you're already getting a view of it in in the labs, but TypeScript, I, I want, I wanted to introduce JavaScript initially because underlying everything is the JavaScript is the language and then TypeScript kind of sits on top of that as a way to kind of essentially modernize, uh, JavaScript a bit, um. So, let me. Just bear with me a moment. I'll open up. And I'm I'm gonna hopefully go through this pretty quickly because I think it's pretty straightforward, um, and then we can move on to the next, uh, topic. Sorry. All right. So, yes, so I'm gonna, I'm gonna do rather quick overview type script, um. I would expect that you kind of you're gonna have some experience working with TypeScript in the labs um if you're wondering sort of what what do you need to know for exam I mean basically you need to understand how the typing system works, um, you know, and, and some of the basic concepts that I'm, uh, covering here as well, which for in all practical sense you're you're gonna be interfacing with some of those. As your program anyways, but, um, you know, I would expect you to kind of understand, you know, the principles, um. Uh, behind it, so. So I'm gonna talk about TypeScript and then I'm gonna move on to data persistence really starting, uh, tomorrow. So, sorry, I'm just kidding. All right. So TypeScript. So, so we've got seen JavaScript and so we look at that and JavaScript is, although it's been modernized over time, it has really nice features like arrow functions and so on and so forth. It is also, um. In some ways it's not a great language um because it doesn't have strong typing, um, and, uh, it doesn't, you know, it's, it's easy to write code, uh, that has sort of undefined behavior or behave in ways that you might not think like you could set, you know, strings equal to integers and you know, set, you know. Uh, use, uh, put a string in a in an if statement and all kinds of crazy stuff and it just will do something but you might not do what you expect, but it will, um, it has very odd sort of notation or uh sort of an odd way of working with things like nulls and undefined values that are not necessarily, um, consistent. So because of this, um, Microsoft, uh, decided at a certain point that they were gonna try to clear that up. And so internally they developed, uh, TypeScript, but then it became just a general, um, language that was developed more, more, more widely. So the TypeScript handbook is here, um, heaps of really good information on there just like the other links. I, I highly encourage you to just kind of look through it. But bottomly I mean the bottom line is that there's a few really key issues, uh, that JavaScript has, uh, that TypeScript is meant to kind of, um. Fix. So problems with uh JavaScript is that it's dynamically typed. So for example, you can create a variable container, set it equal to a string hello, and then reassign it to 43. That's totally legitimate, right? Um, And so when it there are times when this kind of variables will be coerced into another type and it but it doesn't always happen in any kind of way that you would kind of uh really. Like expect or that is predictable really as for you as a programmer, um, and so this makes it hard for IDE support, uh, but then if you wanna like dig a lot deeper I mean there's things around like no values for example that are very, very strange and these are kind of weird historical things to do with how the compiler was built, um, and you know feel free to like this is just one really. If you're into this kind of thing, it's quite interesting, but it's a, it's a, um, you know, a bit of a, a dive into sort of what's going on with null values but take a look at these conditions here. um, this will actually, I mean. You know, if you, if you run some JavaScript code and you say what is no greater than 0, it's false. If you say no it's equal to 0, you say it's false, but if you're saying no is greater than equal to 0, it's true. That is pretty wild, right? Like I mean if you think about it, like how, how can that be possible? It's like internally inconsistent. So, um, so because of this, people were just like this is not good, we need to like do something, um, and. You know, part of that was to come up with new ECA script versions that were better, um, but then, you know, the versions are not always supported the same with browsers and so on, so. Incomes type script, as I said, it was developed by Microsoft. They had the goal create uh safer web code. It is in all senses a super set of JavaScript. So what that means is that all JavaScript code is typescript, um, and on top of it it adds certain features so it's statically typed. This means that you know the variables are either a number or a string they're not both um it does do type inference, um, you know, based on. Like if you, if you set a value equal to a number, it will infer that it's a, it's a number. But then it can never become a strain, things like that so this makes IDE support way better, um, you know, you can't act IDEs really depend on being able to understand the syntax and structure of a language in order to do things like code completion, all these other sorts of things, right? Um, it also adds strict null checking, um, which is, uh, you know, basically the idea that you can, you know, it things can, you know. Oh, Things are either null or they're not. Um, it doesn't try to equate null with zero and other sorts of crazy stuff, um. So TypeScript files are just like JavaScript files except they have a TS extension instead of a JS and because TypeScript is a super set of JavaScript, all you need to do to make a TypeScript is to change its extension from JS to TS and you you're done. But the opposite is obviously not true. um, you can't make a typescript file a JavaScript file, um. So, uh, the static typing, I mean this is what you might come to expect from modern languages, um, so it has certain primitives like boolean number, big in, which is, uh, like a number above 2 to 53 or whatever. Something like that, but it's essentially an unbounded large, uh, integer number, um. Uh, sort of like Python can have arbitrary large, uh, integers, um, strings, arrays. T T poles, um, you know, so a twopo, you know, it's like a pair or a triple, right, of different types, um, as objects, null and undefined then are are are basic types, but it adds some new ones. So, uh, it has enum, so an enumerated type. Unknown any so so it's because you're dealing with uh a language that went from some taking. Uh, you know, not, not being statically typed at all, like sometimes you might want to have, uh, be able to say, oh, well this parameter is any type, um, and then you would then have to have some way in your code to test the type of it, um, but the point is, is that you can do that and it simply is either any or it's, it's a specific type. Um, so the, the important thing is that it's not like this changes anything of how the program actually. Uh, runs, it's just that it's used basically like what is valid, what you're allowed to do becomes kind of restricted. So the compiler does the type checking, right? Um, and. If it fails, then it won't be able to compile your typescript. Whereas in if it was JavaScript, it just would, right? Uh, and so types can be either explicit or implicit. So you don't need to explicitly say it's like a string or a, or a number. All right, I'm running out of time, so I'll just end with this real quick. Uh, so yeah, so this is just sort of how what it looks like you define your, your type. Uh, you still use the let keyword, but then you, you defer these types like this, right? Um, So yeah, I'll, I'll end there and I'll just, uh, do a finish up my quick, uh, type script introduction and then we'll move on tomorrow into, uh, some more information about how we persist data and for that I really wanna highlight sort of some other things other than my SQL or SQL databases because you're kind of already familiar with that with, uh, COSC 265. All right, cool. Any quick questions before we break? Nope. All right.

SPEAKER 0
Thanks everyone. I. Yeah. the I. It OK. They. Yeah out. Thanks thanks guys. Uh, there will be a. I tell you I appreciate it. OK, yeah, so a callback is just a function. So, so the way it works is that, um, when you call several, like say you call a function, um, like that time out function so it's, it's a function called set time out and so that function is, um, takes as a parameter. Uh, a, a function as it's, as a parameter.

SPEAKER 1
And some time out, so like 1000 milliseconds or something like that. So that function that's the parameter is the thing that's the callback function. So what it means is it's the function that gets executed or called back once something has finished or has has completed. So in the timeout, what happens is the timeout. It's behind the scenes, there's a web API inside the browser, um, and it. Will take that function that you've passed as a parameter. That's the thing that you want to execute when everything is ready. And it sits there and it waits for the time, like the 1000 milliseconds and and then it pushes them into the event queue that your callback function that you define gets pushed into.

SPEAKER 0
So it becomes then a function that we need to execute at some point. So then as your programs that jobs moving along, eventually the stack will empty. just. And you like once it's, once everything else has been cleared out and they'll say oh we want to. screen, uh, and it's, and that's what does. Once it executes it, so just think of it as like anytime you have some some kind of operation. Yeah functions.

SPEAKER 1
So make it say I make a request to network.

SPEAKER 0
I Yes, exactly. So it's once you get to, once it's ready. Oh no, no, that's fine. Yeah. Yeah, so, so in that like that's um.


SPEAKER 0
Yeah I.

SPEAKER 1
All right, hey, everybody, uh, welcome. It's gotten cold. Hopefully this isn't the end of summer, but. I fear it might be um. So, uh, OK, I, I thought that before I go back to the slides I had a, a good question at the end where somebody was asking sort of about callback functions and what, what exactly is the callback, um, like what does that mean? And so I thought it would be good to just give a little demo of, you know, some JavaScript and show you. What what a callback actually is and how it behaves just so it's clear what we're talking about uh when we're talking about promises and callbacks and all of these sorts of things um. All right, so before I do that though, um, any questions about anything? OK, I hope the labs are going OK, um, starting. So, next week is still have 2. Uh, but then after that it's working on the, on the project. If for whatever reason you can't access your and you get uh repo, please let me know. I still get a trickle of a few emails about that. Uh, just check to make sure you can, uh, that you have access to it, and if you don't, I can make sure you, you're set up for it. Um All right, so, um. Let's see here. So what I wanted to do was just uh show you so a few simple examples in JavaScript of, you know what callback functions are, how they behave both in just like in the general sense and then like with an asynchronous example um so I am gonna go over here. Um So I'm just gonna use some very simple functions like, like imagine you have a function. Like, where you want to greet. So this is gonna do like a kind of a hello, whatever, um, you know, kind of hello world kind of thing. Um, and it's gonna take us two parameters, uh, a name and a callback. Um, So This function um is essentially designed to take a regular parameter, the name which is gonna be a string, and then the callback is a second parameter and that's going to be a function that you pass in as a parameter. So the, if you recall functions are just objects in JavaScript so we can just pass them around as normal um and so. When we pass it in. To a function with the uh sort of the goal that it's going to be executed once that function is completed, whatever it's gonna do, then we call that a callback function um is this large enough for everybody that or do you want me to make it bigger? It's good you can see it. OK, good. So, um, you know, you could do something with the name like console log. Um, and say hello. A plus name. And then, uh, if we wanted to just in a very simple way, like execute whatever function, the developer decided to pass it as a parameter, then we could just do that. We could just call the call back and execute it, um. This is like very similar to when the examples that I gave were you know we have a function and you set a variable equal to the function you know that's what we're doing here in the parameter we're passing in the function as the object we're not executing it, but we only execute it here at this line, uh, within the function that's that's it's being passed to um. So, uh, Then, you know, if we wanted to, let's just create a a a regular function that's like a callback, um, that says something like, uh, say goodbye. Um, And that one's gonna do console log just goodbye. Hm. All right. So, we just have two functions here, um, and if we want to execute one of them, well, if we just called Say goodbye, it, you know, it would, um, execute as we expect, right? So let's just do that, um, and let's run this oops. And it writes goodbye, it's all good, right? Um, but Let's say we want uh say goodbye to call as soon as greet is finished. Well, we could do something like this, we say greet. Um, Uh, and then Say hello to myself. Um, and I will pass in as the second parameter, uh, say goodbye. So note when I'm passing and say goodbye, I'm passing in the function, but I'm not there's no brackets at the end of it here so I'm, I'm not executing it before I'm not passing in the result of this say goodbye. I mean in this it doesn't return a value, but imagine it returned a value that's not the purpose. um, the purpose is to actually send the function object in yep.

SPEAKER 2
Are they any different like function pointers in C?

SPEAKER 1
Uh, are they different to function pointers and see, um. Uh, they are, um, they're close conceptually to function pointers and see, but, um, if you recall, uh, when I talked about functions, there's a, there's notion of a closure, so, um, what you're actually passing in is not only. The function like a pointer to the function, but also the some a data structure that has um the. Uh, context, uh, uh, where this function was first declared, um, so that means it will have access to other global variables that are not in the function. So strictly speaking it's different, um, behind the scenes, but I guess conceptually it's similar to that. That's a great question. Any other? Questions. All right, so, if I do this, um, I'll just clear this. And I run it, then it does what it basically does is it goes integrate it says hello Ben, and then it executes my callback function, which is say goodbye and that logs goodbye. So that's good. So let's just do another example of this, but do it in a way that simulates a synchronous programming because that's sort of where you're gonna be using callbacks more often. Um, so I'm just gonna. Delete this or or maybe I'll just uh in case you want. I don't know if anybody wants to copy it down. Uh All right, so, um. In this case, uh, let's create a function that takes a call back and I'm just gonna simulate like. Make it a network request and it takes some time. So I'm gonna use the timeout function to to pretend like it's doing something. Um, so, let's create a function. Fetch data. And so that just takes us a parameter, the callback function, um. And we're gonna use that set timeout function that I, I showed in the um in the lecture slides uh a little while back and so set time out, um, takes two parameters it itself has a, um, has a call back, uh, and a, um, and a time that you want to delay, so, um. I'm just gonna use an arrow function for that, um, something like this. And say The the function that I want to sort of execute when the timeout is completed, uh, will, uh. Maybe it logs something. Uh, like data received. Um, and then it will execute the call back. Like that. And then let's just simulate that it's doing it for 5 seconds, right. Um, So you can imagine this could be like a network request or something like that um that handles. You know, it takes 5 seconds, something like that. Uh, so, let's say our callback is going to be like our data processing function. Um, so let's just create that, uh, function. Process data. Oops. Um And just we'll just have it right to the console as well. Some like that. Um, So now we can call fetch data. And like, basically, we're pretending like we're going off to fetch some data and we're gonna wait 5 seconds. And once that's done, uh, we fetch the data, we now want to process it. So we'll pass process data in as the callback function, uh, for fetch data. Um, And let's uh log here. Like, as, as soon as we call fetch data, we wanna log that we, we sent the data request. Here Um, So basically what's happening is we're we're calling fetch data passing in the callback function, the process data once fetch data has completed its thing, um, and then we move on to, uh, logging, uh, the sent data request, um. So What happens is this it immediately. Passes like fetch data like gets called um and fetch data just calls set time out and finishes like almost immediately, right? uh and then it goes on and executes set data request so I'll just do that again so immediately writes set data request and meanwhile. Uh, you have set time out, um, is waiting 5 seconds, and 5 seconds comes back, and then it writes the data received and then it executes, uh, the callback. Um. So yeah, I mean, that's basically what we mean by a callback function is when you're passing in. You know, a parameter, the function as a parameter, um, and it's usually executed at the end of, you know, whatever, whatever you're, you're doing. And so when, in this case, like, set time out is actually not a function that is um Designed like you, you have to, you'd have to do something to make it work with the A sync and um the weight, uh, keywords, but effectively like this could be also like an asynchronous function and so then when the promise, um, instead could be like instead of like passing the call back in as a direct parameter, you would do something like if it was an async function, you'd do something dot then and then. It's in the then method that you pass the callback function, uh, but it's still a callback. Um, it's just a slightly different in that case, it's, it's sort of as the promise is resolved, it will then execute the callback. So hopefully, um, that makes sense, uh, and I think once you start working with, you know, doing the labs and stuff, um, and you start to program a bit more. Uh, you'll get just, it'll become more natural, uh, to you, but do I have any questions about, about this concept and how it works? Oh, OK.

SPEAKER 3
Oh yeah, OK. How would you actually pass the data to the callback, like is there a way to.

SPEAKER 1
Well, yeah, I mean, so basically you could have something like. Data and then if this called I don't know I don't know like some data got passed in so essentially you're you're, you know, depending on sort of what you're doing so like if you're making a network request, you know, probably the return for that it's gonna include some data field um and so in that you would have access to it so you could do whatever you wanted with it, uh, and then you could, um. You know, your function would just take that as a parameter. Yeah. It's a good question. Yeah, so I mean, maybe just to show you, yeah, be like this, plus. If we ran that, um. Yeah, so it's just processing data and then it gets to the 100 and it includes it. So it'd be something similar to that that, um, but it would actually, I mean, you know, for all when we get to, you know, the making the network requests from the front end and so on like that, you'll see there's just a standard like, uh, data fields and you can access them and, uh, you know, do what you want. Yeah, just kind of asynchronous. Yeah, so the so the timeout function is one of these web API functions, um, so yes, it is, it's asynchronous in the sense that it sits outside of the engine and it what it happens is you call the function and then the browser takes, yeah, I mean, it takes whatever the function is and holds on to it and once, um, the time out, the browser has, has gone through its time out, it will push this function here that you passed it to the end of that event queue. Uh, so then it's ready to kind of be, be kind of picked up, um, but it's not using, so, so yes, it is asynchronous, but it doesn't use promises, um, I guess is the, is the distinction. There's no, there's no promises in here, it's just a web API that is, um. Just is there's some time out, you know, running in the browser and it will, it knows to push it into the event queue. Um, with promises, uh, you Um, I mean, you can kind of wrap set time out in a promise, there's like a way to do that if you wanted to to do that, um, but. It's just not designed that way, that makes sense. All right, cool, great, um. OK, so hopefully that clarifies uh a little bit, uh, for some of you might have had some questions about that. Um So Let me find my Slides. Alright, uh, so when I finished last time. I was just uh doing my quick kind of uh overview of type script. I figure if you're probably getting an introduction in the labs already, um, so that's good uh but essentially it's, it's like JavaScript but it's a super set where you have things like um uh static, uh, typing and so you know you have all your standard types um they're they're a little bit different than maybe things in some other like it's, it's not like instant floats are like really a thing in the way um that they are in uh something like Java. Um, it, they just have a number type. Uh, and so those number types can be, you know, in different, in sort of different formats, but they do distinguish between the number type and the big in. So the big in is sort of like a number that's, uh, arbitrarily large, um, uh, like an integer number that's arbitrarily large, uh, as opposed to, uh, like a number, uh, which, um. Uh, can, uh, you know, has, uh. Uh Oh, So, you know, has like, uh, these different like formats and so on, but it's limited essentially to like, I think something on the order of 2 to 53 or something, some number in there. Um, it's because like, it has to include like some floating point numbers. So it's not, even though it's like, you know, 64 bit, um, the actual highest integer number is somewhere around 253. Uh, so, um, and then there's string types. Strings can have double quotes, single quotes, that's all good. Um. And then they, they add in, I mean, you, you can, you can use kind of different kind of constructions for the same thing. Uh, so, uh, like an array type, uh, can either be declared this way as like a number with the square brackets, um, or you can use the array type with this kind of, uh, typing, uh, notations. So these two things are equivalent, um. In type script, um, and then typescripts add some additional types on top like enumerated types like, um, you know, we have a color type and the color could be red, green, or blue. So it's basically, I mean, under the hood it's probably integers, um, you know, in the memory as a representation, but then, you know, your variable can only take these three values color. green, color.red, doc.blue, um. So Enumerated types are very handy, you know, when you want to constrain sort of, you know, something that has a very set number of possible values. Um. Uh, so. With functions, um, you know, you can. Uh, you know, like, you know, in, in, in JavaScript it does all kinds of type coercion, all this kind of stuff, and as you can see like even an example I was just giving, you know, I don't, I didn't give any typing to any of the parameters, right? So as a result, you know, you could really pass anything, um, and the interpreter just does it on the fly. And it will try to coerce as it as it sees fit, but then this, you know, leads to all kinds of crazy stuff, um, you know, where the developers thinking one way, but then they, you know, forget to pass an integer in for a string and whatnot, and the compiler won't give them an error, um, and so, but with TypeScript, uh, you know, you can do type annotation, so like a string, um, parameter, uh, for name. Uh, and then once you do that, then you're only, then you can only call specific kinds of uh functions, um, on, on that type, you know, like two uppercases defined for string, but not for other types. Um, but also, you would get, um, You'll get errors, you know, like if you, uh, try to, uh, compile, uh, you know, 42 in here, the problem, you know, you have here it's like if you, if you just did this in JavaScript, you wouldn't, you know, it would, um, maybe. Like it would try to, it would, it would at a run time it would find there's no two uppercase for my number type, you know, and basically would just, you know, throw up an error but in TypeScri it'll do it at the compile time so that's good, right? So you know you can't pass in 42 here because there's no two upper case defined for that, um. So, uh by default, like, it's a void type on return, like this right here, uh, but otherwise, you can declare kind of a, a type on the return value as well, um, for functions and that kind of thing. Um, So, uh, TypeScri uses this thing called duck typing, um, and it comes from the notion that if it, you know, if it walks like a duck and it sounds like a duck, then it's a duck, right? Um, I don't know if you know the saying, but, you know, essentially duck typing is this idea that you can kind of refer to types with different forms as long as they kind of are end up being the same thing, right? So. So for example, um. Here we have we we have a function degree and and for that we pass in a person as a parameter, but we're expecting person to be an object that has a name and an has name and age fields where the name is a string and the age is a number, um, so we have a, you know, a. Um, you know, kind of an anonymous type here for a type of object that we defined, but you can also define types, um, using, uh, keywords like interface. So interface is a way of declaring that you want to create a person type, um, and that person type, you know, has a name and an age, you know, with string and number, um, so you can, uh, just as easily kind of pass in. Like with a with a person like this that you've defined, and these two things are completely equivalent, right? Um, they're so equivalent in fact that you don't, that it will actually compile like if you. So, although you have to have the typing correct, if like, you have function to find agree uh to find this way, but then you declare a person type. And pass it in, it will compile fine because it says because the compiler knows that those two things are the same. They're both objects that have a name, uh, at an age where the name is a string and an age is a number. So that's the duck typing is that it doesn't, you know, even if you have, if you have like two types, they might have, you know, but they have the same shape, then they're essentially equivalent from as far as the compiler is concerned. Um, when you declare interfaces, you can also do, um. You know, there's, there's better kind of null safety, uh, checking, uh, in type scripts so you can make properties either, well, you can make them optional first of all by putting a question mark here or you can, uh, declare them as possibly, uh, a number or, uh, no, but in this case, if you put the question mark of the property here, you're basically saying persons, um, like like if you added a question mark here under age. Then that means that it would kind of the duck typing would match with either objects that have a name and an age or objects that only have a name, right? Um, both of those things would be the equivalent uh to a person type. Uh, so, uh. So interfaces are kind of like your standard way of sort of describing an object that just has like flat properties, um, you know, like a name or ID and age, those kinds of things. But you can also create classes, um. So where the class, uh, is, um. Uh You know, essentially, um. Like has um. You know, different, like things like a constructor and and functions defined for it. So what I'm showing here is actually quite an interesting example of of how duct typing works. So. If you have an interface, it's a user. So, the user has a name and an ID and the name is a string and the ID is a number. Uh, here, uh, we are defining a new class called user account, but if you notice the, it has, um, according to the rules of duct typing, it has the exact same shape as as the user. So it has a name as a string and an ID as a number. The only difference is the class has this constructor, um, where it basically sets this name to past in name and ID this. ID to the ID. But the bottom line is the underlying like data is the same. Um, so, because the data model is the same, you can do something like this. You can call the constructor on the user account. And you would think, you would think in this case, it's a class called user account, so you're creating a user account type, right? Not a user type, uh, but this is perfectly valid. You can declare that the user is a user type and then set it equal to a new user account. So it's a little bit, um, so even though it has kind of static typing. You have to be aware that you can use this kind of this duct taping means that things, um. That it it basically looks at the shape of the of the data types and declares and figures out whether or not they're they're equivalent. Um, so interfaces, if you don't have like methods, uh, classes, if you wanna have functions, that sort of thing, I might be using classes, um, especially when we get to the react site a lot, um, but, um, there is another, uh, keyword apart from interface that's type, um, the key difference between. The interfaces and types is that, uh, types just cannot be extended, um, so there's if you look at that link you'll read more about it if you, if you wish but you know, you'll sometimes see people use type instead of interface or you know vice versa, but the bottom line is it just has to do with whether or not you can extend it um in sort of like an object oriented, uh, way. Um So, uh, Just a few other things, uh, nice features, um, is that there is the notion of unions, so. You know, if say you did create a. Say, say you, you don't want your parameter to only be valid with 11 type, um, then you can use the union this type, uh, symbol to do, you know, say I want it to be one or the other. So, uh, for example, here is just prints the ID and it's a number or a string, essentially you can think about it that way, and the code that you've written is valid for either because console. log, I mean. Actually, not console log per se, but this string, uh, the string, uh, addition mechanism, where you do string plus some other variable, is both valid for strings and numbers. Yeah. Uh, well, the type of the variable that you pass in is either going to be a number or a string. It's not going to be both, right?

SPEAKER 2
I've just seen single In the context of a general

SPEAKER 1
Oh yeah yeah yeah I mean I guess I would just think, yeah, it's um it's more like a set union kind of operation, but I can, I see what you're saying, yeah, um, but I mean it's, uh, it's just that you know a variable is either like like numbers and strings are sort of inherently exclusive right? um, but I suppose if it, you know, if you could think about it that if the types were, um, overlapping in some way. But it could be both, uh, conceivably, but yes, um, yeah, it's, it's uh it's essentially, um, saying that the set of possible types is the union of numbers, uh, and string, um. But yeah, it does look like an or uh there, um. So, so when you do this, like in, if this is OK then to, to pass in the two different types, and type scripts like compiles just fine, like you pass in a number or string and it works. But it will still throw an error if you throw something completely different, um, like uh this object type, uh, that just won't work, right? Uh, so you can create union types that are like um. They don't just need to be, so, so these are data types like numbers and strings, uh, but it can be based on individual values. So you could basically say, maybe, maybe window states, the only three values that are possible are these three strings, right? Uh, so, uh, if you just passed a generic string in, uh, it would not work. You would have to, you would have to pass in something that is a of window states type, not string, that makes sense. Um, so you can, you can declare types, uh, like this, and, and this is all just a way to kind of. Sort of constraining your code and its behavior, uh, so that it, it works kind of in a, in a way that Is predictable, essentially. Oh. OK. So Say you have a union, but then you need to actually differentiate your code based on which type you've selected. Well, then you can use this type of uh keyword. And so basically type of converts the, you know, it's uh. It basically gives a string representation of the type. Of the variable. Um, so in this case, I'm saying if the type of the ID equals string, it will do something it will, it can call to upper case, otherwise it will, it will, it must be a number and therefore it does this. And so, so the, the typescript compiler will be able to kind of parse this and know that this. This call to ID to uppercase is only valid in the case that the type of the IDs of a string, therefore, it won't have the same kind of error that we had before, um, where you tried to pass a number in, um, and called to uppercase. Um, so you can, you know, build kind of conditions into your code if you need to have different kinds of behavior based on different types. Um So another thing is that um It, um, Has very strict uh null checking so what this means is that um you know if you declare a variable to have a type, it's not it's not automatically nullable um you have to allow it to be uh uh nullable so, um, in, in JavaScript that means that like you might have a variable that's undefined, um, we have that und defines an actual value, um, and so. Here, if you try to set some number X to undefined, you'll get a compilation error. So you actually have to uh do something like say it's either a number or it's undefined. It's that union operator. Um, and if, uh, and then you can do something like this, you know, check if that it doesn't equal undefined and do some math operation that's valid. But if you just did this without the if statement, you will actually fail the compilation, um, it will work, um. So you're, you're incrementing X, but um it could very well be that X is undefined and undefined plus 1 is not defined. Um So those are just sort of, I mean it's a pretty quick overview but you know obviously you'll get a chance you'll you'll be programming in TypeScri um you know for the labs and for the assignment so I'm sure you'll you'll come up to speed on using it. um, they, uh, and you can start by looking at things like, you know, I mean the labs obviously have, you know, examples of it, um, and it's the same with the skeleton project you can look at the code there, um. But if you have questions, you know, feel free to ask here, um, you know, in the lecture or or in the, in the labs about about the language or how it's behaving or if something's not making sense to you, um, just, just let me know, um. They so. So that's all great, but you know, actually nothing like none of these um environments, these JavaScript uh engines I've been talking about like uh the ones in the browsers or the one in OJS, none of these things actually execute. Uh, type script natively, right? They have, they only execute JavaScript, so what has to happen is you need to. Uh, compile, uh, the typescript or it's actually trans pile I guess into from, from TypeScri into JavaScript. Um, and so when you generate a new project, um, like in OJS for example, uh. If um you need to add in, you know, the, the uh the typescript uh package uh so that it knows how to compile it into that, uh, we'll talk a bit more on the front end too I mean we start with the skeleton projects which is helpful, um, so you're not actually, you know, use fully using the the package, uh, managers. Um, but you know, there's different ways to sort of package up your code and, and, and normally what you have to do is set it up in such a way. That, um, you know, all the rules are there to clearly convert your typescript like into some version of JavaScript slash ECMA script, uh, which is then bundled together, um, and then executed, you know, in, in your, uh, whichever environment you're looking at either on the browser or on the back end, um. So, um, So yeah, that's, that's more or less, uh, well, OK, maybe I, I, one other thing I do want to say about text script, so. The other thing is that um because uh like we talked about modules um with JavaScript and the idea that a module is just a JavaScript file where you export, you know, sort of the interface to your module so you might export constants or functions out of one JavaScript file that you can then, uh, you know, use in another one. So we use that module's export, um. Uh, to call to say I want to export those things, um, when, uh. Like, like, in order for, for ideas to kind of all work with this and, and make it handy is that normally, um, and this is all managed by the package manager so you're not actually doing this, uh, uh, so much but um, generally speaking you. You need some sort of like export uh that sort of like because it compiles everything down to JavaScript, it still needs to kind of expose what's the typing for everything that you are exporting so that somebody else writing your study some type script that's using your type script that was then compiled into JavaScript still like all of that kind of typing information propagates through to your typescript, um, right. Uh, and so When this is done, the way this is done is that there's a adopt a TS file that's added to the package, um, that just defines sort of like the types. So like if you were to say you had like a constant, uh, Number and a function and you wanted to export those for other people to use if you were to then compile this down to JavaScript, um, it would, you know, create the kind of bundled JavaScript that you can use, but then it would also um add in this extra file this.D.TS file, um, that declares, you know, the actual typing, um. So you'll see, um, for example, this array is not actually defined as an array of a particular. A big killer type of array. What I mean is by the elements are typed, uh, so it's just an array of any, um, and it automatically infers that it's returning a number. Uh, type. So, so this, um. This is all like partly I guess why I you'd be aware of this this this like if you set up your package, uh, manager to, uh, and bundler to work with TypeScript, normally speaking if you generate your project with one of these, um, scripts that does that for you, all of this is kind of set up, um, nicely, uh, but occasionally, especially with older, um, JavaScript packages, you'll find that they don't actually. Have um. Like they, they won't have this.D.TS file because they were just pure JavaScript, um, libraries that were written. So you might be over here writing some typescript and you want to. Like it doesn't know the typings, uh, that are coming. So if you actually wanna like buying and and and know what the the typings are for, for like, you know, the parameters and the return values and that sort of thing, you might have to add a.d. TS file to kind of map that in or or something like that. So this is, these are this kind of gnarly things that you come up against when you start start to like mix something like typescript with some older. Uh, uh, JavaScript, um, packages that are maybe not as maintained or other sorts of things um. So, just so you're aware of that. So the, the point where you start to look at it, you know, in the code is you look at this, you look into the package and you, you find this TS file. If it's not there, you might need to create it or something like that. Uh OK, um, yeah, so. That's more or less it for uh type script, um. See, I'm already know about 10 minutes left, so I'll just, uh. Well, I guess any questions on TypeScript before I move on. I don't wanna move on unless there's. There's any questions. OK, um, so. The next phase of topics that I wanna talk about like we've we've covered. I mean we spent quite a few uh a bit of time now doing like JavaScript type script and before that we looked at HTTP which was, you know, how you know just the how we simply send requests and get responses from a server, um, and so that's all kind of like, uh, foundation between the client and the server in our reference model that we had, um, but. Um, another big piece of the web applications that we build, obviously is, well, first of all we have to deal with the data still that's getting kind of transferred between the client and the server and like what is the form of that data and what I mean by that is not like the HTTP uh request and responses but what goes in that body of of the message, uh, right, um, so for that, um. More often than not, um, we're using a standard called JSON. however, there's actually newer ones, um, that are, are also. But like improvements on JSON, but JSON is really, it's what we use in the in the. Uh, you know, for the assignments and the labs, and it's, it's really kind of, you know, pervasive all over the web. So this is, it's like a serialization format for sending data back and forth, um, but then obviously we within, you know, the work that you're doing, um, you also have a database, right? I see you have a relational database it's got some tables, it's got some, you know, different kinds of columns and rows, and all of that data stores the back end, excuse me, the back end state of the application like in the, um. The back end for for all the state like that is not held on the client side. And for that we're using relational databases which because you will have taken COC 265 and you'll be, you know, familiar with that. But in fact relational databases have also been replaced by many other kinds of of data storage uh methods, uh, that like we variously I mean you can kind of lump them all together in in this label of no SQL and so I wanted to, you know, present those for you because I wanna, you know, even though like we're focusing on some technologies in the assignments in the labs, there's um it's a much bigger kind of picture on in terms of web programming and what what people are using. Um, so the purpose of the lectures to kind of, I guess, expand beyond what we're doing in, in the assignments in that regard. So, So first off, uh, a little bit about Jason, um, so. Uh, so there's a few different books actually and links, uh, for, for learning about, about this stuff, um. Kind of just kind of tools to to play around with it but but JSON was sort of designed um as a it's basically like an a way of taking objects that the data fields of objects and serializing them in a kind of a in a consistent way, um, and the original intention was really to allow for interoperability between Java. And JavaScript. um, so the idea is that you create some kind of intermediate serialization format and you create these tools that can kind of read those in and map those to object types, uh, in the various languages, so like JavaScript or Java. And so So that's JSON is the serialization and it comes with this sort of other conceptOO and whatOO just stands for is plain old JavaScript objects, highly technical terminology, but the plain old JavaScript objects just means objects that are, um, really just, um, sort of like key value pairs, um, so, so what I what I mean is like uh. Like objects that don't have methods, right, they're just, um, something it's akin to like a dictionary in in Python, right? So the idea is that you know all those data fields, um, map with with kind of standard JavaScript, um, field data type fields map into some standard, uh, JSON uh serialization, um. Uh So, It just has um. It's kind of a semi-formal, uh, definition. So it's, so the whole point is it's, it's meant to be about data interchange. So you, you got, you want some format that, you know, lots of other. Services, programs written in different languages can consume and put into their own kind of, uh, representation. Uh, so it has a syntax for serializing the data, um, so that means like taking things like objects, arrays, numbers, and strings, all these types that kind of we're looking at just now, uh, and mapping them into a well-known structure. Um, there, this, uh, link has the reference if you want to look at the actual spec, uh, you know, of it, um, but bottom line is it. Even if you look at the format it's a little bit kind of you could you could kind of say it's it's human friendly uh in the way that it's somewhat kind of readable, uh, for humans but ultimately it's only um it's only designed to store data so a JSO document. That does not support comments in any way. Really the only way you could have comments is if you had something like a string field in your object and called it like comment and had it, uh, you know, had the string there but you don't, you can't have things that aren't data in in the thing. So it's really a data interchange format for the machines to send information, uh, even and even though it is kind of human readable, it's not, it's not, it's intention is not to be kind of like documentation, um. But it's not specific at all to JavaScript. um, so yeah, like I said, it's intended for interchange originally between Java and JavaScript, but it's used all over the place now. So it kind of is a syntax um that you know you can you can look into it um it's it's it's honestly not that complex um to to work out um but there are just a few things to be aware of because JSON is not the same as writing JavaScript they're actually different uh syntax, um, so for example, um. If you have like a key, so imagine you're so you use kind of the curly braces, um, and then you have different keys, colon value comma key, colon value that that kind of uh structure that looks very similar to just declaring an object in in uh in JavaScript, uh, but, uh, the keys themselves are all strings, so they're double quoted and strings are always double quoted so unlike in JavaScript where you can use single quotes or double quotes, all that. And Jay on it, it, it has to be a double quote. Um, and then there's, you just kind of use these special characters that you would normally say to escape. So like you do backslash quote if you want to do that. Um. So numbers are very specific, um, like, you know, it either it either has a decimal. And it has, you know, one or more trailing digits or it has no, so no decimals, but you can't do like 27. Like that, um. And in general it it so it can capture sort of data like numbers and strings and all these standard kind of forms, but it you cannot, um, I mean you don't, you don't serialize like the methods or the functions or something, you know, like for example if you're making a class, it's only the data fields themselves that converted into JSO um, so I'm, I'm included these links just because, um, it's, you know, and sometimes, you know. It's easiest to learn these things just by doing and looking, you know, so you start to use some JSON and you just, um, you know, look at the format and, and there's like here and also back, sorry. This link this, uh, JSO to JS.com, uh, tools you can see that there's there's little tools to like play around with with JSON and see whether it's properly formatted and whatnot, um, so I just think these links to sort of, you know, give you some. You know, basically a a reference point for that. Um, so, so Jason, I, I mean, I think you'll, you will. Probably, you know, just get you, you'll see it in the examples in the in the labs and so on. I mean it's, it's fairly, uh, straightforward, but the point is, is that JSON is the format that you will be putting the like the data in the bodies of all of your requests, um, and your responses when there is data to be sent with the one exception of when you're sending images back and forth apart from the images you're gonna be using JSON all the time. And what's really nice is because JSON is so like kind of well known, there's like ready-made functions that just parse the JSON of the data, uh, directly into a, uh, JavaScript object, uh, that you can use, um. So I think, I think that will become clear. I mean, I don't wanna going through it in the lecture and the labs will probably be a lot more instructive, uh, for you about, about all this, um, so, um, so JSON is the data that we're sending back forth and so you know what happens is, you know, you make your request and generally speaking, uh, you know, you're just sending data with your HTTP request and it's gonna be put in the body. And and then sometimes the responses will also have JSON, in which case when you do your front end, you're gonna parse the JSON that's coming back into the relevant fields and and data, um, you could, I mean JSON is obviously not the only thing so it used to be that everything was XML. um XML is very verbose markup language. Um, I mean, HTML kind of looks like XML in a way, um, but XML is, is. Sort of fallen by the wayside for sending just regular data back and forth um. But there's also binary formats now, uh, like Protobuff and, and so on that we're not really gonna get into, but, you know, if you start to explore further into web programming, uh, you might find. Um, so you've got your data going back, you know, back and forth, and that's with the JSON, uh, data. Oh, I'm running out of time here. So I'll just, I'll just end with this slide. So, What we'll talk about next though is this side over here um so. Obviously we're using a MySQL database, um, and you have learned about relational databases so far, but there's this whole heap of other options out there now, um, including key value stores, memory stores, graph databases, and so on and so forth. So my plan next time is just to go through those, kind of do a survey of those, talk about the pros and cons and how they relate to the relational model, because there are some key differences uh between those. All right, we can finish there. Uh thanks everyone.

SPEAKER 0
Yeah No. I That Hey.

SPEAKER 1
Um just a few questions. So, um, this week and next week is yeah, that's right, yeah.

SPEAKER 0
Um, it usually can take that long to, well, it's

SPEAKER 1
a long lab, so but some people look through it

SPEAKER 0
quickly. I, I'm not, I can't really say how long it's gonna take but we found that.

SPEAKER 1
I mean, it used to be two different labs, but

SPEAKER 0
we just switched the ginormous labs, so we said. Typically, how long does the talk? How 00, I don't know. I mean, I, I guess, uh, what I would say is that, uh, I mean, I think you know the time frame. it's it's not so much I think. Is the. Oh. Yeah But. You. Oh. Yeah, I'm if you go to the that I think by all means.


SPEAKER 0
Like Ross. I I So Yeah. I I. I the Are you, are you playing chicken. Algo Yeah OK I'd just like to point out. But. Uh And. So.

SPEAKER 1
Right, uh, hi everyone. um, so I guess any questions before I start? Nope. OK, so we're um into. Week 4 and uh you're gonna be starting in on the assignment uh relatively soon. um, so I wanted to start today just by going over a few items about the assignment, um, that would be helpful. I know I've gotten a couple of emails from people actually saying they've they've started already, which is, uh, great, but, um. As I've said before, it's, it's best not to wait until the last week. Um, there's a fair bit of stuff to implement, um, and so what I wanted to do was, I mean, once you finish lab 2 you'll get some, some experience working with, uh, you know, using express to handle, um, routes and so on and so forth, but, um, I wanna give you like a heads up on, you know, how to start approaching the. Assignment, um, in terms of like the skeleton that's provided to you and you know where to go next, um, and I'll come back around to this again next week. um, I'll have a few more items, but I wanna wait until more people are actually into it, uh, before I go into a few more of those details and my apologies, I, um, I had a cold over the weekend, so, um, I'll do my best not to cough too much, um. So, uh, the. All of you should, uh, have access, uh, to a repository. If you don't, of course, please let me know, um, and I can make sure that you have access, um, but if you go into I it, you should have something, uh, that looks something like this, um, so. In this, I mean, on, on learn there's a little bit of information about what you're going to develop, uh, but, uh, a lot of the, the actual content of what end points you're gonna be developing are gonna be here inside of, uh, the repository. So, um, there's a lot of information in the reading just for how to get things running. Uh, you know, just how to set up your, your database and so on and so forth, and there is information on the learn page also for how to access the database off campus if you, if you need to, um, but, uh, you know, you need to do a little bit of extra step to kind of tunnel into the into the network, um, so you need to set up your EMV file and so on. So basically what you're gonna be doing. Uh, in terms of the assignment is to be developing a number of endpoints for your API. So those are, you know, When I was showing your HTTP request back in in week one, you know, that's the URL and the end point is a particular kind of, uh, basically pattern of, of the URL that you need to to implement. um, every time you make an HTTP, uh, or somebody makes an HTTP request to your, uh, API, um, you're gonna be sending a response and your response needs to have, um. Certain, uh, status codes, uh, depending on the specification. Um, so. Uh, you know, some of the common ones that you will have, I mean, are are are some of these, so like. If you, uh, have a request, uh, that is completed successfully, um, like a get request to get the games in your game review site, um, then if you get the list of games successfully, it should return a 200 status code, um. If you are doing something to kind of create a new item, like a post request to create a new game, uh, then you will want to use, um, 201 or or created status code. All of this is detailed in the specification. I'm gonna show you in a moment, but I just want to give you a little bit of an overview. And then you might have a various 400 level codes that you will use when there's errors and the requests being made to the API. So like, um, so if you recall 400 level status codes are the ones that are client errors, so it means somebody's making an API, uh, request, but they have done something wrong. They've left out a parameter that they are required to have, um, something to that effect, um. So an example might be the 400 bad request status code. Um, and so this could be like, if you've tried to create a game. Um, using a post, uh, request, but you didn't include anything in the body. Um, If you're trying to take any action, uh, that requires, uh, authorization, you know, basically, a user that has, that can be logged into the system, uh, then you should return a 401 unauthorized error. Um, There's a forbidden errors, so, uh, that's a 403 error, um, and that would be, for example, when you're trying to create a game, uh, that's using an existing name that's a forbidden action, uh, send back a 403 status code. Um, and then a 404, that's the status code that I'm sure you've seen around on the internet before. It's the error code that, uh, websites will often give if you can't find, uh, a web page that you're looking for. Well, it, it basically is this code for any time that something is not found. So, um, in our case, for example, in trying to find information about a game that doesn't exist, like, for example, the game if you're searching on the game ID, the game ID doesn't exist, uh, you would get a 404, um. So inside of the code, uh, the structure is somewhat similar to to lab 2, but, uh, you have in your source, uh, folder, uh, in your app here you've got uh routes. So routes are basically the routes that are going to be where you define all of the, uh, end points, um. So, for example, in your user routes. Uh, you will have something like your, your registering, logging, log out, that kind of thing. So you can see the routes here are already defined for you, uh, and then you will, um, Uh, it basically depending on the route, so each of your different end points that you have, um, it should call a particular method, uh, in this case, like if you do a post request, uh, user's register, it should call the user uh register controller, which is found here if you see import uh star from user that. Um, register function should be inside the controller's user controller, uh, directories. So if you go to controllers, uh, user controller, and you can see here, and you can see we've basically given you a lot of the like foundation to get started. Um, so, uh, for example, register is defined here. This is that function that we're talking about. Um, and it's an asynchronous function that takes a request and a response, um, and right now it's just not implemented, so you're gonna have to fill in all of the code there. One thing to keep in mind is that we've put everything inside of tri-catch blocks, um. What this means is that if you get an error, like something happens in the back end, like I don't know, like an error with the database and it throws an exception, uh, it should, uh, return a 500 level error out, um, this internal server error. Um, this helps us, so it's important to kind of make sure that you put your code inside of these tribe blocks, um, because if you don't. As when we're testing. If something throws an exception, but it bubbles up and crashes the server, then the all subsequent tests fail, right? So what we want to do is we want to be able to catch the error. So just make sure that you put your, your code inside of this tri block. I mean, we've kind of given it to you already, um, so hopefully it's pretty straightforward, but just make sure you, you put it in the tri block so that if something happens, uh, that throws an error that's not captured otherwise, uh, it's not going to, um, basically crash the entire test suite. Um, otherwise, then we have to go in and we have to try to debug your code and figure out what's, what's going on and, and so on and so forth, um. So you're gonna be developing a bunch of the controllers and most of these controllers are going to uh. Go in And, uh, have some model code in there. That, so the model, uh, uh, is where you put the actual code that, um, will execute the SQL queries, um, to, to the database. Um. So, so that's the basic structure. I mean, given you kind of the, the outline and so you're gonna be developing. Out, sort of each of these, you know, different routes, these are your, you know, these are your various end points that you have to implement. Um, so any questions about this? OK. So, so this is sort of, you know, we've given you that outline. Um, now, if you go back to the, uh, main. Uh, folder. We have a test suite that you can use Bruno to run tests against your code, um. So this is not the full test suite that we will use when we assess your your code because it doesn't cover everything that's in the spec, um, you should feel free to add more tests if you like, um, but if you pass these tests, um, that are in the test suite, then you're probably on your way to getting a good, a good grade. Um, So Uh, storage folder is where the images is where you're gonna be storing images when they get uploaded, um. And so then that brings us around to the actual spec that you need to implement. So the spec is sort of like the, the ground truth of like what it is that you have to implement and what, what your API is, how it's supposed to behave. Um, so, what I recommend doing is you can just download this file API spec. YAL. Like, if you open it, you can see it's like this YAML file. But that's, that's sort of readable. Um, but what I recommend doing is going to this website. Editor. swagger.io. Yeah, right, and it's it's actually um. Already loaded, but you can. You can import a file. Uh, and if I were to, um. Thought I had it in my downloads, uh, API spec. If you upload, and do it like that, then you basically get a nice, uh, sort of browsable way of looking at all of the different endpoints that you're supposed to implement. So these backdoor endpoints. You don't wanna touch those. Those are already implemented. Those are, those are sort of end points that we've created that allow you to, um, basically just, um, you know, clear the database and reset it and so on. So don't touch those at all because we actually use those in the tests to kind of reset the tests, um, it's very important that you don't, but you can use them to. Uh, so, here, like, reset will reset the database to its original structure. Um, reloading will reload a sample of the data into the database. Uh, if you do reload, it does a reset and resample. You can actually execute arbitrary SQL statements as well. Of course this is a horrendous, uh, security risk and you would never do this in a real API, but this is just so you can develop, um. So all of the ones that you're meant to do are these kind of end points here. So like a user's register and you can open up each one of them, it will define sort of, it'll have some rules about, um, you know, sort of validation uh rules. So sorry, it's kind of small for you, but, um, like it says um. If you're registering a new user, the email must be syntactically valid, so it has to have an at symbol, um, and a top-level domain. So it looked like at x@y.z. Um. And, uh, it has to be a headdress that's not in use. So basically, you should check if it's in the database already. If it is, it should return a 403 error, so it tells you here and the password that when you register has to be at least 6 characters. So if it's less than 6 characters, you should also throw an error. So in here you can see, um, it describes sort of what the body should look like. So, uh, in your request you have some JSON, uh, and it describes, you know, it gives an example of what it should look like and it defines all of the return codes that we would expect. So. Um, if it's successful, that is, you register a new user. It should return a 201 code, so that's the status code, um, and it should return the user ID as the field. Um. And then, um, it should, uh, if there's anything wrong with it, um, the request, like it's missing some fields, uh, it should be a bad request. Um, if the email is already in use, it should instead do a 403 error. The 500 errors we don't test on because that's basically something's gone wrong in the back end, um, but, uh, basically anything that it should just throw a 500 error. I mean, it already does that. If you look at the skeleton code in the catch block, it just throws a 500 internal server. Um, so. The important thing is these things, you need to make sure you're matching the code based on the conditions, um, and that the return value is of the right form for what we expect. So if you look through here, there's a lot of endpoints, right, um, so it's, I would recommend. You start by just implementing uh the users and points. I mean, alternately, you can do um some of the, the read-only type ones that are public. So, um, For example, this get games, uh, query, uh, basically, it's a way to get a list of all the games that are uh available. And you know, you can see there's different parameters like the it's supposed to be a capaginated um. Amount, um, so, for example, start index and count. So like pageation is essentially just a way to. You know, request, you know, the 2nd 10 or whatever items in in the list because you, you only need to, uh, select a certain number. Um, so there's different parameters like start index count Q, which is like a query, um, uh, this is a way to sort of do a query that will match on some segment of the title or the description. Um, and how it's defined is that you should create an SQL, uh, query with this kind of format, uh, the like, uh, and then. If you do percent to what that means is that it basically will search in the title and the description for any match, um, for that string, um. And then um You know, there's all these various things like the price and, and so on and so forth. And so this should all match with the, with the SQL um database, uh, items, uh. And sorting and so on. And so here you'll see the responses, um, what it's supposed to look like, and the result that you're supposed to get. Um. So, uh, yeah, I would suggest starting, I mean, the users is probably the, the first thing to start with because once you have the user, um, one then you can basically deal with that you can have logins and, and you can do all the authenticated, uh, queries after that point, um. We'll come back and talk a little bit more about image handling, uh, next week, um. But that's another point that you're probably going to um. Maybe have some questions. Um, but if we go back here, I just wanted just one other thing I wanted to show. Skeleton, um, yeah, so, um. I believe uh. Yeah, no, this is the day. Sorry. Uh, Where Sorry. Um, I want the the back door controllers, yeah, um. Yeah. Sorry. Model specter. Um, Yeah, so you'll see here that the reset database, um. Uh Calls the source app. Resources create database and resample database, these SQL files. Um, so if we go. There, into resources, you'll see them in there. So, this actually defines the the database uh schema that you're gonna use. And if you look at um See all these tables. So for example, user, um, has ID email, first name, last name, so on and so forth, uh, game has ID title description, creation date, creator ID, genre ID, etc. etc. So these are all mapped directly to sort of what the API, if you look at the API spec in those fields, you should see a like a nice mapping, uh, between them. So essentially what you're trying to do is take the. Um, take what's in the API spec and construct the, the, the correct SQL query, um, with on these database tables to get the data or to insert new data as appropriate, um. All right, so any, any questions about this? Yeah, OK. The Yeah.

SPEAKER 0
Uh response a certain code is the message you can.

SPEAKER 1
Uh, no, all right, yeah, so when it comes to that, we're really just checking the response code and the tests. So as long as the, as long as the response code is the right number, it's good, yeah, you don't, you don't need to worry about the string of the message. That's fine. Yeah, um, when it comes to.

SPEAKER 2
Like logging in a user and things, I saw there's something in there about like a a unique token kind of thing. Is there any like.

SPEAKER 1
Oh yeah, well, so I have a, um, the same time as I was gonna cover images I was also gonna do that. I mean, I was thinking I would wait and share that next week because that's when most people are like digging into it and they'll be kind of, they'll make more sense. Uh, there's, there are different ways you can do that, but I just have a recommended way you could do that. So yeah, that's a great question. The other question. OK, um, Hopefully if you complete lab 2, that will help, you know, in in terms of all this, but you know, you, you have all, all the tables and everything, and, and, you know, you should see. Um, see the mapping in there and um. So even though, oops, that's not the one I wanted. So, um, so if you go into the, um. API spec and you you look through there and you have any questions let me know. I actually there is one thing I should highlight about that um so I've had I mentioned this some few people have have started already, um, and there is one. Uh, there's inconsistency actually uh in the. In the spec versus how the how the um. Reference server works. Oh, sorry, I should have mentioned that. So the reference server here, this link here, um. If you um You can basically, um, if you run it locally, you can, you can switch between these, but. This, this server, you can make requests get to test what it, how it should behave. So we have the completed version, and if you go to that link and you make your requests against that link, uh, it should behave like this, uh, spec, um. The one thing that I wanted to highlight, and that is that, um. In the games query here. Uh, there's this one item here, um, and so I'll, I'll try to push the update. Sorry, you probably can't even see that, um. See if this works. So in games, um. There's a price, uh, there's a price field so you can search for games that are less than or equal to a particular price, um, and it says here the default is 0, so that what that means is that if you read the spec as it's written, if you do a query on games but you provide no price field at all. Then it should only give you free games, but that's not actually how we implemented it in the reference server so I think it makes more sense not to behave that way, um, so I'm just gonna push a change to that, um, but I'll, um. I'll push that in so everybody should see that, but I want to make people aware of that. We'll remove that default value of zero and I'll, uh, send it, um. So I'll push that through and then that way the reference server should match with uh with what's in the spec. Oh Alright, any other questions about this? So the the next two weeks are really dedicated for lab support on this. So if you, if you go to the labs and you talk to the tutors, um, they should help with this assignment invariably it gets very busy like right around the due date in the lab. So, um, if you have questions and you go earlier. Like next week or, you know, earlier in the week, or the final week to ask the questions, uh, that's better. Right, right. Of course, some questions only show up at the very last minute when you're trying to finish. Um, all right, so, any other questions about this? OK, so yeah, so just, uh, you know, it looks like maybe a lot, but, you know, once you get the hang of it and kind of get into the. You know, after you've done a few of them, it's just kind of going through and and doing each of the of the end points. Um, All right. Cool. So, oh, I guess the one last thing is that this is the Bruno test suite, um, so you can run these tests, um. Uh, using Bruno, again, and, and there's a number of existing tests in there. So, if you want to make your own, you can, you can do that. All right, um, cool, so. All right, so we've used. Like have the class and that that's cool. That's fine. It's important to kind of go over that, um, so in terms of where we are in the lecture slides, I'm, um, a little bit behind on the timing, but I think it's, it's OK. Um, we'll be able to catch up and make, make up for, for the time on that. Um, so, Let me Right, so last week I. I finished up all the JavaScript and TypeScript stuff, and I started to talk about data, and I talked about JSO data. Um, I think around where I ended I was, um, talking about. You know, how, how in the back end in our, in our particular application we're using an SQL database, but there's actually a whole lot of other, uh, data storage options available to you now. um, so. Uh, just to give context, I mean, I'm assuming everyone here is taking COSC 265, right? So you've all learned about databases, um, you know, kind of the, uh, the relational model and I'd say it's one of the few cases where there was a really clear theoretical contribution, uh, in like kind of academic computer science that led that kind of drove innovation on the industry side. I mean I guess you could argue neural networks that kind of thing are hard one again today that's really doing that where it started and as an academic thing and then and then it got industry kind of followed, um, but it, it's got started as the relational model all the way back in 1970, um. And the idea is that you define all your data as relations, uh, so you've got collections of tables with columns and rows, which are, so that each row is like a two-pole essentially of, um, and each twopo has the identical attributes, right? Um. So you have a unique key per row, uh, and then there's some kind of relational algebra that formally defines, you know, the different operations you can do like intersect and select and and so on and so forth, right? So the relational model was um hugely impactful, um, and led to relational database management systems being used all over the place, um, so. Uh, some of one of the ideas of, of like relational databases is, is this notion of asset, um. And so this is, uh, broken up into 4 different components, um, so the first one is atomicity, um, so it's basically if one part of a transaction fails, the whole transaction fails, uh, there's consistency, so if the database is in a, you know, basically it needs to be consistent before and after, um, some transaction occurs, um. Transactions should be isolated from one another, um, so you don't see the effects of the other during in progress transactions. You know, you can't have two transactions that are, you know. Interfering with each other, uh, and then there's durability that was says that once transactions are committed they're persistent and so this notion of asset was part of what made the relational database sort of so robust as a model, um, for, for, uh, developing databases because you had a certain kind of guarantees on the behavior of of your data uh under certain conditions, right, uh, which is really important. Uh, so, in traditional relational database management systems, these, these like asset properties were. Sort of the main requirement uh for um data handling like it was kind of assumed that these were kind of the golden kind of rule and and this is what you would want to do but then over time this is kind of uh broken down a little bit um and for a few different reasons um so. There's different things that have, have happened, so we're dealing with lots, lots of data and then we also have Moore's law, which is that, um, I'm sure you've all heard of this, the architectures, um, basically changed how we acquire speed in computing. And essentially what that meant is that instead of computers becoming more and more and more uh like more and more fast, you know, in individual kind of computers um that could manage this kind of like as these asset properties we're getting into the situation where where we kind of expand compute by distributing the compute across many different computers and so that's. When you start to distribute data across many different computers, it becomes harder to make certain guarantees about the data and its state, uh, in an application. Um, and so this kind of shift was happening in the 2000s, um, you know, as we got to bigger and bigger like data centers and so on and so forth, and until, um, you know, uh, there was a paper in 2007, uh, by a guy named Stonebreaker who basically said that one size fits all databases are not sufficient. You know, relational databases are really good, are extremely useful in many cases, but there's other kinds of models that we should explore, uh, sort of for different kind of computing environments and different data requirements and so on and so forth. Uh So part of what goes along with this, and this is not like a distributed systems theory course by any means, but I want to just introduce sort of um some of the underlying like theory, uh, that, um, That went behind this and and one of these things, the things that was kind of driving this is that. If as if databases are becoming more distributed, then we're in a kind of a distributed computing environment and there's this um idea of the cap theorem which was proven um about any kind of distributed computing uh system um and basically it said that there's different sorts of um. There's certain attributes that the system can have, but um we if if we have a distributed system, you can only guarantee. Two of these conditions or these these attributes, um, at any given time. So the first of these is consistency. So the idea is that every read receives the most recent data. So every time you read, so for example, I'm gonna read, uh, uh, my information about my user account, it's every time I read that, it's always gonna be the latest piece of that information like, you know, it's my most recent email address, my most recent, you know. Name, whatever, you know. So same, same with like, you can think about any of the other tables that we have in our, in our little example for of course, like games, right? Um, you look all up every time you read some information, it's always going to be the most recent data. Then there's availability which says every read will be guaranteed to get a response, um, and then there's partition tolerance, which is the idea that. If the network goes down, the distributed system, that there's, it will kind of continue in some way. Um. So there there's more, uh, there's more to it. I mean, I just say that here just sort of as a, you know, um. Uh, in terms of like just knowing that it's, it's more complex than this, but the bottom line is that this cap theorem says that when we get into a world where we are where we are, um, dealing with, um. Sorts of, you know, like data distributed on in across, you know, lots of, uh, computers in a network, then we can only, uh, choose either two of the consistency and availability or consistency and partition tolerance or availability and partition tolerance. We can't pick all three. And if you look at what acid is, I mean, it's kind of like around consistency, right? But the problem is that maybe in uh in some cases those other things are more important than consistency, things like availability or partition tolerance might be more important. Um, so that's the bottom line. I mean, I don't, we're not trying to go through and prove the cap theorem here, but the bottom line is that there's, you know, you could, you have to pick two, you know, you can only guarantee two of these things, and it's no longer the case that we always want consistency is like the most important thing, um. So this came around with other ideas. So I mean there was this idea of base so you kind of get it right? You have acid and now you have base. Well base is is sort of a, a different, um, kind of paradigm, um, that kind of gives up a little bit on that, um, consistency side of things. And you can basically make another case. You can build a system that satisfies these a different set of, of attributes. Um, and so what base stands for is the BA is for. Uh, basic availability, so you, you can replicate, uh, data enough that you have some basic availability at all times. There's a notion of soft state, uh, so the idea is that the state changes over time and it will. Uh, it's not, it's got like a hard state. It's like changing, but it changes over time and we got, you know, it will eventually get to a certain state, but it isn't always like in one state or another, uh, and then, so that's the essence that eventual consistency is the e part. So it's the idea that you build a system that's base, it will eventually become consistent. If you wait long enough, and so how long is long enough? Well, it depends, right? That's, um, and eventual consistency happens like in in systems where. Uh, particular, I mean, it's achieved when the data is not changing like frequently. Um, so to give you like a concrete example of this, like. Why, where would we want to use base? Well, um, if for example you're uploading data on your social media feed, it doesn't matter that like other people get the most latest posts or whatever of what you've done. All that matters is that like eventually it gets there, right? Um, uh, it doesn't, it's not like a banking system where it's really important that the transactions happen in a certain order, otherwise, you know, everything can get, uh, messed up. So Here's like, um, an example. So if you wanted to track bank accounts, like if you say you, you, uh, created a user table, uh, and then you created a transaction uh table. So the user table has user IDs, uh, it's a very simple notion of a bank account, you have amount sold, amount bought, um, And a transaction has seller IDs and buyer IDs that map to user IDs, and it'll be some amount, right? Um, So an asset transaction, like if you were to do this, you would need to kind of wrap this together into one single uh transaction with like a beginning and end. So you would say. It should basically fail if this if this fails, the whole thing should revert, right? So you would insert a new transaction with a seller and a buyer and some amount then you would need to update the first user, the seller IDs, uh, user, uh, and increment the amount sold, uh, and then you'd need to, uh. Take the buyer, uh, ID and, uh, increment the amount bought, right? And you need to do all of those things as a single like asset transaction. Um, the base example would be, could be something like this. You'd first insert the transaction and then you would update the, the user amount sold and amount bought uh. And but this changes the, the semantics of what of what the tables actually tell us, right? Work what we claim about the information is no longer that it is like absolutely consistent. At this point, you know, because these things are happening one after another and this there might be other thing you might be making a query in between these in this, in this kind of structure, the most you could say about amount sold and amount bought is that they're estimates, right? They're not the actual value but they're just, they're just estimate so you're not guaranteeing consistency anymore, um, and if you had a failure, then you know this could lead the database to becoming um. Uh, inconsistent. So it just turns out that this kind of base scenario is perfectly fine in all kinds of web type scenarios like you don't need to like have everything be like acid in the way that they um it was, you know, sort of previously conceived like those, like that's all done, you know, to try to. Make sure and sort of mission critical situations where we kind of keep consistency and consistency is paramount but because we're dealing with like massive and massive amounts of data on the web now and the users are generating information uh for all kinds of different uh situations we can. Uh, you know, kind of relax that and kind of move more towards these kind of base attributes and so alongside that then people realize, well, we no longer need to even stick to the relational model then because part of what the, the whole, the whole point of the relational model is that it allows you to sort of in a very formal sense you can kind of um meet these acid attributes uh for your database, right? But if you don't need that anymore, maybe you can use different structures entirely. Uh, and so that was what the big shift happened. So the first, this kind of first started with just key value databases, um, so key value databases. Essentially you could think it's just like unstructured data so there's no, there's no schema, um, to the database. It's not like, um, when you create a table, you know, you need to have your columns with each of your, uh, where you define your types for all of your columns, it's all fixed. Database schema is very kind of rigid in that way. Um, for a key value database, um, you essentially can kind of store stuff that that looks a bit like, um, you know, GSO data, for example, right? It just has fields and values, but there's no predefined schema for it, um, and generally speaking you would. Uh, take like the primary key. That's basically the only way that you would, uh, look up things in a very simple key value database. So you don't have lots of the operations that you get with relational database like aggregation functions or filtering operations. It's just a very simple thing. You just are like pick, you know, getting things by key and uh getting the data. Um, and storing the data, and then there's just very simple operations, um, there are these crud operations that where you can create, read, update, and delete. So you create, you store a new key value pair, is create a read, finds a value for a given key. Update just changes the value of the key and delete removes a key value pair. Um, so There's lots of advantages to using a key value database, um, there's. It's super simple. It's very fast, they can be implemented like if you can just look up things by their, uh, primary key. I mean, so an example of this would be like, uh, I, I, you know, one of, one of the first ones of these that really kind of. Got huge adoption was like the, the databases that were behind how Amazon built their products, uh, stored their storage of of products. They just had simple key value thing key value, uh, databases, and they would just, you know, you if you just need to search the information on a, on a, uh, I mean if you just need to look up, you know, a particular. Item that you're selling and get the information, it's very fast. Um, and it's totally flexible. If you want to add a field, you can just add a new field, um. And it's very scalable and it can be, and it can have high availability. There's lots of disadvantages, you lose a lot of what's in a relational database. So, um, for example, uh, There's not validation on the data, um, that, you know, all the kind of fancy things you can get with the relational database like not no checks, uh, you can even get, you can get weird things like where maybe they change like field names by misspelling and you don't, you know, you can just do that, um, and so you can get inconsistencies start to show up, uh, and so it can get kind of complex in that sense, um. And so it becomes more instead of like the database management system. Being the thing that makes sure everything stays in the correct format, it becomes the application's job to do that, you know, you have to make sure things work well, um, in the very simplest key value databases, uh, there's not even relations, uh, really between different values, uh, the more complex ones have been developed, but you know, in the very simplest ones they're all just independent of each other so and then you can't. You can't do kind of, um, these kinds of uh SQL style um uh functions like summing or counting or SQL select and and so on. But these are, those are functions that are just not needed. So the whole point is to create something that's really kind of efficient and fast, um, for, for users, uh, when you don't need all of that other stuff. So there's lots and lots of implementations now of different kinds of key value databases with different degrees of like um you know lots of different feature spaces it's not it's not really like standardized in the way that like. Relational databases are, I mean, some, some have more features than others and so on. The first one really was Amazon Dynamo, that's the one that they built behind the scenes for their, you know, for their, their store. Um, it's now called Dynamo Database, um. Oracle has um a no SQL database uh inside of it can like work sort of with their Oracle databases. There's Berkeley database, there's ones that live in RAM entirely, so, like Memcache and Redd, so these are very Very, very fast, um, key value stores for just like storing things like cache data or information that you wanna read very quickly, um, just some other ones in here. I mean, and then this, this kind of structures also been adopted inside the browsers, so there's a, there's a key value database, um, that's provided as part of the web APIs in in modern browser's called index database. We'll come back around to that and talk more about that. In term two, so there's, there's lots of different ones, uh, that that people have, um, and so I'll just, uh, finish today with, um. Illustrations. So the Dynamo, the Amazon's, uh, highly available key store, uh, just has two operations. It just has a put operation, uh, which is like a key, a context, uh, an object, so context is a way to kind of add in a little bit of versioning information in there, um. Uh, but it's not really, um, the key point is that it just takes a key and it gets back an object and then you can, I mean, sorry, you can put a key and put the object and you can get the key and you get back the object and objects are typically around limited to about 1 megabyte in size. So Dynamos, uh, was, I mean this was this implementation and seeing this widely used with sort of the aha moment in the late 2000s when people realized we didn't need to be using SQL databases for everything, um, because it, it worked really well, uh, and so the final point that I just want to make is that the whole reason behind Dynamo. Was that they didn't care so much about having all the features that SQL provided um what they really really cared about was this kind of reliability and the the availability of the data for the consumers because from their perspective they didn't care about um anything. Other than we can kind of keep customers happy by getting the information as quickly as possible, even if it means we can kind of have inconsistent information, you know, or no schema to the data or anything like that as long as we're getting them the information quickly, that's what matters because from their perspective that translated to money, right? And so they introduced the idea of service level agreements which now have all all their cloud services at this kind of idea that essentially. You have You describe the performance of the system in terms of its availability like how what percentage of up time it has 99.999% or something like that, and they build that contractually into the services that they offer to you and notice they're not saying anything about consistency there they're talking about availability, um, and so it's used now in Amazon for all, all kinds of, of things. All right, I'll end there. I'll finish up with a few other topics on, on the sort of other kinds of databases, uh, that are used, uh, and then we'll move on, uh, and some other topics, uh, tomorrow.

SPEAKER 0
60 Yeah. Really I. Yeah. Um. Yeah Yeah Yeah


SPEAKER 0
OK, uh, let's go ahead and get started. Uh, I'll just start like every time. Do we have any questions about things that I've covered or about the assignment? Anything else? No, OK, um, so I'm just gonna pick up where I left off. I'm gonna try to move a little bit quickly through this, uh, next bit on persistence, try to catch up to where we're supposed to be. So, um, Last time I started to talk about some you know SQL style databases, so there's databases that aren't relational databases, but they are maybe designed, uh, to. Uh, provide, you know, the ability to, to, to have high availability, uh, but maybe don't have all the features of a relational database. So I'm just gonna continue through a few more examples of different kinds of, uh, no SQL databases because they're the kind of things that are likely to come across if you're doing any kind of web development in the future, um, although we don't use them in, in the assignments per se, um. So, uh, the next one that I wanted to talk about is the idea of having a key value database but you store it entirely in RAM. So the most popular, uh, version of this is Redis. So it's basically it's called a memory store, and you take the whole database and you just put it in RAM, and of course, as you can imagine, this makes it very fast, um, it will, you know, be able to serve up, uh, results very, very quickly. And so it's used very often for cache data on the server. So imagine you have a web server, maybe people are making, uh, lots of requests. Well, you just cache them the first time you need to pull it from the database, you cash it in, in RAM in the reddest, uh, database and. Uh, you're good to go. So, um, you know, it's oftentimes that it's like sitting right on the, the same computer as the API server. So Red is just one example. It's by far I guess like the most well known, but then of course, as always happens, so lots of competitors come out, uh, so keyDB is another one, that's come out more recently that you might come across, um, but basically it's just a key value store, um. So this means you got a bunch of keys, which are sort of the primary key for the items, um, but then you can have complex data stored, um, you can have strings they have bit arrays so you can have kind of binary type data lists of sets, hashes, um, and the other thing, uh, that is, uh, kind of interesting about Redd is that they, the keys themselves don't need to be strings, so, um, in a normal kind of JSON style key value. Structure you would think about the keys as being strings and then they all have different types of values. Well, in red you can actually have a a binary type as the um as the key, um, but it just has a different like uh like command set and like all of these ones are not kind of formalized in any way. It's not like relational databases different, you know, types of databases will have different features and functionality um so they'll have like. Uh, features for loading and storing, changing values and, and so on. Um, so memory stores are. Used a lot for when you're doing like, like regular queries where you might think lots of users maybe are doing the same kind of query. That way you can serve up the data very, very quickly. Um, so, All right So, um, I guess another category of new SQL, uh, database is what we might broadly characterize as document databases, um, so what this means when, when we say document is essentially we're storing some kind of, um, semi-structured information or data. It has no necessarily no schema or something like that that. Uh, defines, you know, what the fields are supposed to be or anything. It could be kind of arbitrary, um, and so you store a bunch of documents. Maybe you actually store just a bunch of JSON data or XML, but it could even be other kind of like binary types like PDFs, you know, document files, um, spreadsheets, all kinds of sort of stuff. So you have kind of the documents, um, and then there's usually some associated metadata alongside of it. And then essentially the way these document databases work is that it builds indexes on those documents in some way. Either based on the context of what's in the documents, um, so things that are sort of the, you know, you have a document database that's sort of like a standard sort of information retrieval kind of system where you can do queries like keyword queries and try to find documents that match, uh, the queries, um, or it could be based on the metadata associated with each of the files, uh, in your document database, um, so these are used, you know, when you, you don't really need like a. Uh, you know, a relational database with tables, but maybe you're just storing different kinds of, of semi-structured or unstructured, uh, information. Um, So I mean they have like one of the key advantages I guess of having a document database is that you are storing it in the format native for the program that you're using so you know maybe you have just a bunch of JSON data where you just read the JSONN data from directly and just send it on to, you know, your application and then that's what what your application expects um so that's nice I mean. And you know, like I said, you can, you can index it based on both the internal content or the metadata, um. It's an easy way to store very complex data, you know, where you don't want to try to formalize the schema in any way. You don't have to manage the schema, um, and you know this comes in a lot, um, it becomes a big issue in development if you think about how database schemas are always evolving all the time, you know, so if you don't have to even deal with that. You just throw stuff in it's just big blobs of JSO data that's good of course everything that has to be managed on the application side essentially I mean you can have all kinds of uh issues on on on that side, um, but you know you can have data that's replicated you just have different documents, you know, you, you don't, you don't really know like, you know, based on the content you could just push the same, you know, data file in. Um, but then, yeah, I mean, the big thing is, of course, you can get inconsistent or obsolete data, uh, document structures over time. Um. So there document databases are sort of a broad category. I mean, it's not like there's like one sheet uh fits all for this kind of thing. There's lots of implementations of these. Some of them are built into sort of like traditional database, um, management systems like so for example, post-grass, uh, you can actually use it as a kind of document database. But, uh, some of the other ones that are, are, um, uh, commonly used, well, there's Elastic Search, um Elastic Search and Solar Apache, uh Lucine, they're actually kind of related, but they're they effectively are um frameworks that allow you to, um. Create pretty much like a search engine, um, so you, you put a bunch of documents in and you create certain rules for uh creating information retrieval rankings based on queries um and so you say you wanted to have your own say you had a whole huge collection of documents in some, you know, company database or something like that and you wanted to create a custom search engine over that, you would use something like Elastic Search or uh solar Apache. The scene, so actually, so the scene and solar are both open source projects, um. And then Elastic Search kind of builds on top of it some additional tooling, but it's all based on the same thing. So some of these other ones in here like. Uh, CouchDB, MongoDB, like all these other ones, these are ones that are sort of, uh, sort of. Um, kind of no SQL databases that that essentially take in semi-structured data usually in a format kind of like a JSO document, so you know, a bunch of fields and, and, uh, you know, with keys and then you got various values and then you can create indexes on various fields and so on and so forth but the, the key thing is there's no schema, um, you can just add fields as you want and and change them around and so on and so. Um, these all have, I mean, are just different, you know, implementations of those with slightly different feature sets and, and so on, but they're, they're a bit more kind of they're semi-structured in the sense that they expect something like a, um, JSON like structure, uh, for your data, but as opposed to something like Elastic Search or Solar uh uh Lusine which you know are just essentially just raw documents that you're, you're indexing. Um, so, lots of different implementations of these things out there, and it kind of depends on your use case. So, um, the last, uh, kind of new SQL style database that I wanna highlight for you because it's quite different than everything else that I've discussed is this, uh, idea of a graph database. So a graph database is, um, something that has really been developed in the last, um. Couple of decades, uh, where essentially you're you're you're storing information in some kind of graph data structure so we're all familiar with graphs, right? You have nodes, you have edges, um, you know, it's sort of your standard computer science graph, um, but it's where your, your data actually very like fits quite closely into that model and you want essentially store it that way and to query over the graph, um, so. You'll have nodes or a vertex depending on terminology you want to use that represents some entity uh that you want to store, uh, and then the edges are the relationships between uh the the nodes uh you can make graph databases that are bidirectional, you know, so they would have, um, you know, some kind of, you know, connection from one node one way and then back again, or they can be, um. unidirectional. Um, and then on top of all of that, each of the nodes and the edges, uh, in your graph can all have attributes or properties essentially that describe that um that edge or the node, um. So it's, it's stored, um, internally as a set of keys and values, but you don't need to worry about that so much. But, um, I'll show you an example of like what it actually looks like in the next few slides. But one thing is that there are even extensions of it where you can create, um, hypergraphs, um, where for example you can an edge can can connect more than one node to another node and so on. So it kind of depends on the graph database implementation whether that kind of functionality. Uh, is available to you. Um, so. Just to motivate this a little bit, let's just think about some examples of kind of data that you might want to use, uh, that would be better, um, kind of represented. In a graph, uh, database versus, you know, like a normal relational database or something like that, so, uh, street map, uh, a street, uh, connectivity map that should be written around the other way, a street connectivity map is a is a kind of classic form of a graph. So if you think about, uh, like imagine you have a bunch of um. You wanna characterize sort of um some street network but what you're really interested in is to sort of uh facilitate certain kinds of um queries like how to get from one location to the other or something like that. Well, um, in that case then. You're probably going to want to model, uh, the street network, um, in terms of various junctions where streets come together, um, and then you might have an edge that like describes the flow from one node to the other. So, uh, like a street network, um, you know, if you have a one-way street, it's going to be unidirectional, a two-way street would be like bidirectional, right? Um, so. You basically could represent this map as a bunch of uh nodes and edges uh between the nodes. Um. So In a graph database, the nodes and the edges can have properties like I, I just mentioned. So what that means is that like, you know, because the, here's an edge here between this gray node and this red node and that edge might have a whole series of different properties, uh, which could be like its name, it's type, it's maximum speed, you know, restrictions, the surface of the road, so on and so forth. Um, and so different edges will have, um. You know, different kinds of attributes and um it doesn't necessarily have to be the same set of attributes um it could be, you know, some, it could miss some attributes and include other ones. um, so yeah, all of the edges will have uh different attributes and uh so do like uh the nodes themselves, um, so. Here's another kind of graph, um, that's more of like a social network graph, um, that describes relationships between people and companies and and so on. So in that case, um, you might have a certain kind of people entities like yours Dave and Kathy, and they have colleague of relationships with each other that's the edge here, um, this could be a worksat relationship or something like that. Um, and then, uh, the, um. The nodes themselves will have, you know, various information. So for example, the address, um, of where, uh, what building they work at, what their phone number is, and so on and so forth. Um, so nodes and edges can have properties, um, and. On top of that, you can have different types of nodes, so it's not like uh just a simple graph, um, like in you might. Using like discrete maths it's sort of like a it's what they call a colored graph I guess in in kind of formal mathematical terms, but it's essentially every every node has you know can have types and those types can dictate sort of the types of uh relationships they can have like you know what kinds of um edges can come map between things and it also can. Dictate what type of pro uh properties, uh, that it would have. So, here's an example where we have, um, People, uh, and then we have um. Uh, years and we have, um, uh. Like the um course codes, so somebody in this year. Offered this course, um. So, um, Basically, when you combine the properties to the graph, you have this thing called the property graph model. And so in there, you know, this, you can see you have types, what, where these are not, these are not individual, um. Uh, these are not individual nodes and edges, um, these, this is the graph model is describing the types. So here's the employee type, the company type, and the city type, uh, and in it you can see the nodes have different properties like the name, date of birth, employee ID. And these are just examples of what they could be, and then the kinds, the relationships, um. Have, uh, you know, a name value pair as well. So like start date, um, for this has CEO relationship. This company has CEO. Where the employee is the. This employee Amy Peters is the CEO of the company, uh, so that's a unidirectional one based on, you know, the, the definition and then same with like, uh, located in, um, so generally speaking you can, uh, think about like the nodes as nouns and the. And the connections, the edges as like some kind of action or verb, uh, between them, um, so that like if you're trying to think about how to conceptualize your uh graph database, you would, you start to think about your entities as the nouns and then what are, I mean they can be kind of uh relationships or they can be actions of of some kind, um, so. If you were to turn this into like a sentences, you could think about the nouns being the the types of the, uh, you know, being the the nodes, the, the verb is the, the edge and then the properties for each of those, the properties of the nouns or the adjectives and the properties of the verb or the adverbs, right? So, um, it's just a, it's just a way to kind of help to think about like how do you, how best to um. Naturally map sort of a conceptual model of relationships, um, of entities down to uh um to an actual kind of property graph model like this, um. So One question, uh, you might have, I don't know if you do or not, but it's like why do we even need to bother with graph databases? I mean, you can if you want to use a relational database and store uh the nodes in the edges as tables in your, in your database, um. The key, uh, reason, uh, for using something like a graph database structures first off, I think it's the conceptual modeling side of it where you want to kind of, you know, think about things in a as a graph and then work with them as a graph, um, so and that's that's the bottom point here that, you know, some problems are just best. Suited to be directly represented in graphs. So like a social graph would be an example of this. But the other key thing, like, I guess sort of from a computational side, why you would want to do this is that, um, you know, if. The kinds of queries you want to do on a graph, you're gonna need to do lots and lots of joins between nodes and edges, um, and if you're doing something that's like wanting to take certain hops, like a certain number of hops along the, the edges in in the graph, it becomes really, really expensive to do this by querying over joins on these like nodes and edges tables. It's just not effective. It's far better to use a native graph, uh, representation and use graph algorithms to. Uh, execute the query, um. So, Um, So yeah, I mean, this, I, I kind of hit on this. I, I'm not wanting to spend too much time on this, but I will say that I'll just go through it quickly. So if you're mapping the data of your application to a graph, then, you know, you have your entities, um, and will hopefully familiar a little bit with like entity relationship kind of. Uh, modeling, uh, maybe from, uh, databases, but if you have your entities, then those are represented as nodes in your graph, and then the connections are the edges, uh, between, uh, the nodes. Um, and then the semantics of the connection, what that meaning of that semantic is the meaning of that connection is dictates whether it's, you know, what direction it's going to. I mean, so for example, the has CEO or is CEO of like that will switch the direction of that of that edge, right? um. Uh, and then the attributes become the node properties so you can also add all kinds of interesting things in there if you think about sort of, uh, properties of the, um, looking at at at the the relationships, the edges and those and and those properties you can add things like weightings between them or strengths and things like that which uh. Can be very useful and sort of to describe things like the strength of the relationship between two entities, which leads lend themselves well to certain kinds of graph algorithms that um. So, uh, you, then there's other metadata that you might, uh, have in a separate sort of metadata about the whole graph, um, like information about the data entry or the versioning and and things like that as well, um. So there's so unlike relational databases, even though it's somewhat a bit more formal than some of the other no SQL things that we've talked about, there are still it's not like there's one canonical, um, sort of way to approach it like we have SQL for uh for relational, uh, databases. So there's a number of different ones, uh, that have been implemented. I would say NO4J is probably the most mature one, but there's certain like Amazon, Neptune, Janus graph, those are both open source, uh, projects, um, and then there's, there's other ones here. So for example, I talked about Reddi is a memory database. Well they have an in memory graph database, uh, version, and there's, there's others that you can, uh, look at. So just to give you an example of, um, then. Like once you have the database, you need to then be able to query it somehow, right? So. The um like I I'm saying it's not, it's not kind of formalized in the same way or or there's not like kind of a canonical way to to query graph databases in the same way as there is for SQL, um, but, um, there's been a few kind of forms that have kind of become, you know, dominant over time so. I mentioned NO4J as the implementation of a of a graph database um that you could use and it has a language called cipher um so it was originally developed for that but it seems to be kind of being adopted around so it's a declarative language just like SQL, um, but instead you kind of make queries over the graph, um. So it has sort of your standard create read update and delete operations on the elements of the graph itself and then instead of doing a a query like a select query, uh, what you do with that's called you would kind of create a pattern, um, and you wanna it's a pattern matching um language so you describe sort of the pattern that you're looking for, uh, and then it finds the elements that match the, the pattern. Um, so this is a bit what it looks like, uh, here, um, I'll have, uh, I'll show you a few quick examples in the next slides, but there's are alternatives and probably, um, I mean, I, I just list a few of these here, uh, but one thing I should mention is Sparkle, um, we're not talking in this class at all about the semantic web, but, but RDF graphs are another kind of graph database structure that that was, um, sort of developed, uh. When there was a lot of interest in the idea of a semantic web, which I think it's kind of evolved over time, uh, but in there it's, it's like an XML style format and, and they have their own query language for querying these the graph structures, um. So So for example, the, the NO4J has this nice little playground you can, you can play with, but, um, I, how many of you heard about the Kevin Bacon, uh, problem or whatever it is for, uh, for movies? Anybody heard of that? See a few nods. So the idea is that, uh, everybody's related to Kevin Bacon or the six degrees of Kevin Bacon, you know, it's, it's, it's just a classic sort of, um, graph, um. Problem where the the idea is that there's, you know, in any large uh network, the, the degrees of separation between any two nodes is on the order of some, you know, like it's a rather small number, um, and so the idea is that, uh, you know, if you start with any actor in within like 6 steps you can get to Kevin Bacon through shared movies, uh. And so, um, there's a you can do a bit kind of like that, um, by just loading in something like the IMDB database into graph DB and start to do queries over uh over movies and see their relationships. And so, um. And, and so basically what you're saying is I want, I wanna match against things that fit a pattern. So this looks, you can see it looks a little bit like SQL, uh, but it has, you know, some differences. So it's trying to match, uh, some an M that's of, uh, type movies, so entities of of movies, and then there's like a where clause, um, and there's a limit of 5 and so here's it's returning 5 nodes, um. That are 5 movies released after 2000, um. But then, I mean, here's where it gets interesting because you can match the relationship. So, you know, the nodes are in the in the Round brackets and then they um the relationship is in the square brackets and so you could, you can say, find basically match people. Uh, that have acted in relationship, uh, to movies, uh, where, um, it's, uh, released, uh, greater than 2000. Um, and so you can get back results that, you know, look like this, where you have, these are the actors, uh, that acted in this movie that was released, um. After 2010 in this case there's only one movie in the database, um, but you could, so here's the Kevin Bacon problem where you're basically saying you could see that there's there's sort of like in the pattern matching you can you can create structures to kind of match against ranges and, and, um, and so on. So here it's saying find a person who has the name Kevin Bacon, um. It in that matches uh to. Uh, this Hollywood, um. Uh, You know, basically this is any this is like a, a global, like any kind of type that matches um. Uh That, that, you know, that fits in here and it'll map it to the name, uh, Hollywood. See, it doesn't have a typing here. Uh, and then it's saying from 1 to 3 hops to that. So it's basically, so here's Kevin Bacon and That it hasn't acted in, it doesn't matter what actually that it's, it's gonna find, you know, whatever kinds of relationships, but here you know based on what's in the database it has acted in to these movies and then these movies have uh steps to, you know, has a directed and acted in other different kinds of relationships so you can find basically everything within three hops of Kevin Bacon. Um, so, in this case, yeah, Hollywood just stands for any nude. In the graph, um. All right, so, um, lastly, I'll just leave you with this, um, so just to give you like a comparison of the kind of work that you're doing in the lab for with the MySQL, it's very similar. I mean, like in MPM you can install, uh, a NEO4J driver which is essentially a, a client for interacting with a NeO4J database that you have installed, um, and then you can, you can actually create your, um, your queries and, and do them, you know, just like in, in SQL. All right, so that's all I wanna talk about about that just to kind of show you some different, um, you know, types of um. Uh Different kinds of ways of persisting data beyond what we cover, you know, in both cost 265 and what we cover in the assignments. Um, any questions about this before I move on? To the next subjects. Oh, OK. Um. I have a, I mean, if I have a, um, an extra lab I can upload on to learn if you're curious to work on it. It's not, it's not related to any assessment in the course, but if you want to have a chance to play around with, uh, uh, graph databases, um. So, let me close this up. Um, So Next, um, you know, we talked about. Talked about um. HTTP in the first week and then we went to a bunch of different topics like JavaScript, TypeScript, uh, data and how we handle that. Now I'm kind of coming back around to HTTP, uh, but in this case I wanna talk about a few other concepts that are related to what I already, uh, covered, um, in, in the first week, and this relates of course to the assignment as well. So these topics are rest and and just APIs more generally speaking going to a little bit more more detail, um. So I'll just uh For it So the first thing that I want to talk about, uh, is rest. Um, so, um, rest is a, um, Uh, it was developed actually as part of a PhD project by this guy Roy, uh, Fielding. Um, it was actually a chapter in his, his dissertation, um, and what he was trying to do was sort of come up with a way, so here, here's the, uh, here's the chapter itself it's you can see it's actually like literally the title of the chapter. He was trying to come up with a way to sort of. Uh, describe how API should be built, uh, that are built on top of HTTP in such a way that they will behave in a manner that's predictable, that is, um, uh, that, um, where, where you could look at sort of the definitions of the end points and have some understanding of the behavior of the API, you know, based on on those definitions, um. And the other thing is that um when he was doing this also web services previously had been a. Like the, the main way to doing that was using this really heavyweight XML based, uh, format called SOA that was really hard to work with and so he's trying to come up with like a simpler, uh, model that just built itself naturally very easily on simple kinds of HTTP, uh, requests and responses that are already there. Um, so, basically, it's, it's a. It's a way of approaching the development of an API where you use HTTP methods when I talk about HTTP methods, I mean things like get and post, uh, you know, those, those kinds of methods that you should be familiar with now. You use them explicitly so in a very particular way and consistently, um, to match how they're defined in the HTTP protocol. Um, so Um, there's actually, I mean, the, the reason why this is a thing, uh, an issue, and I'll, I'll have a bit more into some examples is that, you know, you can use something like a get request for example an HTTP, and you can use it in a way that's, um, uh, it's gonna trigger something that is behaving. In a in a way that actually changes the state of the of the server or the data in the back end in a way that like uh the conceptually like getting information should not should not do right? Like you shouldn't be like if you're just trying to get some piece of information you shouldn't be modifying the state of your application uh in the back end so for example um you might. You know, it, it's, it is like, um, possible that you could make a get request and delete some um piece of data in the database when that happens, um, or create some new element in the database, but this kind of behavior doesn't match with um. Uh, you know, what, uh, you would, what the original HTP method was intended for, um. And so the reason why this matters is also if you have these kinds of effects are happening then uh like I mean oftentimes making get requests and things like that will often be done just by all kinds of services that you have no idea about like so imagine like a web crawler that's coming along and wants to just get web pages it might be triggering things happening in your database by making get requests um. In a way that is actually changing what's going on, um, if you don't like align the methods well with the semantics of, of your program. Um, So to kind of step back a little bit, uh, and sort of explain the, the, the context, so we introduced HTTP, right? So HTTP is stateless, it's a stateless protocol. So it was always originally designed for document uh retrieval. So and what I mean by stateless is that all requests and responses are completely self-contained, so. If I make a request, um, I am making that request the server can should just takes that information in every action that it takes on that request is gonna be based purely on what is contained within that request, right? There's no kind of connection that's established with multiple requests and and things going on like that, um, and so HTTP, uh, creates a set of common. commands, um, so you'll see things like get, um, that's, it's meant to retrieve a named resource like in its original conceptualization as a, as a kind of document retrieval. A protocol it was meant to retrieve a resource and so it shouldn't alter the visible uh server state. He is like get but it only gets the headers so it doesn't get a body in in the response. Post is meant to submit a data to the server. originally this was, uh, primarily done through HTML forms. And then there were some other less commonly used commands things like options which is supposed to get the methods uh for a resource post um where instead of submitting data the service you're like creating a new resource, um, put, uh, is, is meant to submit a change delete delete a specified resource and patch, uh, to, uh, modify an existing resource, um. So, um, Uh, in HTTP, um. And in in rest um like what what Roy Fielding was trying to do was to kind of formalize a little bit that notion of document retrieval and to talk about what kinds of what what kind of actions should a server actually take, uh, when they take a an an incoming uh HTTP uh request, um, and so. For this, there's like two concepts. Um, the first one is about being safe and the other one's about being item potent. So, Um Safe methods are defined as methods that do not modify, uh, resources. So essentially they're basically read only. um, I potent methods are methods that. The data is changed, but it's only going to be changed to the to one state no matter how many times it's called, right? Uh, so what this means is like if I try to, um, You know, you know, if whatever the current state of the system is, once I make that item potent call, it should be in a new state and that new state then if I continued making the same call it should just be in that same state. Um, Uh, over like, like, no matter how many times I've called that, so. So, uh, methods that are safe and methods that are item potent. Are what RET is trying to sort of, uh, categorize as like the best practice in in terms of building an API um that is quote unquote restful on top of HTTP so. It's just about best practice and standards. You can totally break these and have them behave in a different way, but you probably, uh, shouldn't. So you know, in, in his table of like what, what methods should be safe and what methods should be item potent, uh, it looks like this. So uh get request. Uh, and head request should be both safe and item potent. What does this mean? Well, it's feed only. It doesn't change anything in the back end, um, therefore, if you get once and you get the next time, the state of the server remains unchanged. So we're talking purely about the server, right? If you get something twice, it sure it might change the client in some way, but that's not, we're not concerned with that. We're only concerned with the server side. Um, Uh, so things like, um, putting and deleting should be, they're not safe, so they can, they're not read only requests they can change the standard database, but they shouldn't, uh, continue to change it with multiple requests. So the delete's probably the easiest way to think about this, right? Like if I have an item in my database, if I make a delete request. It should maybe delete a row from the database, but if you then try to delete again, the state of the database is the same, right? You can't delete it twice. It's, it's, it's going to be in the same state at the end whether you call it once, twice, or 10 times, um. And then uh methods that are not safe and not item potent, well, those are ones that can, um, can both change the state of the database but also can continue to change it every time you call it. So with a post message, I mean a classic example would be like. Creating a row in your database. Well, you would create, you can create a row by making a post and then you make a second post and it will create another row in your database, right? So, so the state of the database in the in the server is changing, you know, every time you call a post of whether and it it makes a difference, uh, for that, um, and so. But if you're building something that's stressful, you should be always using these methods in, in these ways, um. This is a lot of text here, um, but it's really all about like why why following these rules is important. It really has to do uh with the notion of side effects, um, that, um. Uh, like, basically, if you look here, uh, a poorly written server application might get use get methods to update a record in the database or to send a message to a friend, and this is really, really bad, uh, design. So. Um, I, I'll give you an example that I, I came across, um, that there was some, um. Somebody, I I saw it somewhere on social media, I should have saved it when I saw it because I haven't been able to find it since, but they had, they had one of those kind of um. Uh, automatic door opener, uh, things, um, and so it was hooked up to some like kind of smart functionality, um, and they had, um. The um. They made the the request to open and close the door a get request, um, and so what happened though is that that get request also turned the state of whether the door was open or closed and so some other tooling kind of interfaced with that and they were like wake up like why is my why is my like garage door randomly opening and closing, you know, all hours of the night and it was because some other service was simply querying. To find out if the door was open using this get request, and that's so that's like a classic example, right? You can end up with like really bizarre weird side effects behavior if you do things like use get requests to uh modify the state of your system, um. So I talked about rod and and database as well. Those kind of naturally mapped very nicely to to rest. So rod being create, read, update and delete that's the four kind of uh kind of actions that you wanna take, um, so generally speaking, uh, if you want to create a resource on the server, you should use post. Um, to retrieve a resource, you would use get. To change the state of an existing, uh, resource or to update it, you'd use put, and to remove it, you would use, uh, delete. Yeah. What was the difference of train length Oh, that's a really good question and um it's funny you should ask because. Oh, I don't have it's not the next slide. I was by two slides. So, so patch is a particularly weird case that is, uh, I think it still gets interpreted in different ways, um, so I have a slide that'll come back around the patch, but. Bottom line is patch is supposed to be seen as kind of like a diff operation, uh, versus a, um, put, which is, uh, um, sort of changing or updating the state of it, um, but. Um, yeah, I mean that's one that catches people a lot is where does patch fit into all of this, right, um. So, so yeah, I mean, this is just an example of the bad practice, you don't. You don't have there's nothing that says you have to map HTTP methods to those crowd operations, so you here you could have, you know, some kind of user, um, get request and give an ID and then you could have an action delete as part of your, your thing. So you know, I presumably, I mean maybe you've written your your HTP request to return information about the user ID, but maybe you wanted to add on the action delete. Um, and so this then becomes a get request that presumably does something that's not safe, uh, um, uh, is it not a safe operation in this case, um, you know, you should instead be using the you should, it should be over here at the at the HTT method level, not in the, in the URL, um. I mean, it might be, you might think this is kind of silly, but like, I mean, you know, there was no kind of like standard practice in terms of how people were developing. Uh, APIs, um, until rest came out and people were like, oh yeah, we need to kind of really stick stick to this, um. So these are just more some more examples, right? So you could use a get and it might have an action like add user that would probably be a really bad case because you're modifying the state. Um, these ones are like post messages um these post messages, um, would be OK because presumably I don't know, they're they're updating the information about, about the user in in different in different ways, um. So a question about patch. um, so the idea, I mean. There's, there's, um, there's actually differing ideas about how best to use patch so it's certainly there's not, it's not always consensus about these things, um, but ideally like patch is meant for like a partial change like, um, a diffing of a thing rather than sort of recreating the whole like updating the whole entity, um. Uh, and so with a patch, I mean, I guess the difference is you're, you're only changing elements, um, you only include the elements that you're going to be changing. So if you, if you include an element that doesn't have a value, then it's supposed to be interpreted as a null, um, so you're, uh, so you're kind of deleting, uh, the element, but there's more here about this. I mean we've kind of chosen a particular way to sort of use a patch in the API for the assignment. Uh, but this is an area where you'll see a little bit of debate about the best case, uh, use for that. Uh, I mean, most of the time when people are kind of focusing on, uh, re, making sure things are restful, they're really focusing on like the get and the delete and the post, uh, methods, um. There's a, um, there's more information here too. I just wanted to give you some, some references. It, it goes into quite a bit of, uh, discussion about it, but this is best practices for how to partially update an entity, um. So, um, alright, just a couple more minutes. So there's important things about, uh, REST to highlight here. I mean, I've talked about RE in the context of HTTP, but. In fact, so, so, so rest kind of is also its own thing, right? It's, it's a way of sort of describing how, what kinds of, uh, requests you make and whether they should be safe or high potent. It's completely um platform independent. It doesn't matter if the server is Unix or the client is a Mac or Windows or whatever, right? Like you can, I mean this is one of the nice things about about building a restful service is that you don't need to think about that. Everything is sort of defined, um, you know. Everything is mediated by these kinds of uh uh these these HTTP uh methods um it's totally language independent so you can use different languages on, on different sides, uh, and it's all based on this, um, on the, it's based on the HTTP standard. It sits on top of it, um, it's not actually required that it must be, I mean you can build something that's restful used not on HTTP actually um. But it and it can also be used with with firewalls and and all of that. So it's quite, I mean, it's got a lot of nice features, um. And typically you communicate over HTTP, uh, with the using the same verbs as used by web browsers. um, what I'm saying when I say typically, I mean you could build something that's technically restful based on the design that uh Roy Fielding came up with where he's talking about safe and item potent methods in particular, um, but over some other protocol, um, but generally speaking it's always in the context of HTTP. Um, and, uh. Yeah, basically you use the, the system to, to get, to get your data and and send uh send data to the, to the servers. Um, so when we talk about restful apps, um, you could think of them as sort of a subset of all of, of web apps out there that sort of follow this, this, uh, standard and approach, um, and so, so it's all about communicating to end users, right? So if you're, if you say I have a restful service, then some developer can go and use your API, do a get request and could be, you know for sure that it's a read only request, right. Um, all right, uh, I'll wrap up there for today, um, and then, well. Wind this up, uh, next week and I'll talk a little bit about APIs and move on to a few other things.

SPEAKER 1
All right, thanks everybody. You know Now Oh I I I I Yes. from. You're just curious, yeah, I'm like oh yeah, yeah, yeah. You All right, I'm getting surrounded by just turn off.

SPEAKER 0
I'm turning off the mic so things are getting, yeah,

SPEAKER 1
OK. Did they include everything that we talked about, it's, it's,

SPEAKER 0
it's basically no SQL is just a grab bag category for anything that's not a relational database. Yeah, um, and it's, it's they're all kind of put. Under that category because it was sometime maybe 1015 years ago where people all of a sudden were really about well now that we're talking around 2007 when the when they were really building the key value databases where people were like, oh, we don't have to do everything as relational databases and so then, then, you know, everything gets kind of categorized in there, but it's, it's sort of like an ad hoc category of different kinds of techniques. They don't all use JSO. I mean, they use, it's basically anything that's not SQL-based, um, relational databases. So like the graph database would be an example of a no SQL database that's not based on JSO if that makes sense. Uh, oh, no, well, I would say key Value stores as actually being, um. Uh, no, document databases are can be other things. So for example, you could have a document document databases just mean that it stores a bunch of information in schemaless documents. Sometimes those will be like JSON style documents, but it could be just random files, for example, it could be a whole collection of, say, say you have an organization and you have a bunch of PDF files. and other kinds of files, um, and you wanted to build a database over those to allow people to query and search on them you could build a document database on top of that, and it has nothing really to do with key value stores, uh, per se. Does that make sense? Yeah, OK, yeah, it's more just like there's a whole bunch of things out there and there's different kinds of,

SPEAKER 1
yeah.

SPEAKER 0
Oh, did I not? OK, sorry about that, totally, yeah, yeah.

SPEAKER 1
Um, I know about. It's like I don't know if this is one of the tips we can go out if that's easy. Well, I just want to clear out we can keep talking. I saw her. I just like I starts with the. Yeah, I, I have no idea. I, I have no idea. Yeah, it's, um, and then I don't know because I'm doing this right at the top, right off the tribe, it gets, I mean. I'm. That's.


SPEAKER 0
I don't know how much I. And It's not. but I don't, I say that this is not not not work. That's the thing. It it work I wouldn't. So no, it was beyond. Yes. So So you don't have. No. Probably. So. I you very. So. Yeah.

SPEAKER 1
Everybody got quiet when they bumped them. Um, all right, welcome, everybody. So we're into the assignment, um, so the labs for this week and next week are just gonna be support for, uh, the first assignment, um. I'm gonna talk actually about that first, um, so if you're following along in the slides, I'm gonna do the beginning bits of the week 5 slides and I'll go back and finish up what I was doing in week 4, but I wanna cover a few things that will come in likely very handy as you're going through the assignment, uh, and developing a kind of common issues, topics that are, you know, if I cover them here. Uh, hopefully, uh, they'll give you a head start on things. Um, OK, so. slides. So I guess, uh, before I begin on this, I mean, I might answer some questions, but I'll just ask, you know, right now if there's any questions to start off. Oh, yeah. Sorry about that. All right, so any questions about the assignment? Yeah.

SPEAKER 2
the um. Functionality. To Yeah, um The part about updating the password, is it kind of saying, um. When, when you get a pat of request, if there is. Like a password Yeah, the wordings a bit strange.

SPEAKER 1
Let me just open up the spec and then I'll, yeah, OK, I understand what you're saying, um. OK, um So you're talking about the patch, uh.

SPEAKER 2
Yeah, yeah, the user one, yeah, right, yeah, OK, um,

SPEAKER 1
yeah, the wordings a bit odd. I acknowledge, uh, so. So the idea, so the password and current password. Um, can only be supplied when editing, uh, the password. Um, so, So the question is. I mean, can you phrase the question? You're just like wondering, just like I'm just wondering whether,

SPEAKER 2
um, it's kind of a universal pat request so that you could specify any number of details that you. All of them and the password is just one of those things you just have to check that the current end yeah, yeah, yeah, that's, that's the way it is,

SPEAKER 1
right? So, so, so the thing, yeah, the wording is strange because it makes it sound like you could only send password and current password together without anything else, right. Yeah, yeah, yeah, yeah, so yeah, I, I. Yeah, so it's basically um saying you, you don't send password or current password unless you're updating the password. That'd be the way that I would, uh, interpret that, uh, yeah, exactly, exactly, yeah, I mean, so, so there you'd be no reason ever, yeah, to send one or the other because you wouldn't send password. Uh, because you're sending the authentication token said, I mean that's how you're, and you wouldn't send current password without password because it, yeah, it doesn't work. So yeah, that's, that's the meaning of it. So this, it just means you, you basically send these together or not at all, um. But you can do a patch that does those and also, you know, changes the first name or something like that yeah yeah I mean it should be an error if you supply current password. Uh, Yeah, so the point being if you send password without current password or you sent current password without password, either of those should be, yes, those would be an error, right, um, because, uh, basically it's a, it's a, uh, it's a bad request because you're not, you're sending something that isn't kind of a, a valid patch request. Um, I mean, I guess the other thing I should say too is that you know we, we endeavored as much as possible on the reference server to. Sort of implement the spec, um but we also had in mind a number of tests that we were going to do um and so we kind of really. Like focused on on those parts of it if there's something you find. How, how should I put this, so the spec is. Is what you should be building to not trying to reverse engineer the uh reference server if that makes sense um so uh for the most part the reference server should match what's in the spec, um, but the tests are based on what's in the in the spec that we're going to be, uh, doing, um, and so for example if you're writing a new test that you think implements the spec correctly. But it's the and then you run that test against the reference server and the reference server is in align with spec just pay attention to the spec if that makes sense, right? um. If you have specific questions, you know, obviously contact me or the tutors or anything about that. Um, OK, cool, so, um. I've lost OK. All right, so there are a number of bits of the functionality that you know basically become that that I wanna cover that kind of give you a head start on things. I mean if you've already started that's great, um, of course, um, but there are things that aren't maybe specifically covered in the labs but that you'll kind of have to work through, uh, in the assignment. And so these are more kind of like guidelines on how to approach uh these aspects of the API. Um, So just in terms of getting started, um, like when you're, you know, when you open up that spec, I mean, obviously there's lots of different end points and you might think, oh, where do I even begin? so. Just be mindful that some end points rely on other end points, you know, so for example, you can't create, uh, that says film, sorry I didn't update it from last year, um, film, it was a film website last time. You can't create a new game, um, until you've like actually logged in, you know, so because the, the idea is that you'll get a 401 unauthorized error. So basically. You need to implement the login functionality before you go and start doing the post ones, um, so basically the starting point is, you know, there's, there's basically the user end points and then there is the, um, like any kind of get request that is just a read only request, um, that doesn't rely on any kind of user authentication. Those you can just get started on cracking right away. Um, once you get the authentication part built, then you can kind of do all the rest of them. That makes sense, um. So I have some example code. This code is in JavaScript, so it looks a little bit different because it's, it's a bit older, but it's mostly the form is all the same, and I just wanna talk about a few things about, about the code, um, you know, you will have already seen this kind of structure in the labs and it's in the skeleton project already. But there's a few differences actually in what's here, uh, versus what you have in the skeleton and it's not required that you implement it this way, um, but I would, you know. Say that this is this is a a a good way to do it and it's, it's sort of a a way that is um. I guess good practice, um, you know, and you might come across it and so there's this notion of a middleware. So how many of you heard this term before, middleware before? OK, so you you right, OK, so, um, you can basically inject middleware in your, uh, routes, uh, any time you're doing a post or any patch or get or whatever, right? Um, if you add in a, it's like the way, the way it's structured right now in the, um, in the skeleton project is, you know, it'll do post and then it will call whatever controller function is in there, right? But if you want to. You for example you want to reuse the same kind of authentication login required functionality for example like you could create a middleware function that just checks to make sure the authentication is correct, um, and so the way that works in how express uh works is that you have to, um, add it in as the first parameter before the controller calls so. Like most of them look like this where you just have the, the HTTP method and the controller function. So you just add in a, uh, function call in here that does that. So. You know, if you could, uh, implement kind of a login required kind of, uh, function. Uh, that checks the authentication token, um, and then that just put that at the beginning of each of those rather than, you know, going into each of your controller functions and at the top of them doing the authentication check, the authentication check again and again if that makes sense, right? So the middleware is just, it's like a, it's like a little hook inside of your your program to run something in the middle before it goes on with the next like the normal processing, right, um. So, uh, I guess you've, you've seen this already. I mean, the controller code looks something like this. Once again, this is not typescript, it's JavaScript, but it's the same thing. I mean, it's, uh, you know, essentially you've got like, you know, the controllers, you know, are these, these functions, and then when you go in, uh, you define them as an asynchronous function. Um You know, I, you know, this, the way that they're the, the, the, the, um, syntax that's used in the skeleton project is it uses this kind of constant function, uh, format versus, I think the function keyword if I'm correct, um. So, uh, but it's essentially just a different way of describing a function. So it's an asynchronous function. It takes the request and the response and then in your tri block you have your, um, you know, you do what you need to do, but and then here you call your model code, uh, and so the model code is what then, uh, we do kind of a, um. You know, essentially accesses the database and queries and, you know, just whatever, you know, tables it needs to. So in this case, this is from a different kind of API for venues like, um, if you're going to view the details of the venue, you call the view details model code. And you pass in the the the request parameter ID so the parames is the, you know, you know so so that should be all clear to you based on going through the labs and all that. So that's good. And then the responses are status message, status code, and so on and so forth. And so this is what's being tested again. And if you, you know, you add your, you add your data, uh, as like JSON in the return value and the response, um. And then your model code's gonna look something like this, right? It's, it all depends on obviously on sort of what your SQL, you know, what the tables are and what fields you need to use. Um, if you're, if you, you can probably make, uh, your model codes all work with single, uh, single queries, right? But in order to do that you're probably going to have to use some joints at times of different tables and so on. Uh, so you're gonna have to use a little bit of your like SQL knowledge and creating some kind of complex, um, you know, queries that join tables on IDs and, and so on and so forth, um, the alternative of course is that you do, you know, a few different SQL queries to gather the data and do some kind of joint essentially in the code and, you know, that you're writing, um. Ideally you do it all in in the SQL, um, but we're not testing on that, so you might find one way or the other is easier to implement, right? Um, so you'll do some kind of SQL like here's a big thing that's doing some different joins on different things, um, and it's kind of constructing a response, uh, for that. So, so those are the kind of the pieces and you're doing that for each of the endpoints, yeah. Uh, so is the model returning what looks like it.

SPEAKER 0
As we passed straight through Yeah, so the model basically

SPEAKER 1
constructs the JSO body. Uh, right, in, in this example, right, um, so the controller, um, I mean that's, this is sort of the separation concerns thing, um, that you know, with the, the model controller, you know, kind of idea. I mean, obviously you can implement it in different ways but the whole point is, is that, yeah, the, the model basically constructs that, you know, the, the venue here. Uh, is the return, you know, it's basically getting the return, so in this case the venue, that's like an object, right? Um, but then that just gets directly sent in as the JSON that's sent back. So it's in the model that does basically pulls the information out of the SQL and constructs that body, um, and then this right here, this called the dot JSON just converts the JavaScript object into a JSON representation of it, um. And attaches it to the body. Um, so. So, you know, you'll have things like this. You can look in the, at the, um, slides, you know, in the details, but you can see it's kind of constructing some return. Um, like based on that. So I just wanna show you because the authentication stuff is uh is something that I think you know some of you may or may not. You know, it might not be 100% clear how to how to approach that. So this would be an example of, uh, I mean you, you would need to rework this sort of a type script, um, but like if you were having a middleware, uh, function for authentication, it would work something like this, um, so I mean you could use this as sort of a template to try to look at, but in this case, so, so if you recall up here we added this authenticate login required um. Function at, uh, you know, for this post and for this patch end point. So what that does is it. You know, what it will do is it will pass in. The, uh, Sorry, it, it passes in uh 3. Uh, functions, um, uh, sorry, 3 parameters that request the response and then it has a, a callback function, um, so it's called, uh, next, so essentially what it, what it's doing is that it will, it will take on the, uh, it will just kind of. When you're, when you're done with whatever you're doing in your middle where you just call next, which means it's gonna go on into the next, next step. Otherwise, if there's an error, obviously you can just send a response and never go on to the next step of your, of your, um. Call like you're never gonna go on to, sorry, this right here, you're never gonna move on to this uh. To these functions, uh, if you return directly without calling next on that middleware. So this is all kind of built in to express. This is just sort of how it it works, um, they, they in middle we such a common kind of functionality that they have it all. I mean, if you, if you look at the Express docs, you can actually read all about how. But you know, the, the, how the middleware works, yeah,

SPEAKER 2
um, just with this authentication stuff, um, given one of those end points, uh, which is like a. Um, you got. Authenticated to access it, but The Uh Oh yeah, yeah,

SPEAKER 1
so in that case, so it could either have the header or not, yeah, yeah, it could either be authenticated or not, yeah.

SPEAKER 2
You suggest like to Well, yeah, I mean in that

SPEAKER 1
case, um, if, if you had I mean you could, you could have either. Um, Uh, I mean, I guess basically that wouldn't require a log in required, um, middleware you would just access the header in the next function and check if the authorization header is there. Right, so you, you wouldn't use something you just wouldn't do this because all that this is doing is it's basically just, uh, I mean the way it's defined is it's like required that you be logged in and in that case it's not required it could be either or, you know, and you're using that information in in the controller later on so that's the way I would do it but yeah I mean you could. Um, I don't know that there would be an advantage to any other kind of, um. Middleware function. off the top of my head, I can't think of like why you would necessarily want to do it that way, but yeah. Um, so yeah, so basically this is a common functionality that for many endpoints, so you, you, you would, you know, do something where you're finding the user by the token idea how it, however, that's defined, uh, you know, that would be making a, you know, uh, SQL query, um, and, uh, you know, if it doesn't work then it's unauthorized 401 and you're taking care of that it's done right, um, you just sent back otherwise. What this does is it adds it into the as a new, as a new, um. Uh, it, it basically adds something to the request. It says the request authenticated user ID equals the user ID, uh, that you've, you've basically pulled out of here. So actually in that question that you had, I mean you could if you wanted to just have a. Uh, you know, another middleware function that's just does that action that like pulls the user ID and puts it into that field in the request, um, and then uses that but it just wouldn't have this if part in here right? it. Yeah, yeah, I mean, it's it it's neither here nor there. I mean, you could like put this, this same kind of code inside that one endpoint, um. But if it was some if if that were a kind of condition that you had in lots of your different endpoints then where it's like an optional login, then you would probably make a middleware function or something like that.

SPEAKER 2
I yeah, yeah, yeah, yeah, so you can just create

SPEAKER 1
a new field on your own because there's no, there's no you know this is the original request, uh, from the, you know, from the client they didn't, they didn't have a field called authenticated user ID, so you're just adding it in, um, and then you you because all it is is an object and you can just add properties, you know, as you want, uh, yeah. Um, So, so yeah, so this would be sort of how I would recommend, you know, doing something like that. I mean, of course you can do this logic in your inside of your own. You know, Uh, inside of each of the, of the controllers if you want. I mean, that's, that's fine. All right, um, now a few some more advice. So like I said, we're testing it's the API specification that's the thing you should really be building uh so just like look at the specification before you kind of go in to start coding it, just make sure you understand exactly like what you're trying to achieve with each of the functions, um, I mean basically just creating a new function like a controller function for every single thing in the spec, right? Um, So, if you're using external packages, that's fine, um, like you install new packages. Just make sure as you're doing that like if you, if you want to install a new package, um, make sure, uh, that they're appropriate inside that package. JSON file in the in the in the main like the home folder of your of your repo like what I mean is that like if you don't have what you can do is you can install packages globally on your machine and if you do that, um, then. I try to or we try to run your code and we don't have that package globally installed on our machine, then we're not going to be able to, you know, compile your code, um, and so. So basically, um, you know, the package.json it just has a list of all the dependencies like, uh, all you, you basically can just add, you know, packages in, um, as you need. You probably only would maybe need a couple of them. I'll talk about a few of them in a moment, um, that would be helpful to use, but you're not required, uh, to use them, um. So Whenever you're testing, um, you know, just make sure like if you, if you pull your code and you're doing it maybe in a new environment, you'd have to remember to do MPM install and just make sure that that by doing MPM install, um, that it get make sure your everything works the way way you want like before you upload it, um, and submit kind of your push your final version of it, um, because for whatever reason you might have some environment that you've been working in and you don't realize and. Something isn't there, um, so that when we go and pull a fresh version of it, we run MPM install and it doesn't work. Well, it's better to not find that out like, you know, 10 minutes before the. You know that it's due, um. So, uh. There you can have your dependencies, uh, sort of in in either development or production, um. It's, uh, so, so when you add a package, you can do this dash D and it kind of creates a, a depth thing. And so basically what that means is like if we, if we run the tests, um, uh, and. We Don't if they're installed a kind of development, that means they're only available for a development build, um, and not for the production build. So just make, uh, you probably just put anything under prod don't put things into dev and you're probably fine, um. But bottom line is just try, just try to take your repo, you know, download it into a fresh repo to appear install and run it and see if it runs, you know, make sure it runs, um, and then you're probably OK. Um. So important, make sure everything uh has the prefects slash API one that's a constant inside the skeleton project so hopefully you won't have to do anything about that, um, but you know if for whatever reason you change your code and you're starting to take routes that are like in somewhere else, obviously our tests are gonna fail because we're not doing it under they don't have this kind of prefix in here so it it's all it's in there but you know it happens right? um. And, uh, just make sure you look at the, the latest version of the, the specification, you know, as you're, as you're developing, um. Questions about this, yeah, um, when you see that announcement

SPEAKER 2
that you sent out a while ago that you were gonna like update. Yeah, so, um, I, well, I mean, I actually.

SPEAKER 1
I was having trouble getting the the script to work actually, yeah, I'm, I'm, I'm still trying to, I'm trying to just have it push automatically into people's repos, but the, the thing that I worry about with this is that like then people need to pull the change, uh, into their local repo if it's if I'm pushing directly into their repo, so I was. Yeah, um, thanks for, for bringing that up. I, um, so, so it's just that one thing about the default value of zero. I will still try to, to push it through. I, I guess the spec itself, nobody should be changing the spec file anyways, so it should be fine, but yes, I'll, I'll push that through. So if anybody have questions about that, so I mentioned that just so you, so it's clear, um. Uh. Yeah, I mean So like if you, if you download this kind of YAML file, um, you know, if you, if you, if you've already pulled and you're developing locally, if I push to the repo uh, uh, a, a, a change to update this YAML file, you won't see it on your local, um, poll unless you do a get poll and see it, you know, pull it down, but you couldn't see it in the, in the repo so that was just the, uh, sorry, this, where was it? um, it was under games, right? Um, Yeah, this price integer. I'm removing this default 0, ignore that under price. Um But I'll, I'll push that through. I'll send another message about it just to make sure everybody's clear about it, um. But what what this is saying is that if you don't include a price and a get request on the games, if you follow the back, it's gonna be a default value of 0. So if you just don't include it, you're only getting the free games. So there's like no get request that just gives you all of the games, um, which is kind of a problem and it's actually. Um, yeah, I mean it makes it just doesn't make sense, right? Like, so, so you can always put the price of zero in if you only wanna get free games, right? Um. Uh, cause it's less than or equal. So there's a, there's a mechanism to get free games, but we don't want to only get free games if, if you omit that, that variable in the, in the request. That makes sense to everybody. OK, um, Yes, um. Where was it? All right. All right. Avice number 2 comes to image files. So. Um, chances are, you know, you, I mean, you started looking into this, you haven't even thought about this, but the question is like how do you actually, um, handle photos, right, because you're gonna have to, so, so there are the reno tests, you know, there are tests for kind of putting, um, you know, uploading the images for like the users and for the, um. Uh, Uh, for the users and for the, uh, for the games, right, um, and there is a photo, uh, directory so that photo directory like if you look at at the get ignore, um. Like, here, let me actually pull up the. The repo. Oh shit factorification Um All right. So in here, um. There's a storage folder. So this default, this default folder is what's used to populate the database, uh, with default images, um, when you run those, um, those back end, uh, and points that are, are there, um, but. Essentially, when someone uploads the files, they're gonna put it into this images uh folder, uh, here. uh, so just make sure this folder is here for whatever reason like you don't want to delete it or anything like that, um, because that's where you're gonna be storing and and loading because you don't store the files, the image files that are uploaded. In the, um, in the database, obviously, you just, you just store it in the file system and so it needs a place to store that, um, and it goes inside of the storage images, um. It should be OK with the way we set up, get, uh, but just make sure. That so the the storage photos is tracked. So if you push your repo up it's gonna make sure the folder gets kept, um, even though it's empty, but any kind of files you put in there like as you it's like so if you're running locally your server and you're uploading photos to your server and it's storing the files there, when you push, you're not gonna push all those image files up, right, um, because that's in the ignore, um. So, uh, when you're doing it, I mean, one thing is to make sure that in the when you put the correct, uh, mime type for the images, you know, so for example if it's a PNG, it's gonna be image slash PNG, um, or image slash uh JPEG, and so that's inside of the, um. Uh, in the request, you know, as you're, um, sending it. And then to actually handle the file, uh, reading and writing, you're basically gonna need to use some node package that allows you to read and write the files and there's actually a whole lot of them that you can use there's lots of things you can use so I, I just recommend, uh, that you. Uh, use Uh, this package, um. So this just basically you can, uh, you require an. Z slash FS and that gives you like a file, uh, uh, file system, uh. Uh, Like objects. So it basically allows you to kind of do different functions, um, that will, uh. Sort of, uh, you know, read and write files and that sort of thing, um. So you could take a look at that, I mean, it's a way to kind of um. Essentially read it and write the image files as needed because basically what's gonna happen is when somebody makes a request and they send the image file you're gonna have that in the body those body fights you're gonna have to store in like in a file in the file system using something like that MZ package and store the the image file and then in the database you're gonna store the file name so that the file name. So when when somebody like like searches for like the game or they search for the user there's gonna be a column with the file name, you know, in there and then you know, inside of your, your, you know, code you're gonna get the information about the user of the game and then you can read the file uh from the file system and return it in the body, uh, adding the correct, uh, mime type to the header, um. So Um, you can test against the reference server for this. So the reference server has a lot of, uh, queries for handling images, so you can test to make sure it's working like correctly, uh, for what you expect, um. So the third piece of advice is um abound around the idea that you are how to handle the password in the database um so the best practice is to use uh some kind of existing library to encrypt the password. And then put the encrypted password stored in the password field in the database so you never store a password in plain text, um, you know, if somebody's setting a password, you know, you never ever ever want to have that in, in, in there. So, um, you could, I recommend just use this, uh, package be crypt, um, there are other ones that you can use, uh, but you can take a look at it. It basically will, you know, just take in, you know, some. Uh, data, and it, it basically encrypts it with some salt and some other things, and it just, it basically creates an encrypted string version. And then what you do is When somebody goes to log in, you, you, I mean you have the encrypted password in the database so you run the the password that was sent in through the same encryption and then you compare the encrypted passwords to each other, right? So you compare those rather than the, um, you know. Uh, storing the plain text password in the database, um. For generating the authentication token, um, that gets sent back, you know, so, so when you that author is off the Z uh send like so once once you've logged in you need to send a response back with a token, um, that says, um. You know, basically this is some random token that says you are this logged in person, right? Um, and so there's lots of different ways you could kind of just randomly generate some string of some sort, uh, but, uh, one package that exists for that is this one called ran token so it just generates a random token, um, and then you would use that as your authorization token that you would send back and forth, uh. You know, for your authenticated queries, right? Uh, So, so, yeah, take a look at those, um, if you have further questions, obviously feel free to ask in the labs or ask me or or anything, but those are, those are like kind of the biggest sticking points, you know, historically, you know, I mean we run this, this project, this assignment many, many years, uh, in different forms and so, you know, things like handling the images, you know, how to, uh, do the authentication and the password, uh, handling, um. You know, those, those kinds of things, uh, uh, come up again and again. So this is some, uh, advice to kind of give you a head start on all of those. Um, So I guess lastly, um, I'll just say that you know, I would suggest getting really working on it this week, um, and you know, because next week the labs will get really busy they always get very busy right at the end, um, right before the due date. So, you know, if you start in on things early and can ask questions, uh, that's always I guess better. Any, any other questions now before.

SPEAKER 3
Photos. So for photos we're just checking if the my my type is correct, right?

SPEAKER 1
Yeah, yeah, so like in the, um, uh, like if I think it's. Um, I believe it should be in the spec. Um Yeah, so Uh So right here, so you see like um if you're putting an image, the request should be sent with this content type. Uh, image slash PNG, that's the mime type. So, so you have, you should have that, uh, header. So basically that tells the, the server to know to save it as a dot PNG file because otherwise you're just like when you make an HTTP request, right, you've just got your headers and then you've got the body and the body is just gonna be a bunch of bytes, um, it doesn't even know that it's a PNG file or what kind of thing is being sent so you use, you add that into your request. Uh, as a header, um, and then. You know your server should be able to save it as a dot PNG file and then you know, send it back. Same with the then this one's for JPEG. It's image slash JPG and for GIF image slash GIF. So we will have, we have an example of images of all three types, um, in that folder, um.

SPEAKER 3
So my question was that, um, do you have any validation for any binary content or do you? And rely on the clients in the game. Oh, verify that it's.

SPEAKER 1
Oh yeah, no, you don't need to do that. You just assume it's assume it's a valid PNG file. Yeah, yeah, sorry, sorry, I misunderstood. Um, yeah, so I guess the question for everybody is like you don't have to verify that the image is like a is a like correctly encoded PNG file or JPEG or anything like that. We'll just assume the user is sending, you know, correct data, um. Yeah. Uh, yeah, and so you just send that as just this raw binary, um. Yeah, so you can look in the, in the, look at the um. The Bruno tests and you can see sort of how it's how it's set up for that. Cool, that's a great question. Any other questions? But the Pardon?

SPEAKER 2
If you had a dog, would you call it Bro?

SPEAKER 1
Uh, no, probably not. I have no idea why it's called Bruno, the, the app, but yeah, all right, um. Cool. So I'm gonna, you know, we basically use the whole time you kind of going over this, but I think it's worthwhile because it'll gives you a head start, um. I'm just gonna go, um, do a little bit more on what I was talking about last week, um. tell you where it was. Alright, so I'm actually, I mean. I wasn't quite this I, I, I, so we're talking about rest and I, there's a couple more slides there, but I, I think they're pretty straightforward. You can look at the slides if you want, but they don't really add a whole lot more, um, so I'm just I'm gonna start at this point. So I had a question actually about about rest, um, and so the idea was that, um. Like I gave us examples about like uh a get request that had delete and I'm saying that's a bad example of course that's that's only a bad example if what that query actually does is delete something on the server so actually maybe I'll just go back and show it to you so you know what I'm talking about. Uh, yeah, this, this example here, you know, this is only bad. If in fact it does delete something and change the state on the server, so the whole point about RET is that is that it's about, you know, that certain kinds of HTTP methods should be safe and item potent, you know, and. That has wholly to do with what the state of the server is. It has nothing to do with the state of the client and what the client application is doing. So for example, if you had this get request and it had this form, but action delete what that actually meant was I'm requesting a a form that allows me to sort of enter in a delete action or do something like that, a subsequent action. That would be OK because that request is just a read only request and it's just creating a form or something on on the client side. It only becomes nonreful if this action actually deletes something on the server side, right. Um, so, um. So rest is a kind of uh. Uh Become kind of a popular way to develop uh you know web servers um. And um partly because it's it's built on um top of HTTP too um it's it it it's essentially a uh you think of it as kind of a stateless um request system right so and the and the idea being that. You know, whenever you make a rest, uh, request, um. You don't, um, the server should not have to kind of, uh, Um, it shouldn't require the server to have any kind of notion of the application state sort of in in connection with with any given client so you know it, it should, it should have its own state and if you make your request, um, you know it could be one client or it could be another client, it should, you know, do, uh, you know, whatever, you know, it should take whatever action it it it needs and so, um. So all of the information that it needs all the parameters, the context, you know, the data, um, has to all be included in that request, um, sent so it doesn't kind of, uh, manage anything and and ideally when you do that when you make your request to like an endpoint, the entire resource should also be returned in. Yeah Um In that one request, so you shouldn't have to make multiple requests to get the information, uh, that you need. So this kind of way of building up your, your, your application where it's, it doesn't have to maintain a state on the server side is it just makes things a lot more performant you don't need to manage all of that. It's, um, it's, it just simplifies the design of everything. You don't have to make assumptions or build up some kind of, you know, representation of, of state. Um, and you don't need to kind of synchronize, uh, information, um, so like, uh, a REST API is like in a way it's, it's much simpler from the server side, uh, to kind of design and, and, and implement of course that you do need to then manage state, um, in some other way. Um, if you need to, to, to do that because the requests themselves don't have like an ongoing state. So and so another way to think about this if I make one request and then I make a second request, the second request knows nothing about the first request, right? Like it can't know anything about that, um, so that information has to come from somewhere else, um. So another thing about rest is that um is the notion of how the URLs built and we've already seen some of this already um when I was showing you the the API uh requests um but this is sort of, you know, part of the whole idea is that you the rest should be kind of uh. Technology independent like you should have an endpoint like we have in our API and there's nothing about that. There is, there's like absolutely nothing in that URL that tells you that you're building with a no JS server versus, you know, PHP versus ASP or whatever, right? All of that stuff works the same regardless of the URL, uh, or that you're you're using so all the implementation details gets hidden, uh, from the end point. Uh, ideally, um, to be restful, so these are, you know, once again, rest is kind of like a, it's like a, it's not really a standard, it's more like a, it's sort of more of a, um, best practice, right? Um, and so one of the things is that you try to keep them consistent in the way that you, you create the actual URLs so if resource names are kind of like the nouns of your system, then you should kind of just keep it. Consistent, like, so for example, um, like in our cases we've got games, users and so on, right? So we use plurals, um, versus or you could use singular, you just pick one or the other, um, and, and so on, and you should try to keep things everything lower case, I mean, uh, and. Uh, not use sort of so, so part of the problem is because you're using URLs like characters like spaces, um, and things are not very, uh, nice and user friendly, so like hyphens are better if you wanna put a space into um into a uh into a URL you have to use like some URL encoding it has that weird sort of like percent uh symbol, you know, and then some number or whatever, right? So just use um. Oh Like, um, hyphens and things like that, um, and, uh. And and then the the last thing is that. If somebody puts in part of Their end point into the URL path so this is not something we actually do in in the API, um, but ideally in a rest server what you do is if you put in that it should actually return information on how to make that request. So, so for example we have in the spec. Instead of giving a 404 error because it's an incomplete URL, it should actually provide the user the information to make the request. Like it like what parameters should you send in and, and so on and so forth, um. So, um, there's some, there's lots of issues with rest. I mean, it's, it's, um, definitely not the perfect thing and we'll, we'll start tomorrow. We're gonna talk about graphQL as another kind of technology that's a more modern, you know, update of it but you know, bottom line is it's um. Because it's stateless, it does this kind of request response thing that you can't make push, you can't do push, uh, um, events you can't broadcast information to multiple end users so there's lots of communication kind of protocols that. Are difficult or impossible to build in a restful uh server API that you might actually want to use in other situations and we'll talk about ways that could be done and so you end up having to make sometimes multiple requests and responses um for certain things, um. And, you know, You can uh Um, well, we're kind of out of time, but you know, we'll talk a little bit more about like underfetching and over fetching and so on, but but bottom line is that you don't unless you're unless you're, um, API is strictly kind of mapped to exactly the kind of information your client needs, you get into a situation where. You invariably have to make multiple requests to get all the information you need and so that's, that's a problem. All right, I'll just end there and we'll pick it up tomorrow.

SPEAKER 0
number. Yeah. OK OK. I. Please. Oh yeah. you got there. I don't. that. it's like. I quick, but um, just quickly with the types, because I noticed that so far like all the control methods whatever just promise any, is that something we should be aware of like should we have implemented? I mean that's mostly for simplicity so so part of the issue is just that. To make it work with TypeScript, um, you know, you have to have the typing in there, but. Uh, you know, there's basically express types, um, Um, but any, it just makes it easier because it effectively. Makes it easier for you to build that you know that about the underlying, you know, express typing, uh, I meant models, models. Uh, right, so, um. Because I've remembered in the lab, I think. I like music. I haven't I joined Yeah, yeah, yeah, is that something I should be. It's what you could, you could have the return types, uh, that's sort of up to you and what you, what kind of, I mean that would be I guess the, the correct. Yes. Tight and you can do it in optional fields and things like that for. Turn Uh, so you have a type. Uh, you can find the time.


SPEAKER 0
He. I OK What's Um Yeah No No We should I

SPEAKER 1
All right, uh, everybody, uh, so I heard it was pretty busy in the labs, um, so, but it's good to hear that people are working on the project. Um, any questions about that before I start? No, OK, um, so, uh, I'm just gonna keep on moving to the material. I'm, I'm still back in week 4 slides, but we'll, we'll just keep on moving through, um, so. I have been talking about uh rest and I've talked about the fact that um really both HTTP andE which is sort of based on uh HTTP uh have this assumption of statelessness, um, so what that means is that every time you make a request to an API, um, you know, it's an HTTP request. You make that request and it just the server gives the response um just based on whatever happens to be inside that one request it's not like it remembers that it had another request that came before or anything of that sort so it's a fundamentally kind of stateless protocol uh meaning that it doesn't remember anything between multiple uh messages so how is it that. You actually manage state in a web application um if it's built on HTTP and you're kind of building an restful API as the back end, how do you handle state because probably you're gonna need some kind of uh notion of sessions or users or something of that sort, right? So, um, I'm going to go through a few of the different approaches and some of them are things that you will use in the assignment, um, and it's just basically an overview of different approaches that you can can use for that, um, so. This is a mini overview of what I'm gonna talk about. I'll just head right into it. So In general, uh, we can conceptualize state actually across different time scales, so. I mean, in the most kind of the shortest time scale is basically the idea of the stateless, you know, uh, stateless situation where you're just making individual HTTP requests and there's nothing that is going to be like stored or you know there there's basically it's forgets everything that happened uh before. Um, but in terms of the, like the scope of the application goes, like there's other kinds of, of state that we might want to consider, so. The kind of classic, um, one sort of for a web application is the idea of a shopping cart, right? Or some kind of um. Uh, some kind of, uh, you know, transaction that is occurring, uh, between the client and and the server and so that would be kind of like the next stage like a business transaction, uh, kind of scale in general it's just within the scope of that particular transaction you might need to maintain some sort of state and depending on your implementation. That might be handled on the client side primarily it might be handled on the server side or it might be handled across both of them, right? um and so you know that would require, you know, if it's gonna be on the, on the server side you'd have to basically be storing some information in a back end database about the transaction, uh, that's occurring, um. Then you get, you know, span it out a little longer and you can we can talk about session time scales. So this is basically like your session, um, you know, the fact that these requests are coming from the same user in the same browser during the same session, right? It might not there might be multiple transactions that are going on within that session, uh, but it's the same, uh, user. Then if we zoom out a little further and think about kind of like a a common user for your application, they might have preferences that are sort of um you know something that it's going to uh kind of live um that's sort of tied to the user but they're not tied at all to the session right because if you think about a session. In a browser, all you have is um the idea of a particular device and you know a user basically using that device and connecting from that IP address or something of that sort but preferences has the notion that there's some kind of uh something kind of kept across all of these multiple sessions that is tied to some user ID or account or something like that. Um, and then I guess the longest one would be, uh, what we call record state. This just means that, you know, essentially, you know, there's some kind of permanent record of something, uh, that, you know, every time you connect, um, it's going to be part of the, the, the state of the application that is remembered for for the next time and it might be even for multiple users, right? Uh, so like for an example in the game website I guess that would be sort of like the state of the overall kind of, you know, database of games that we have and so generally speaking, I mean this is not kind of like any hard and fast rule, but you can kind of think about them kind of operating at different, uh, time scales. um, some of, you know, you've got some state that is really you really need to maintain some kind of notion of just what's going on in a particular transaction. But then in other cases, it maybe needs to be tied to a user, right? Um, So, uh, when it comes to session state information. Um, So it's basically the idea here is that you know, you have a server, um, and. You have the client and the client, you know, it's going to be making multiple HTTP requests and you want to understand some information about about this client that's making those uh requests so um in particular you might wanna maintain some consistency about. Which client is making a request, so if you recall like from the server side, you know, there's nothing inherent in HTTP that links anyone request to a particular client, um, in order to do that we need to hook in some idea of authentication, right? um, so. Is there some way to know that this is the same user uh that has been authenticated previously through some transaction or some some some request previously has has authenticated them and now we're saying this is the same the same client is connecting um and then so there's which client is is connecting but then also that needs to have some understanding. Of what actions are allowed, so like what is authorized um for a particular client because um you know certainly not all, all actions are authorized by all clients right? we see that even in the API that we're doing right like the the owner of a a game is the only one who can actually um modify it, right? And so if if they. If they haven't previously like authenticated that they are that owner, uh, then they are not authorized, uh, to do it, um. So Uh, You know, basically, you know, any, I mean, so, so that's kind of a very common reason for having session state information. uh, you might also like just think about it as being any kind of thing that's a longer lived transaction, um. You know, things that will that have to be kind of built up by multiple stateless HTTP requests. You need to, you need to know that like who who's making that request each time, uh, and maintain that. And like I said, that can be, you know, this information can be managed either on the server side or on the client side or it can be synchronized between them, um. So, uh, one of the easiest ways to do this, um, is you can just add a parameter to your request so you can make like a get request and add like one of those uh query parameters with a question mark, um, and you can actually put some kind of session variable in the parameter of the HTTP request, um. So it's not like they're going to be, it's not like the username and password is is in the request, uh, but you have some kind of unique random identifier, right? So it's sort of like the authorization ID, uh, that we do, um, and so you could, if you want just include that with every request, uh, you know, you could just take the do the example to come and then like pass it in, uh, like this, um. Any thoughts about why this might be bad practice in general? Any ideas about that? Yeah. I Yeah. Yeah, exactly. So I mean all you need is if you have that session, um, ID or whatever you can basically just copy and paste it into an URL and they can be you, right, essentially, and it's not all then it's also not tied at all, uh, you know, to a browser or a client or or anything like that, um. So generally speaking it's not great practice. I mean it would work um and you know if you're using HTTPS you know the actual request um. Uh I mean Yeah, I mean, it's not, yeah, even if you're using HDPS, it wouldn't, it wouldn't be a good idea, uh, never mind, don't. So, um, so the other thing that you could do is, uh, you could use cookies, um, so. Cookies are a way to maintain session information and it's basically kind of a little little key value um sort of store uh that are implemented by the browser um so in this case with a cookie, um, the server it like issues some kind of random identifier, um, and then and that's sent in a cookie to the client. For a particular username and password. So you log in with your username and password, and, and the, the, uh, the, um, server sends the cookie to the, um, back to the client. Um, then that cookie lives on the client side and the client will kind of send it back with every, uh, network request, um, so it could be like in the post, uh, like data or something like that, uh, but. The key is that the username and password are not sent. You only do the login one. So this is effectively what we're doing in the, in the API assignment is that with the, um, you are. You know, you, you only log in once and then you, the server generates the random ID and then you send that random ID. Uh, back and forth, um, but. Um, essentially, um. They like a cookie is just um it's just a small piece of data like could actually take a you know um it can be kind of take a different forms, um, but you know, it comprises of different uh name value pairs. Um, it can also have attributes, um, such as like an expiry date. Um, and so name value pairs might be are the things, so, so the cookie is sent to the client and the client sends that cookie back, but it doesn't send the attributes because those are sort of that's extra information like for example the expiration date or something like that those are attributes that are sort of described how for how the client is supposed to handle uh the cookie, um. And so browsers are kind of built to like handle cookies like automatically, they store them in the browser, um, you know, memory somehow, um. And so you can use it for any kind of maintained state information. So, like the items in your shopping basket, um. Items in the shopping basket, you know, they could uh variously so so if it's, if it's in a cookie, right, um, then it's gonna be kind of device dependent, right? Because if you think about it. The the information is being stored on the client, but if you went in and logged in somewhere else, you're gonna get a brand new, uh, cookie, right? Um, so it might be better if you had something like items in a shopping cart to actually store the state of that on the server so that if you, if you leave from this computer and I go over to this other computer and log in, um, I'm going to have, you know, the same. basically recover my my shopping basket, but it sort of depends on how you want to implement it but also, um, different types of browser activity information, um, so for example, what if you have like a multi-page, uh, you know, process where you wanna register and you have to go through certain things if you wanna kind of restore the state of how far along in that process you are, uh, you might store that, uh, in a cookie, um. That way, if you were to close, you know, uh, the website and cut back, then the cookie is still there. So, um, there's lots of different types of cookies. I mean these types of cookies are sort of defined by standards and browsers will, will kind of, uh, are, are, will implement, you know, how cookies are handled sort of in a consistent way, um, but these types of cookies like our, you know, sort of have different um. Uh, sorts of um. Functions. Um, so, The the first party cookie, I mean, that's just a cookie that's sent by the server, um. Uh, to which, like, basically it's, it's set by the server when you you when you first connect, um, it's a little less useful. The thing that you normally would use is something like a session cookie, so this will exist only during duration of the browser session. So if, if you were to close your, uh, browser and then open it again. And you're using a session cookie, then the browser will um will delete that cookie generally speaking. I mean you could basically set these policies in the browser, uh, so you know um how things, how things work, but in general, like a session cookie is intended to be one that does not persist outside of that session, right, which means if you close the browser uh. But a persistent cookie. Is one that's not deleted when the browser closes, um, and is used. I mean they're they're kind of known as tracking cookies and so persistent cookies are actually why cookies, I mean, I don't know if you've ever been to a European, uh, website, and they always say, you know, we want the right to like store cookies on your device. At some point cookies got flagged as this really bad kind of. Uh, you know, potential kind of like for tracking, you know, for privacy violation and so on, and it's because the EU has very strict laws around that. They enforce the idea that if they have a website that's serving EU customers then you need to have a sort of a warning about about the use of these persistent cookies. I mean, the thing about it is that actually in fact there's way more kind of um uh invasive tracking methods that that uh people use now besides cookies, but it seems like cookies kind of got, uh, grabbed on to, um, originally, uh, so the. You know that's often, uh, I mean it can be used for like advertising so like if you have cookies, um, you can kind of track you know user behavior across multiple sessions, but it can also be used for things like remaining logged in. So if I go to Amazon and I want to buy some books and then I close my browser and then I open it again, I'm still logged into Amazon, right? Uh, and that's probably using some kind of persistent cookie to, to do that, um. Almost always your um uh the cook I mean these are not mutually exclusive categories, but a secure cookie is just one that is is served it that that can only be transmitted over an encrypted connection um so what this means is that it's, it's one of these other types of cookies, but it's, it's flagged as saying it, you know, basically the browser will reject it if it was not sent over a secure connection. So you know this would be, you know, um, you can imagine it would be any kind of cookie that stores information that you don't want people to be just seen visible and plain text over the network, right? um. And then there's other ones. So I mean I guess third party cookies are things, um, might come into so so often those this is also not mutually exclusive from these other ones, but third party cookie is, um, basically one that's maybe set by some third party, um. Uh, to serve some content like advertising, um, Facebook, uh, I mean, had really kind of, um, they did all kinds of stuff, uh, and with, with like cookies and everything to try to track behavior across different websites. So like if you log in on Facebook like you would they could track whether you were they would could track all of the other. Websites you were going to and so on and they got kind of slammed in court in in the EU for that um so it it sometimes cookies can be used in a, you know, quite exploitative way which is part of why the EU has such uh strict laws about it, but they are actually really useful for just maintaining session for an application, um. So, um, Basically, the sequence is sort of like this a little bit more formally is you make a get request, uh, from the browser to the server. So it's a normal, like, I want to get index.htm at HTM or whatever from example.com. So then the server will send a response and in that response, so, uh, you know, you have this is the header right of the HTTP you have your content type you're sending back some HTML you send back a 200 response code, everything's OK. And then you also add the set cookie, excuse me, the set cookie. Um, uh, header and so that set cookie has a particular format like, um, you know, the cookie, this is the key and this is the value, uh, and it has an expiry date on it and so then the browser will take that. It looks at that, it sees that there's the set cookie header and it stores the information about, about what's going on for example.com. And then when you make a request, um, from the browser, the browser actually will, will sort of insert this cookie into the header. um, so when you're writing your application, um, you don't like if the cookie is set, like the, the, I mean this is something that browsers will, will do, they will actually, um. Uh, insert the cookie, um. If of course you're using something like Curl or your some command line tool or Bruno or any of these sorts of things where you have to, you know, explicitly settle the headers, then of course you would need to manually put this in like you're because you don't have a browser that's doing the action for you, right? um. So, uh, some limitations of cookies for, for session. I mean, every browser has its own cookie jar, so of course, it doesn't, you know, you can't go from Chrome to Safari or whatever you're doing and share that, um. And you know, conceptually speaking, I mean a cookie does not in any way identify a person it's some sort of weird amalgamation of different things. It's sort of like a user account, web browser and device all it it's sort of like that intersection is where the cookie lives, right? Um, so it's not as encompassing as sort of like user information which you would have to probably store like if you wanted it to span across all of the different clients and different browsers, you would have to come up with some kind of um server side storage of, of like of that, um. And, uh, you know, finally, of course, the cookie requires the browser is cookie enabled, um, and is set to allow cookies, so you as a user can go into your preferences and turn off cookies. Um, so, uh, you know, if it isn't there, then you can't rely on that, you know, a user of your application can use your application as intended. Um, if that makes sense. So, all right, so that's pretty much cookies. So cookies are a great way to uh maintain state. We'll, we'll come back around to state, um. And when we come around to the second term, when we talk about the browser side of things, there's a lot more you can do now in terms of storing data on the inside of the browser besides cookies. So there's things like local storage and such, but we'll come back around to that when we come to term two, and we're really looking at the, at the, um, client side of stuff. So any questions about cookies before I move on to the next topic? No. Um, OK, so. The next thing I'm gonna talk about, I'm, I'm just, it's a bit of a little bit of a jump, but it's sort of just covering some different topics that are important and that has to do with API versioning so um we've talked a lot about protocols and we've talked about, um, you know, standards for, you know, how we, how the server and the client communicate, um, but. What we haven't really talked about so much is about, um, how like if you're developing an API obviously it's also a piece of software that you're like engineering for users, um, to use and. So one thing that you have to really be mindful of is if you are developing an API with the mind of it being kind of like a web service, like a, a service that other clients might use and they might be attaching to bring in all kinds of different applications, then you really need to be mindful of being clear about how you do handle versioning of your API. Uh, because ultimately it's a product and you need to sort of manage sort of the backwards compatibility of, of what you're doing, um. And so there's Like There isn't like one correct way to do like versioning in an API, um, but there are sort of some different kind of approaches that you can take, so, um. The most important thing is that you, when whenever you're building an API like I mean in in your case, right, you're gonna be building the API and you're building the front and application but there's all kinds of situations where that's not the case, right? You might have. You might be an API provider and in fact there's these websites, um, I'll try to find a link and, and, and share it uh next time but there's websites that just like publish, you know, thousands of just existing free APIs that are on the web that anybody can use, you know, things like weather APIs so you can just make a query and get the current weather, you know, uh, at some city or something like that. So all these APIs exist and they're there for people to use. I mean some companies provide APIs, for example, Facebook has an API, probably, you know, well, when it was Twitter, Twitter had an API, but now X kind of um threw away most of that, um, but anyways, like all of these applications have, you know, like APIs so that you can basically build applications on top of them, right? And so the important thing is you need to have some kind of compatibility between the API provider and then the consumer um and so one of the ways um one of the one of the important concepts is, uh, this notion of semantic versioning how many of you have come across semantic versioning in another class? OK, uh just a couple, OK, um. So, um, and. You need to sort of have a clear way to sort of build into your actual API request a way to um deal with API versions um and then there's some interesting things about publishing APIs so there's just an interesting uh stack overflow discussion if you're interested in terms of best practices it's a little bit dated but so on. Um So why, excuse me, why do we want to, uh, version APIs? Well, Uh, like I just said already, we wanna maintain compatibility with the consumers, right? If APIs change, you don't wanna break a bunch of existing applications that depend on your APIs. Um, of course you might wanna add or amend functionality or new services, so you would need to kind of version for that, um. Sometimes you might have performance, uh, improvements and you know those performance improvements might involve things like, you know, combining two different requests that are commonly done together into a single request, right, because we wanna we wanna map the user or the client side request like what they need as closely to what the API server provides as possible so that there's a fewer number of requests. Um, sometimes you might wanna version things for market testing. You know, for example, you do AB testing where you give out different versions of the API and see, um. You know, you can do system testing, you may have a dev version of your API, a test version of your APA, a production version, um. And also you might have different client bases that you're serving to um so if you if you're doing like business to business there might be a completely different like set of kind of um you know requests and end points that you might wanna provide for a business customer um who's maybe, you know, paying a lot of money for your service versus, you know, like a, a business to customer kind of situation, um. And even you might have different geographic and political region region issues, um, so. Uh, I mean, a perfect example of this is, I mean. I don't know if it qualifies as as an API in the way that we're talking about, but you know, for example, Google Maps serves. Different data depending on where you're making the request from so they actually show different maps on Google Maps, uh, you know, depending on, you know, because there's certain parts of the world where it's contested about which country controls what parts of land and of course in the US they call it the Gulf of America now which is. Kind of absurd but yes they they do do that um so like you know you could you actually will have you know maybe potential to have to filter your services for different, uh, you know, regions and, and so on and then of course you might have to roll back something you finds out there's a bug in your API or it's not working, um, and so the whole point is to sort of develop your API. And keep the client perspective in mind so you wanna make sure that things are going to be as much as possible backwards compatible so like um you know the that the client can can just continue working through the change, um. And that it's forward compatible so that like if the client, um, can, can. Uh, the client can change and not doesn't have to kind of require the API, uh, to change for for the client. So the whole thing is that, you know, really when you're developing APIs, it's a different way of developing, especially if it's like a, a service that's provided for like, you know, many end users for different use cases you have to develop with a different kind of a mindset, uh, really. Um, then if you're just building your own application for your own purpose, um. So I mentioned semantic versioning, so I mean you probably have all seen semantic versioning. I mean you've all seen kind of version 1.0.0, right? Or 1.0.1. Well, maybe you thought they just randomly picked those numbers or how do you know whether to go from 1.0.2 to 1.0.3 versus 1.1, you know, like how do you make those kinds of decisions and there's actually um. Like a a method to that kind of to the madness and the idea is that there's the notion of major minor and patch uh differences, um, and so. Part of the reason why we do this is that, um, sometimes, uh, well, well, first off, um, like, I'm gonna jump down here and just explain what it is and then I'll explain this bit. So like the major minor and patch mean basically mean the following so you make a major version change when you make an incompatible API change. What that means is that if somebody has an existing application that's running on your API. You will go from version 1.0 to 2.0. If that happens, you will expect that their application is just gonna break, right? It's not, it's no longer going to work, um, if they wanna make their application work with the new version 2.0, it's going to have to have, you know, some major reworking of some kind or another. So minor version changes are intended to add functionality, but to always maintain backwards compatibility. So what that means is that like if um you know if an application exists on version 1.1 that it should still work on version 1.2 without any changes, right? It might be able, excuse me, it might be able to actually. Do more things with the API, um, if it wanted to, but it should always be able to work as is at that point. And then, uh, patches are, uh, just like sort of bug fixes, um, so that third version, the the are just like. Um, small, uh, backwards compatible, uh, bug fixes. So that's in theory what you're supposed to do now whether developers follow that or not, I mean, well, that depends just purely on, on how they, how they do it, um, so when you, when you're building your API then. Um, the changing of the version number basically, um, if it's built into your, your URL, it means that, um, changing the version number will, um, I mean you, you can think about how it's gonna be handled by some kind of caching, uh, in your system so we haven't talked too much about browser caches and how they work, but you know you could exam you can imagine that your major and minor. Um, kind of parts of your API version, um, you know, if you want it to be cached, you know, for some, some endpoint, and then the patch goes into like just a, a, um. You know, a URL, um, I don't know, like a query parameter or something like that, then the browser might have like a cached version of the, of, of, of the request. So it's just something to keep in mind in terms of how you, how you construct it, but the bottom line is that it doesn't really matter how you construct the major minor patch. I mean, normally it's just numbers, right? It'd be like 1.0.1 or something like that. But you can use names, you can use other things. Like there's not really like a rule around it that it has to be, uh, numbers, um. You can go to this website semver.org, and they have some more information about the process, but bottom line is if you're building an API, um, you should. Ideally follow, you know, this, this kind of uh process, um, and that's how you would like whenever you have kind of formal release of course you might also have beta versions which isn't even covered here, um, so, uh, like often times after the patch you might have like some kind of version dash beta or something like that or dash alpha, so that's even, but those are supposed to be sort of just development versions that aren't really used in in production. Uh So that's what's going on. You can take a look now at your versions to see whether it makes sense. Um, of course it doesn't follow. I mean, I don't know, like somebody like Windows, they just randomly change between numbers and names and and whatnot. So it's not like you have to follow it with rules, but, um, but yeah. Um, so how do you specify the API version? Well, you can do it in different ways and there's no, um, one right way to do it really. I mean. You can't do it as a query parameter, so you could do, you basically would just have your end point and then you'd have some query parameter like question mark V for the version and then you'd actually put the version in here, um, or sometimes the versions are, you know, in, um. A, uh, you know, based on the date of the, of the version, uh, and so Amazon and Netflix, uh, their APIs work that way, um. The the the other version, uh like the next way to do it is using to actually build it into the API. So that's what we have chosen to do for your assignment. So you have your path and inside of your path you have your, you know. Your, um, server and in name and it's port number slash and then the, the prefix is APIV1, right? So that's the API version built right into the URL, um, and that's how Facebook, uh, does it, um. There is an argument against this way of doing it despite the fact that we've done it, um, and that is that it is some some people think it's semantically messy in the sense that it makes it because you know end points are supposed to be like describing an object um it kind of implies that the version is somehow a version of the object versus a version of the API but you know people are opinionated, right? It doesn't mean that it's it's correct, um, so. Then, like another way you could do it is you can actually enter it as a header in the request. So then you're not actually putting it in the URL at all, but in the HTTP itself, you have like uh some kind of uh uh header. Um, so you would basically have some kind of header in there. Um, problem is that it's hard to test, so you can't actually just type the URL in and like change the version from one to the other. You'd have to use something like Bruno or, you know, Postman or something and actually add in the headers as needed or make, you know, construct a a test using JavaScript or something like that. But GitHub, um, uses, uh, this. It has like a custom request header. Um, So there's one that's called. I mean, there's a, there's an accept header, which is like predefined header, but there's a cus you know, GitHub has a, just a custom request header in there when you use their, their API. So just different ways to do it there's not really a right way, um, but the key thing is just to make sure that you're like kind of versioning your API like once it's out in the wild and people are actually using it, you have to assume that they're using it for all kinds of purposes you don't even necessarily know um I mean some APIs obviously will be kind of gated in the sense that they will have a um. You know, you can have a some kind of, uh, key to give you the access to the API that's often how it is for a paid API services, um, but, um. Even so, you still don't really understand how everybody is using your API necessarily, um, and so it's just really important that if you're gonna be developing, uh, you know, a web application and building an API, uh, that other people are using that you maintain your versioning, um, for that in a way that's like consistent and clear for the for the end users, um. So there's a lot more to it actually um just in terms of looking at API as a piece of software for other for for for end users um and so that you know once you develop the API of course you need to publish it in some way um and so documentation is really key, um, so. You know you can basically create kind of like sort of like using doc tools or something you could build kind of like a documentation for your all your API end points um that's great but you know of course having guides and tutorials and all of this other sort of stuff um is is like um really really uh helpful um. So, um, you know, some kind of like tool that's like designed to kind of help people through how to use, use the API, um. You can also think about like, um, you know. Whether like like. Like, like, ideally your documentation and tooling kind of just has clear explanations of how to directly access the API just by making requests, you know, so you don't, uh, you could just make a crawl request or you could use postman um or something like that, um, and you can just. Just access it, um, and, and test it, um. So That's one option, but then obviously if you want to build adoption, um, of your, of your, um, API. Usually having some kind of software development kit that's kind of built on top of the API um in kind of the developer preferred languages so if you know that lots of people might be writing Python scripts and want to use your API then create like a Python software development kit that basically creates Python functions that wrap around all of these these endpoint requests, right? um. So, um, You know, it's just basically a library, you know, you build a library and that library sits in front of the, you know, making the, the, um, the requests like the rest API requests or whatever, um. And uh So that makes it just a straightforward. It's easy to install people get get started right away, and usually, you know, if you go to lots of like APIs out there, they'll have like kind of some documentation and they might have like different languages that you could use, you know, so common languages I guess would be Python and JavaScript, but you know, depending on what you're doing, you know, you can have all kinds of different, um, uh, language, uh, SDKs, um, so you have SDKs and also like samples are really good, um. In terms of API as a product, there's a whole strategy around how you make that work. I mean, obviously we have, we have service oriented, um, kind of, uh. Products where uh you know, instead of um you know buying software installing it on your computer, we basically just have a bunch of web services that people consume right and then they pay into that uh and then there's the question of like how do you make that API accessible? how do you turn it into a product, how do you make that work and I obviously there are different strategies to that, um, so one of them is like. Some kind of free or freemium model for for developers. I mean, this is sort of all over the place, so like you can use like the Google Maps API and as long as you make fewer than something like 10,000 requests a day. It's free, right? I don't know the number. I just made that up, but it's some some number of requests you can do for free and then if you want to exceed that, so say you want to build a commercial tool that has lots and lots of requests on their API, well then you pay into it, uh, and you use your API key, uh, to do that, um, so this is the model that you see all over the place now and what you know, it sort of relies on the idea that. You know, you're going to have a large enough user base and people are gonna get kind of hooked into your ecosystem enough uh that eventually it will pay off so you give them, you know, it's kind of the freemium models the loss leader idea you just bring people in to start using the API and then they build software that depends on that and then they're they're kind of hooked into it. Um, So, uh, you know, you can do things like, uh, you know, just there's lots of different things you can do to make your API easier to use. So if you do have API keys, have some way to instantly kind of generate, uh, an API key even without sort of setting up an account or anything like that, um, building sandboxes for developers to use and that sort of thing. And then before everything's done, like when you're ready to kind of publish, have some kind of landing page like a web page that describes, you know, all the, basically gives access into all of this information and makes it available, um. So, um, that's just a little bit about sort of looking at the API as a software, um, you know, product and how you would, you know, how you can go about, um, doing that. So, um, At this point, uh, let me. Just real quickly, uh. Open up my other Slides because we're, we're just running towards the end of the lecture, but any questions about any about versioning and about publishing APIs or anything? I mean, it's, I think it's pretty straightforward, right? Um, yeah, OK. Um So, um, All right, ever since I only have a couple of minutes, um, I'm not really gonna dive into it, but I, I just want to sort of set up the next topic, um. So, so, so far, you know, and in, in assignment and lectures we've talked about using. HTTP as the primary protocol for the communication between the server and the client, right? Um, But, um, and in particular that, that you could build like a restful API on top of it using these get requests, put requests, post requests, that's exactly what you're implementing, right? It works fine in some cases except it is somewhat kind of rigid right because you have to define all of your end points and all of those uh end points you have to kind of understand it's a bit like building a relational database right? you need to know what your schema is you need to understand what kinds of requests people need to make, what data they need and what information they want to pull from the server, um, and so that has. Been seen as limiting in in many kinds of situations and so the next topic that I wanna talk about is a sort of a more um just a newer kind of uh approach uh to building APIs which is graphQL which is a sort of it was developed by Facebook originally but it's essentially a way to. Um, sort of, uh, allow people to make the requests not by in terms of end points but by almost it's like a almost like a pattern matching thing where they describe what they want, what data they want and what form they want that data to come back in and then the server tries to kind of fit that in. So we'll go into more detail about that, uh, next week, but, um. Yeah, that's, that's pretty much it for today. If, you know, if you have questions about the assignment, of course, feel free to, you know, contact me or ask in the labs, um, but yeah, that's all for today. Thanks everybody.

SPEAKER 0
And I Oh Yes. OK That Yeah OK. I Yeah I Great. No. You all. Uh OK Yes. I Oh, here we go. I No I. Yeah Actually Yeah. I Yes Yes. That's that's. Oh no, you will be. I think yeah. We. I made it. So Yeah. which is the. Yeah. I Yeah, that's no no no. Yeah. Yeah. Well. Oh yeah. Yes, it will be. Ju. I Yes Yeah I I.

SPEAKER 0
OK. What the I just. Yeah. It's like I guess I did go to about 50. What the. because you don't. here's the one. It. trying to get that. OK Because. I got my program. Oh. The How I OK. Yeah you will that commit.

SPEAKER 1
All right, uh, let's go ahead and get started. um, so before we start, any questions about the assignment? Hopefully everybody's cracking away at it. I see some hands up, yes.

SPEAKER 0
Of some sort available so we can see what's fact. Like up because I remember you said like, oh yeah, you don't if you use types or not. Uh, so basically the testing is just gonna be based

SPEAKER 1
on the, um, uh, series of those similar kinds of Bruno tests that that you've seen but just more comprehensive coverage of the of the API, um, and not every element of the API obviously I mean that would be too much but it's essentially just on that so I mean we're not we're not looking at sort of how you write your code or you know how you comment it or any of that stuff so. Your code can be uh spaghetti code that's fine. uh, it doesn't matter to us, so. Any other questions? Yeah. And you refer to that. What are you You delete's image, who doesn't have If you delete a user's image, it does not. Um, I don't know, it's like. Uh, yeah, I, let me, I, I don't know. It depends on what's in the spec. Let me see. Is that unspecified in the spec is that? OK, um. So is this delete the user image or the yeah. Like, uh. So this one Is that what you mean? Um Uh, So the question is if you. Delete and it doesn't have an image. Uh, Yeah, it's not um. Uh, I'll have to double check if it's not specified, then we might not have a test for it at all, in which case, but, um, I think, um. My Immediate thought is that because it's item potent should be OK if there's no delete, you should be able to just do a delete and it should be OK, but it shouldn't, it should only delete it if it's there, but then it just doesn't do anything essentially if there's not an image, but I'll double check that. Um, I'll look in the in the test maybe I could, I'll check, uh, after the, the lecture and I'll send an email out on on learn about it. Cool, yeah. Um. Yes, yeah, yeah, exactly so I mean if they don't if there's something that's not specified in here then you could pretty much be guaranteed that we don't have a test for it. If that makes sense, right, yeah, yeah. Getting Uh, Well, it should be um. Uh, no, I don't think so, right, because, um. Yeah, it's not a, it's not an author's because you wanna be able to get the reviews for game. Like if you're like imagine you're on the website and you wanna be able to see the reviews reviews for the game, uh, you don't need to be, uh, logged in and there's nothing here but like unauthorized, um.

SPEAKER 0
Sure, so yeah. Yes, um. I wish list that on again said games on already and you try to do it again. Is that the same case where you can just do you send it to?

SPEAKER 1
Uh, if you wish listed it and you do it again, um. Let me just see. Yeah, it's, it's unspecified so um. I would say there's If it's not in the specification, I would probably don't have a test for it, but I would say OK yeah. You know this is actually quite an interesting so as much as you try to like specify something of course obviously it doesn't, there's a lot of cases where the specification might be still ambiguous or um or also um. Or just not complete, right, um, and that's, I suppose if, if, if anything else maybe you take that as a learning from this experience, right, um, as well as you know that that we tried to do a fairly comprehensive in terms of our our spec and all of that and then we built the tests based on the the spec as we had kind of thought about it. So, uh, you know, if it's not something if if there's like a behavior you think it should have but it doesn't say explicitly in the spec then it probably. Isn't, there's no test for it anyway, so you basically implement it either way, if that makes sense. All right, cool. All right, uh, so yeah, I'll probably be a bit busy in the lab, so just keep that in mind, um, you know, for the rest of the week. Um, OK, cool. All right, so I'm still on the week 5 slides, but I'm just gonna, I, I might actually skip over a small part of this so I can catch up a bit, but. Uh, when I was talking last time, I, you know, we covered things like rest and then I started to say that, well, there's some limitations to. Rest and also HTTP sort of you know if you're building a restful API that's built on top of uh uh uh top of HTTP because it sort of has assumes this kind of stateless um model, um, unless you have a really nice coupling between what the server provides is the end points and what the client needs for the application you're gonna, you're gonna end up with mismatches, right? um and then what. What that ends up causing is either over fetching, which is where you get more data than it's required, or even more I guess even worse than that is under fetching, in which case you have to make multiple requests to the server kind of to fill in your, your information. So, um, since like if you've got some kind of complicated data structure but you haven't built your end points to allow for that. You will, you know, do something like this, like if you had an auction website like a TradeMe site, um, you might, uh, get the auctions, you get the bids, uh, you might get something about users, uh, you might get the photos for the, the auctions, so on and so forth. So all that, it's like too many requests and that's the the last thing you wanna do, uh, in kind of a web application is sort of. Rely on heavy network back and forth because that's the slowest operation in the entire application um. Uh, you know, it's, you know, it could be on the less than a second, but it's still like on the order of like milliseconds of every request, you know, and you're accessing some server on the other side of the world it has to send the data back and so on, um, and for mobile applications in particular, um, it's really undesirable because you want to kind of minimize the network, uh, requirements for any kind of mobile application. Um, and as it turns out, many mobile applications are actually just web applications wrapped up sort of in a thin browser, um. So yeah, so I guess just to define those so overfetching, you download more data than you need. Uh, so, for example, if you only need a list of usernames, but you get all the information about every user, um. So because you would get like a JSON object with all this data about the profile, but all you need is the user name. So you wanna just, you know, have an endpoint that only gives you the information you need. The under fetch is the opposite. It's like when you download. I find my, my mouse there download less than what you need, so, uh, then you do more so it's like an N plus one problem. You have to keep kind of accessing more and more information, uh, you know, you get like an ID and then from that ID you get some other information and so on and so forth. So like in this example. You need a list of uh uh recent three friends for a username so each item and users, uh, you need to need to get then the information user friends, in which case you have to make 123 requests right for each of the friends, um, and so on and then yeah. So So rest, I mean that's that's a problem with building any kind of API like we've been doing um but there's some other issues that are problems, uh, in sort of. The way that that that we kind of define our API functions. So first of all, and the rest uh end point there's no, there's no kind of notion of strong typing, so, um, you can. For example, you know, if you were to say I want to, um, you know, request, uh, um, you know, some primer has to be an integer versus a string, there's nothing that kind of liked, you know, allows you to like define that strongly in the actual. Uh, request, uh, and there's also a lack of any kind of machine readable like metadata that kind of tells the tells it like whether or not you're matching the different types. So integers and strings are one thing, but so for example you might have more complex data structures. So if you had something like uh you're doing a search for APIs on events, um, and there's some field called event start time. Well, you could define it as an integer, but why is it an integer? What does that integer actually mean semantically it's like what is that the number of seconds in Unix epoch time or who knows what, right? So, um, why not have like a date data structure that's kind of more more clearly defined. Um, and then that way, you know, it would work and then there's also, you know, there's the question there's like implicit like if you use an integer, it's like how you actually do the mapping of that and, and so far, um, so on, um. And then I mean because things aren't strongly typed you don't even really know whether the types match uh in different kinds of uh end points so like if you had uh events post uh end point for example um and you needed to, it has a starting time kind of um parameter like you know it sounds like it's the same. As the event starting time that you might have used elsewhere, but there's, you know, maybe that's defined in the events table, but are, is it? I mean, you don't really, there's nothing that kind of is, is clearly mapping these, these things together like you would normally have like a, a strongly type programming language like what we try to do with TypeScript for example instead of uh JavaScript, um. So that's like kind of a you know a limitation I guess of of rest APIs. So sort of with these kind of issues in play like this this problem of like kind of matching the request from the client the server and having the you know the the problem of overetching and under fetching and also not having things very strongly typed, um, sort of in that space, um. Facebook developed uh GraphQL because they were creating their own internal API for all of their services and then they ended up publishing it out so other people could use it so people could write applications that could sit on top of Facebook and make requests about you know users and posts and whatnot and in the process of that they developed this specification, uh, because they thought it was really useful and it's now like this open source specification. Um, and it's, it's basically a specification for how you specify the data itself like the strong typing of the data fields and so on in the requests and the responses that you're, you know, that your server and client are are dealing with and also specification on how to query data that's distinct from kind of using these kind of HTTP uh methods, uh. So graph is just a specification, um, sort of of what, um, of how you're supposed to implement it and then you'll find that there's actually a number of different reference implementations of it um so you know, for example, here you'll see that there's a graph QL, um, reference implementation, uh, for JavaScript and no JS and so, uh, you can use that, uh, for example, um. So graphQL, um, basically, instead of sort of making your requests look like, you know, HTTP, uh, requests, um. You know, you actually have some kind of typing and datas. I mean you you can see it kind of looks a bit like, like type script or something like that, right, um, and so you can define types. So like here we have character. This is a graphical object type so it has this object, the curly braces, and in it has two fields name and a appears in. Um, and for those they each have their own fields and they can be, um, you know, in this case this is like a string type which is, uh, just kind of a scalar type, you know, standard string, um, or it can be kind of made up of like other types. So in this case the Pearson is a an array of episode types where the episode type would probably be kind of, you know, defined somewhere else, um. And so you can have all kinds of different uh types, you know, defined in your API and you can also add, you know, beyond sort of just like strong typing you it has nice modern features like being able to, um, sort of define whether it's nullable or not, um, so the, the little exclamation mark here is saying that it's a string type. Uh, that is non-nullable, meaning you're not allowed to, to pass in a null for the for the name field, um, and then, um. They, uh. The query here, um, defines it's basically how you specify an end point. Um, So, um, and you're basically saying it's an endpoint for, uh, heroes that are character types. So how does this, uh. Sorry. So basically, the query here is. If if you instead of saying I want to like have some URL what where you define sort of an end point with a noun and it's like I wanna get that or something like that. What this is doing is it's actually giving the shape of the data that you're curious or want to have from the server. So it's basically saying I want an object. Of a um of a hero. And this hero being like just uh, you know, the hero for for a movie or something like that and that is gonna be a character type and it's that hero is gonna have a name and it's gonna appear in some episodes and and and so on. Um So Basically what you do is you define all the different types of objects and fields that can be queried by the client that are actually queryable by the client, so, uh, you kind of define kind of the entry point as sort of this is the kind of data shape that I provide, um, and. Uh, basically, um. You know you get you can the the the the client says I want to kind of you know have something look like this query and it sends it to the server and then the server is supposed to kind of match the data to fit what the query what the what the client wants um so what this means is that like. You know, you don't have a predefined endpoint of like a particular schema, but the client can say I want, you know, character and da da da da da and then the, the server says, oh well, based on my data I this is how I I'll I'll, I'll kind of put it into that shape and send it to you as like JSON that looks like that, um, so it becomes much more flexible like you you don't have to. You, you know, in the case I was talking about before where there's like user names for for users, but you have you in your in the rest API you would have all your properties and fields available. Instead you would just say I want just something that's just user names from users from the client and the server should just pull just the relevant information that it needs and and create the JSON to look like what you what you're looking for, um. So the whole idea is that it's what's meant to be flexible that the clients don't, you know, can kind of come up with their own way of kind of, you know, what the data should look like in that the server is responding with, um, so. That in contrast to rest like I've said where the end points are like very are set they're inflexible, um, and you have all these predefined, um, end points where you have predefined inputs, predefined data structures and, and so on and so forth, and everything is set until you just come up with a new version of the API, um. So, uh, Every, every graphQL query, I mean, it all operates over HTTP just like, like, um, a ReT API will operate over HTTP normally. You know, so you are, you know, you've got your web application client and makes a request to a server and of course it has to make an HTTP, uh, request, but all, all of the requests from a graphQL server should always just return 200 status codes. So the status code. Has no doesn't match at all to the actual response. The data response from from the server that's purely, you know, so it kind of decouples the HTTP from the rest of it. So like in RES, the response codes actually indicate a success or an error like in your, in your example, but if you're using a graphQL server, everything should always give a 200 response code even if it's there's an error message, um, you know, so if you made a badly formed query or it doesn't match some schema or something or other, um. And so then you can just create user defined error fields, uh, in your response. You can still get kind of network errors like if the graphic coil server is down. You know that might be like a 500 level error of some sort, um, but you know, basically when you make your request you you'll get a 200 response code and then it will look like something like this where you maybe have a data field and in the data you're getting the the information that you've requested, the integer and the string and then. Any errors will just go in some other data structure that is completely user defined for however you wanna do it so there's no there's no kind of standard way to do this um in this case, you know, it has an array of objects and those objects are I guess error objects and they have a message, uh, field and it has the actual uh. Um, thing, so here you can see it's returning some data, but it's also sending an error message, but it would all get returned as a 200 response code. Um, So So Graphel kind of has you thinking in a little bit of a different way, um, so in. In uh in a rest type of API you're kind of naturally kind of thinking in sort of a tree structure because all of the end points follow that kind of path down a URL right like so it'll go down some route in a URL and that gets to the end point, um, but you don't really have to think that way you think more about it in sort of GSO like data structures as for your query, um. Important point is that you know this so the so the graph 12, you know, server sits there and it can take these requests, um, but you're you're not kind of, you're not querying the, the database directly right? so you have to have, you know, whatever, say you have your OJS server that's sitting there that takes that query, it has to figure out how to get the relevant information out of the query that you've made. And from whatever schema you have in your database and they don't necessarily have to map together in fact you could even um kind of compose the query out of you know different pieces of information from the database to create your your response, um. It does, I mean, it's not like totally flexible in the sense that you still have to have some kind of predefined data types that your server accepts, um, as well as some of the, you know, some queries, uh, that it allows for, um, but. You can um sort of on the client side you can make those queries and you can do things like ignore certain fields or say I don't I don't need these kind of fields in there um so. You know, it basically defines sort of the, the different types of objects and fields and different kinds of queries that are allowed, but you could kind of think of them as being much more kind of like atomic. They're like little they're like the little pieces building blocks that then some client can choose to kind of compose together into a larger query uh as needed, um. So, for example, um, this kind of shows you side by side how that might, might look. So here we have an example of a client and a server. So, uh, the rest, uh, client is searching on some, uh, database or, or doing some endpoint on like music albums. Um, and, uh, you know, maybe it's, um, so you do a get request on some album ID. And ask for that for that album's assets, um, and then subsequently it does a second request on the asset and asks for the comments. So essentially you can imagine this is like you got albums and then you maybe have some comments on some e-commerce site or something like that, right? Um, and so in a, in a rest client, um, you know, you would pull, make the first get request and it would return the data, uh, and it might have ID fields and the URL is the, is the asset, I guess, for the album, um, right, and then, um. Uh, then it does for each of the assets, um, it's gonna take probably the ID and it's gonna, um, ask for the comments and for that sends back a second request with the author ID, and then it might have the text of the comment and so on and so forth, right? So the way you would do this in a, in a graph QL type of context is that. You might have your, you know, you your data types for things like comments that have text in them you would have, um, assets, uh, that have an ID, a URL, um, a, you know, a comments field in it, and so on, um, and so what you do is you just make a single request but. It basically, you know, because you've defined what comments the comments type is which you could make a request for on its own, but you can kind of just plug it into the structure of your what you're looking for and you're saying I'm looking for data that is an object consisting of assets uh by album ID um and uh that you know. Will be, you know, for that I, I want for each one of those, the ID, the URL, uh, the comments, and so what it does is it kind of pulls all of this and it kind of constructs it into one big data structure so it takes each of these idea fields, the URL, um, the comments and the text so it sort of like takes some of the information from here and, and kind of combines it all into one data structure. Uh, because it's able to match it to sort of the shape of the data that that you want, um. So You can see that I mean the the great benefit of this is that you, if you properly defined all your atomic pieces of what it is that your service provides then you can just the client can just come in and sort of say what kind of data they want, what kind of shape they want it to be and make one request to the server and get one response and they get the data in it already in the format they want. In the restaurant one you have to make two requests. You have to probably take these data field collections. You have to combine them together on the client side, uh, to get you into this format. So that was sort of the main, main goal with graphQL is the realization that. Like the mapping between the server and the client, um, is, is not always so clear and so if you can kind of allow people to kind of compose, uh, queries up from these basic pieces then you get, you get something that's a whole lot more flexible, um. So GraphQL uh does use get and post requests, um. Uh, so like, um, but, you know, uh, usually the, I mean, the way it works is that. Um, you know, you would have your API and you make your graph QL access your graphQL, uh, service, and then the actual query instead of being part of the, the URL like we have it in our, um, in our example for the assignment like instead of that you'd have like a query, uh, and then you would actually define I mean the shape of the query would be like some structure like you know this um. And you would just be in a string, uh, in the, in the, uh, in the query parameter, um, and then like posting like putting data in, uh, it's similar, uh, but you would put the query in the HTTP body. So, um, you know, in your request you just use some JSON and in there, uh, you might define, you know, what your what your post query is, um. If you're, if you're curious to like try this out, um, I have like a. An extra lab you can do. It's not required for the, obviously for the assignments or anything, but if you want to see like operationally how it works, it's pretty straightforward once you get, I mean, just like we use Express and with no JS and we set up a, a simple route handler for, you know, for making your HTTP requests for the in the assignment, there's also like a nice graphQL, uh, library implementation, uh, that maps right into Express. So there's nothing that says you can't combine graphQL with rest or any of these other, uh, you know, different things. So for example you might have in behind the scenes one or more rest, uh, servers uh running REST APIs and then you might have in front of that some kind of graphQL server that maps onto those, um. It's totally possible to kind of mix and match these technologies, uh, if you want, where the client is just making request the graphQL server but then you have other things here, um. There's uh a lot of um uh resources if you if you wanna uh look into it um but you know the key thing is um if you wanna um learn about. Graphic. I mean this is about the specification, uh, this, this is the main main link but if to see how it works with, uh, express, which is what we've already used in MP with it, you know, with the MPM package for what we're doing in the assignment, um, then you can, uh, take a look at at this this package here, uh, as well, um, there's also a nice article here that describes sort of like more in depth around. The relationship between rest and graphQL and how it, you know, how you go from one to the other. Um, So Uh, so yeah, I mean, basically, I mean, I just want the takeaway from this is that you realize that I mean although we're focusing largely on rest, um, in the course on the terms of the assignments just being aware. That you know graphQL as a newer technology that is it has by no means has it replaced or supplanted um uh rest I mean that's still like hugely like kind of uh popular and widely used but just so you're aware of it um and to see like the difference in terms of the way it works in particular how it, you know, when you. When you're making the request, it's no longer kind of built on top of that, um, those HTTP, uh, requests and status codes. I mean, it doesn't have any kind of mapping between things like, you know, the 200 code and the 400 code all of that is that's rest, but then you move to graphQL and they basically, uh, did away with that and then you just do like custom error messages and and all of that sort of thing. So, so any questions about, about this, uh. Um, about like kind of the why you might want to use, uh, graphQL instead of rest or or anything else that covered. OK, um. So, um, I'll send a, a message out on learn also about the, the lab. I'm assuming most people won't want to look at that while they're still working on their assignment, but you know, maybe if you have some time over the break and you wanna see. How, how you actually, uh, uh, can use it, uh, then it'll be there. Um, so the next topic that I have in the, in the slides, I'm actually gonna just kind of, um, I'm gonna cut out because it's not as important, um, I mean you've already done some done some things on testing. Already, um, with the Bruno tests that that you've written, um, but the key thing in this in this um subject about automated API testing is I, I wanted to also highlight that there's there are other libraries you can use where you can kind of um sort of programmatically. Write tests, um, and they're they're very um useful in some cases for like kind of continuous integration and development uh situations. So for example you might write a bunch of tests and you wanna kind of programmatically, you know, kind of interact with your API not by making direct kind of um. HTTP requests, but directly like accessing, you know, like calling the the functions and testing the, the return values so like using some kind of like you know building like unit tests and that sort of thing, um. I'm, I'm less, you know, I, I don't really wanna spend the time kind of going into too much detail about this, but there is one thing I wanna just highlight because I think this is relevant for testing more broadly, um, regardless of the testing framework, uh, that you're using, um, and so, uh, I'm just gonna skip over these things real quickly, but, um. What I wanted to highlight was that when you test. Uh, I mean this is true actually about all kinds of testing, you know, not just web programming, of course, but that the whole thing about when you write a test is that you don't just want to be looking at the, um, you know, that things happen as expected in kind of the in in in the sense of like a positive outcome, right? Like if, if we have if the app has an expected behavior with correct input. Then of course we expect it should have the correct output, right? But The thing is, is that we also need to know that the system rejects or fails in the way that we expect as well when things are not correct, um, and this is sometimes something that. We forget about um when building tests because you're kind of so focused on operating on like what you expect to what's the expected behavior of the service, uh, that you don't start to think about sort of how it should fail uh when things don't uh uh complete uh so. So we often test that uh to corroborate that something completes as we expected. So if you want to do a login that it's successful, like when the person tries to log in that they are indeed logged in, but we need to also test that the system rejects that doesn't complete as expected. So. If somebody wants to log in but they send the wrong password that they are not logged in, you know, so, so those actually cases can often be a much larger space of possible test cases than the correct behavior on on correct input if that makes sense or an unexpected, uh, behavior, um. So, so that's, uh, uh, just a key point you can ignore about this bit because that was more about the other stuff, but ultimately, um, just remembering kind of this this full kind of matrix, right? So If the intended behavior is success, right, you know, user tries to log in and they do and it we the intended behavior is that it's a successful log in, then the test should pass, right? If Um, If the test would fail, of course, if the actual behavior failed, so if they're expected to log in, but they, they, but then the system does not log them in, then that's obviously a clear failure, right? Um, but then you also have to look along this row that the intended behavior is a failure, then we also have tests that need to pass here that the actual behavior fails as well, um, and so. I mean we do this sort of, you know, if you look at the tests in the in the assignment obviously we have expected error codes of 400 or whatever under certain conditions, right? So, so we're doing that there but um it's something to be mindful of, uh, when, when writing your tests, uh, to do this, um, and of course this is not by no means is this kind of limited to uh to web programming in in any way, but, um. You know, I think in in in the space of web. Uh, program and we'll, we'll talk more about testing on the client side later on, but it's actually. I mean there's so many ways that people can behave with your system in unintended ways, right? You know, like there's so many ways that that that that you know things can um. Uh, where, where they may be acting in some way that's kind of interacting with their system where it should fail, um, but oftentimes it's hard to almost kind of, uh, you know, imagine what all of those are so one of the challenges with testing and web, uh, programming in particular is that is keeping on top of that. And, and it gets even more complicated because of course when we get to the client side we have no control over the environment either because people are running in all kinds of different browsers and different other you know in all different kinds of environments that we have no control over so if you want to really comprehensively test then you need to do it, run all of your tests, but also under all of these different kinds of conditions that you maybe can't, um. Uh, you know, can, will require, you know, almost like a whole battery of computers to, to test against, um. So we'll come back around to testing later on. It gets even more complex on the on the on the client side, but I just wanted to highlight this as a as a takeaway, um, when, when writing your test is a focus on, focus on it is behaving like we expect but also that it doesn't that it fails when we expect it to fail and this is, I guess the important thing is this is probably the one that's least kind of tested that is that. Um, Or, or these kind of things, this is the gap I guess is that if we think the behavior should cause a failure and actual behavior succeeds, uh, that's a problem, right? You know, so, so that like for example if somebody tries to log in but then they forget, you know, some, you know. Uh I don't know, well, password's an obvious case, but there could be other kinds of examples where like, you know, maybe they're missing a field or something like that that they need. Um, and it, and, and it still passes, you know, you, you still allow them to, to do the, do the action regardless. Um, that's, that's a problem. Um, OK. Hopefully that any questions about that before I move on to the next stuff? OK. So So I just need to pull my slides. So now we're switching over to week 6 slides. Right. So So so far almost everything that we've covered apart from a little bit in JavaScript I guess um has pretty much been about the client side I mean sorry the server side of the equation and that and that reference implementation or the model that I, I, I showed you um and so now we're switching over right um and. To begin with, I, I do wanna just briefly hit on security, some important security issues, um, but then we're gonna just basically move over to the client side, uh, entirely, um, when it comes to security, so, so this is this course, you know, uh, if you, if you're doing web programming, I mean. Understanding like web security is of course critical to like building any kind of production uh web application. I mean it's it is really you cannot there's no way around it um you have to take that into account um but to properly and comprehensively cover web security it is it's like itself kind of like an entire course of material right? Um, and we're also not really focusing on the sys admin side of running a web server and, and all, all these sorts of things either, um, so what I wanna do here, uh, before I go into the client side is I just wanna kind of give you sort of a, uh, a an overview of where what the resources are for starting to like look at some of the major problems around web security and if you're interested in these then. You go on and if you're doing 4th year, take software security course that actually will go into in depth detail on these, um. So Um, So right, so this is just a brief primer on some security issues and some of the top big ones to keep in mind. And then like I said, if you, if you're interested it's sort of a primer, go on and take a 4th year course on software security where you get to actually. Go full on, do security testing, trying to, trying to, to break applications and so on and so forth. Uh, so what I wanna, what I wanna highlight for you, um, is this project called, um, OASP, so. The landscape of kind of web security is kind of ever changing so if like you were asking me 10 years ago what the big challenges are around web security and uh with respect to web applications, you know, maybe the top 5 topics um. You know, might be one thing and then if you ask me, you know, now it will have kind of shifted in some in some case and so given this kind of dynamic nature around sort of what that's happening in the space, um, this, uh, project, the open web application security project called OAS was, uh, created and so I'll just click on the link here. Um, So this is uh a great kind of uh resource. There's huge amounts of like, you know, training materials and so on, but this is they basically have, um. Uh, different kinds of, of projects, um, and they have chapters around the world. There is a Christchurch group here like if you're interested in web security and you just wanna get like hands on what, what you know, companies working in this space are dealing with around security, you can actually go to their meetups, um, here in Christchurch, um, but the important thing is that they have this thing called the OAS top 10. Which is kind of annually kind of, uh, updated and it's like the top 10 web application kind of security risks, um. Uh, and so, I believe I have it in a slide here so I can just. Back. Yeah, so this is a few years ago and I mean we could check and see how much of these has changed, but you can see that they kind of just rank these are the ones that you, if you're building a web application, you need to be really mindful of, of all of these things and injection is number one, I'll briefly cover what that means in a moment, um. But you can see, uh, broken authentication is #2 sensitive data exposure is um a huge thing, right? I mean, I, I can you can imagine like, well I'm sure you've all heard about kind of the privacy leaks and so on and web applications. Well this is a huge, huge concern, um, building any kind of uh web application now and then you can see it kind of goes into some other kinds of of issues down here and and so on and so forth. Um, we could actually take a look at, let me just see if, uh. Um, Yeah, so they kind of go through sort of how they've changed over time, so I think I guess maybe um. 2021 here. Uh, you know, some of them became went up, some went down. So for example, injection has gone down a bit, probably the reason for that is because the kind of the, the, the kinds of libraries that we use, for example, our database, um, code that we use for our accessing MySQL inside of No GS it's probably mature enough that people, um, you know, people use those tools in the in the correct way and it. So that you can't get kind of injection attacks happening uh but other things you know are becoming. Uh, more things they do this sort of on a state of, you know, the state of the nation or world or whatever with, um, in terms of, of security, uh, issues, um. So injection though is like a one that's like a classic problem, um, and so this is and, and so much so that there's even like an obligatory XKCD cartoon, um, so any, any topic that's worth anything has its own XKCD cartoon and in this one, I mean injection plus is essentially the idea, the idea that you can through some kind of connection from one system to the other, so any web application would be a classic example there's a client, you know, connecting to the server. It's so there's like an opening that allows the attackers to kind of run some kind of malicious code on on the server side um and so this is an example of uh SQL injection so uh somebody like it's like a mom calling uh. The school is calling the mom and saying that um the the student's name which uh looks like this here uh. They, they basically took a plain text, uh, version of it and, and inserted it into an SQL query which caused them to drop all the tables in their database, um, and so injection, so, so SQL, this is SQL injection where like you, you just take a raw string and you just push it like you if you did some kind of string concatenation, you know, all of a sudden you know it destroys the the database um. So, so SQL injection is is one of the more kind of prevalent versions of injection that are out there, but if for example when you're using the, the library to make your MySQL requests when you do that kind of, uh, templating system where you put a question mark or whatever for the for the location. of the field and then you pass in the fields that library already sanitizes everything so basically removes all kinds of characters from strings that can cause it to read as an end line and and turn into a new new command or or anything like that um. So, basically, injection is possible anytime you have an interpreter of any type. So it doesn't have to be SQL. Anytime there's any kind of interpreter that's gonna execute some code, then there's a vulnerability. So if you pass information through an HTTP request, if it's, it has to be really scrubbed and correctly formatted before it happens, so like that's why SQL injections are particularly bad because people would just take these plain text field like a form field on a web page. Some would enter something and it would just they just directly turn that into an SQL query, um. Alright, so we're running, uh, out of time, but I just give this last little example so that shows it doesn't have to be like injection is not a problem that's that's purely about SQL, um, you know, in this case, uh, imagine you have a Java class that sits on the server. Uh, and that gets an input from the user makes the HTTP request, and then that class is going to use the Java runtime to make some on this DOS call and you know, some kind of call to like the operating system, right? so. If you did something like this. In Java you'd create a runtime object. um, this allows you to run kind of executable and in here you just kind of, uh, say I'm gonna execute this command dot stuff.Xe and I'm gonna pass in my user ID. Well this right here, adding in my user ID is an injection flaw, um, because, uh, you could add in something like I'm gonna pass in a some parameter in here, uh, and then like. Because you can put any string, if you put some other command in there, you could actually like do stuff like read off what's the, you know, what's going on inside of the, the server, you know, state or something like that, um, because you basically add this ampers sand in here as a command. Um, appender, uh, and then you can do that. So this is that air that, so, so basically whenever you're put in a web application you have to always think, are people like put, are you ever taking data from the user and directly running some kind of interpretation over execution of code? If so, there's like a potential for like an injection attack. All right, so I'm out of time, but um. I'll talk about a little bit more on this, um, but then really we'll just dive right into the client site stuff starting from tomorrow. Thanks everybody.

SPEAKER 0
they are. We Well Uh, just make sure that they're done. Um, so that when you run an MPML star if you push the node, it's gonna be. you talked about adding the actual. The actual install. Yeah I think, well, I guess I I. Good. Yeah. Yeah.


SPEAKER 0
And All right, uh, let's go ahead and start. Uh, thanks for coming. This is historically the least attended lecture of the semester because everybody's furiously trying to finish up their API and so they're usually in the labs or something like that instead of coming to lecture but so thank you for coming. Um, any questions about the assignment before I, uh, go into the rest of regular material? OK, cool. So, um, When we left off, um, I was just doing a real whirlwind short tour of like web security, um, really just wanted to highlight a couple of key things that anybody who's doing, you know, web programming should be aware of, um, so you wanna look at and ideally learn about those all those different kinds of vulnerabilities and those OAS tutorials, uh, that I mentioned, uh, and then when I was ending I was talking about injection as one of the um. Most, uh, common kinds of, of flaws, security flaws that you can have and so. Just as a refresher it was it's basically any time you interpret like any kind of information that's directly coming from the client into the server and so um you know the whenever the the web application uh passes some information through you have to make sure it's scrubbed in such a way that it's not going to. You know, basically allow the attacker to execute some kind of code on the, on the server side. So SQL injection is probably the most famous, uh, version of this because it's where where people take essentially some kind of text string as their input and they inject that into sort of an SQL query, um, which allows them to manipulate the database and the reason why this works is because clearly. You know your back end service is is making authenticated um queries against the database right? so you know for example you're making insert statements or you know statements of some sort like that um. To a database table and you're able to do that because the service knows your database username and password right? so the service is basically using as proxy it it's letting letting some you know uh attacker basically get in and and and inject uh something directly into the into the back end. Uh, and like I showed, it isn't just about SQL, so there's such things like you do command injection where if you actually execute some code, uh, based on the input, uh, you can do things, so I give this example. So All injection, um, kind of flaws are essentially input validation errors so it's basically that you are not checking the input and validating uh that it is correct, but when we talk about input, um, obviously the first thing you might think about is any kind of text field any form where you're entering information. But it's really any kind of external input. It doesn't have to be, you know, just things that users are entering in as text fields, uh, that are doing this. So, um, you know, potential avenues, uh, are, you know, anything that contains some data, um, that's input, so it could be text fields, it could be list boxes, radio buttons, check boxes, the cookies themselves, the HTTP header data, the post data. Hidden fields, um, parameter names, parameter values, you know, depending on how you write your server, if any of those forms of input allow you to, uh, like get directly passed through without some kind of, um, validation, uh, then you are effectively opening yourself up for for potential uh injection attacks um so it's really important to do this, um. You know, and you know, like I said with yesterday with SQL if you use kind of a well vetted library, so like if you're using no JS, there will be no JS SQL libraries for the whatever um whatever database server you're using, whether it's MySQL or Postgrass or whatever they'll have libraries that uh sort of do the sanitizing of the data input, uh, but it's clearly not just SQL any any other kind of um. Input data has the potential to do this, um, so you have to just be careful of all of these things. So how do you approach? Well, I mean you basically have to validate and then revalidate uh the data so. Usually, and we'll get to this when we build our front end, you're gonna do some kind of validation on the client side, right? So imagine you're entering in an email address into a field well maybe on the client side. You'll verify that it is a well formed email address. It has a little at symbol and it has like the domain, you know, like example.com or whatever, right? So. You know, you'll do some kind of validation on the client, um. And you know, or here's another example, maybe like ID number, you know, validate that it contains a number, um, rather than a number plus some malicious code that that could be executed. So what happens then is of course you send that from the client and at any point, you know, in the chain from uh between the client and the server there's potential of course that that data could be manipulated or changed in some ways that's harder to do if you're using um secure socket layers which is sort of the um the encrypt if you're encrypting the connection you know between the client and the server. Um, but, uh, you know, it at some point, you know, if you're not actually encrypting data, people could actually, you know, change data around even as a maybe it's not the client but some attacker in the in the middle kind of comes in, um. And then eventually it gets to the server and then the server has something to do that so when you're trying to validate and revalidate, I mean it's not always, you know, uh, for sure, um, you know it's sometimes it's very hard to to validate your data I mean even with the example of the assignment, I mean I've gotten several emails about things that aren't really specified, um, you know, in the specification. Um, and you know it's really great because people are thinking about all these edge cases, right, which we didn't even really, uh, consider, um, you know, so for example had a question about the ID value, um, of the user, right? It just says it's an integer. Well, integers can be negative numbers. I mean, strictly speaking, you know, we don't have any test on that, um, but you know you could, uh. You know there's there's all kinds of edge cases that you might not really think about so it can be hard to validate and you really have to be kind of comprehensive, um. Uh, and also like on the client side, I mean, so the client can do some validation. Which is great, but. You know, of course you know if you've got a public service that you're providing to clients, well you don't really control the clients themselves like you know you might just have an API. Uh, and that API is then built into all kinds of different applications, so you basically have no control on the server side at all over what how the how the client does validation or if it does validation at all so you can't assume that any kind of input data has been previously validated even though it's best practice, you know, largely for like user, uh, experience reasons to make sure you have proper validation on the client side because you don't want to make. Bad requests um to the server if you can help it if you can short circuit that right right on the client and that's much better but you on the server you can't you there's no way to know whether or not the client has done the proper validation so. Whether or not you know I mean it's good practice to validate on the client site, but then you should revalidate on on the server. Um, so, So validation is the kind of the key to injection. Um, there's, you know, if you want to learn more about this, you know, and you're on the 4th year you can take some security courses, uh, and learn more about, you know, how to, how injection attacks can happen, um, and also how to mitigate them as well as other things, so. There in that was, uh, list there's all kinds of different topics and I'm not gonna go through all of them obviously, but another big one that I wanna cover briefly is around authentication because I think one of the top ones was about, you know, problems with authentication or faulty, uh, authentication authorization, um, and so this is. Something that we've touched on already in the assignment you've done like logging into your um with as your user and there's certain types of actions uh that you can do, you know, based on whether you're logged in uh versus if you're not um and so uh I just wanna kind of go over that as well because this is something that's gonna show up on basically any. Any um kind of web service that you're you're developing is almost always you're going to have some notion of author authorized actions um and you need some mechanism to authenticate that people are who they claim to be. So authentication and authorization are two different things, right? So authentication is to establish that some claimed identity. So I, in other words, like I am this user because I have this secret information, um, like a password, right? Authorization is the. Sort of the permission to take actions so you can have different types of users who are all authenticated but they might have different roles in the application um and based on those roles they might have different sorts of actions that are able to perform so authentication always precedes authorization you can't authorize people until you've authenticated people. Um, so why do we authenticate? Well, I mean, it's, uh, the, I mean it kind of makes sense, right? I mean, we, we know all the cases of just where we want to like give access to resources, right? I mean you log into your email to give you the access to your email. Uh, but there's also two other reasons why it's really important to authenticate apart from kind of controlling access, and that is one is to log user activity. I mean you, you don't, you could log user activity based on, uh, stuff like cooking information like maybe um. You know the IP address that's connecting and so on and so forth but if you want to be able to capture, uh, any kind of activity at the kind of user level, then you need to have them first proceed with doing some kind of authentication in your system so that when they're taking those actions you know that it is that that user is taking the actions versus some other user so logging user activity is really important, but there's also this idea of non uh repudiation. So non repudiation is essentially this to say I can't claim to not have taken an action. So but this it's, it's like if uh you know say some action occurs, um, if it's authenticated then you have a record of that that person is the one who who took the action so they cannot claim that they didn't take the action. Um, so this is something you might not, uh, think about as, as, but this is another good reason to have authentication because if you want to say you have kind of, um, secure kind of features in your application and you want to understand, you know, basically be able to audit who's taking certain actions and so on and so forth, then you need to have that kind of authentication mechanism, um, so. So that's why we authenticate, um, and you can authenticate in different ways. I mean, and generally speaking there's 3 factors. I mean we've we've all heard the term 2 factor authentication by now um and that it kind of relates to that. I mean the 3 factors are something you know, something you have, and something you are, and I guess that it's a little bit of a blurry line between have and are I suppose but. Something you know would be like a password, you know, or some secret information that you have, right? Um, something you have might be like a token, uh, or something, you know, like, um, the two-factor authentication. And then something you are has is something that like uniquely identifies you like personally so that'd be like a biometric or something like that right like I scan fingerprints, something like that, right, um, so there's kind of three factors and they kind of usually they're used together, you know, um, nowadays I mean we it always used to be just something you know but then people figured out that wasn't really working very well so now everybody has to, you know. Sign in with their little codes and all this sort of stuff, um, nowadays. So when it comes to securing passwords, I mean we have already talked about this um but for the assignment, um, but you know I just wanna kinda, uh, kind of talk it through a little bit, um, so when you secure a password, um, you know, best practice is that you will both hash the username and the password hashing is just, um, you know, the process of essentially um. You know, a hash function takes some string or some data actually it doesn't have to be a string any kind of data, right, and it will passes it through a uh a function uh that essentially um gives every different kind of input data a more or less unique outcome so the idea is that the hash is some essentially a giant number right? But that, um, number is so large, the space of hashes that you can do is so large and they'd have a small numbers of collisions that you would use some kind of hash function that would basically give every unique. Uh, user name and password are kind of a unique cache. It's not really unique of course, but it's, it's, it's, it's very, very unlikely that you're gonna have collisions, uh, so you would, you would hash both the username and the password, um, in best practice like if you're gonna store these things, um. You would, uh, Uh, require users to change passwords. Regularly, although I've, I don't know, I mean this is uh this is always open up for debate because if you ask too frequently, um, I mean there's some like social engineering issues around this if you ask too frequently then people stop kind of um. Stop they they basically stop, you know, they get annoyed by it so they'll use some way that is maybe less secure to manage their their passwords, but, um, using multi-factor authentication of course username and password plus the code by this phone is is is also good um and then also um. When you store them is this thing called salting you salt the username and password so you basically add all the kinds of additional elements into the ID information, uh, that help to kind of um. Essentially it makes it harder to to um. Uh, I mean, to, to mathematically reverse engineering makes it much harder, but the point is, is that you could basically use libraries for these, these things, um, nowadays, which is, which is great. So all of this stuff is good practice with, uh, with passwords, um, but then of course also any kind of connection that you make when you're doing some kind of log in action. You would use HTTPS rather than HTTP. We don't do that, which kind of defeats the whole purpose, right? We're sending like in the in the assignment we we log in but everything's on HTTP. That's mostly just for simplicity's sake for for building our application. I mean normally. When you the way you'd handle HTTPS is that you would just have some kind of proxy server sitting there that would take the that it would establish the secure connection between the client and server and then your no JS server would just be living on the server and that proxy server that takes in the encrypted connection then we'll just kind of pass it through locally in the server to whatever port number you're running your your service on. Um, we don't really cover that, but I mean it's, it is something that like any modern web application would of course would be run under over HTTPS. In fact, I think you know, search engines like Google will actually downgrade, uh, search results for sites that are not offered over HTTPS now, um. So it's all, I mean, you would absolutely need to do that, um, because essentially otherwise anything, any data you're sending over the network is in plain text, um. So what that is, I mean, so essentially there's a layer it's called secure sockets layer it's just a standard for encrypting the internet traffic, um. Uh, it's there's sort of different versions of this like the encryption mechanism, I mean the, the one that is, um. Uh, you know, sort of used nowadays, uh, mostly it's the transport, uh, layer of security, um, so this kind of sits here and you just think of it as like a layer sitting on top of the, the HTTP, um. It can it also um authenticates the identity of a website, um, so there's a cer er like a you you basically get it certified like a domain name so that if you have your, um, you know, if someone's connecting to it, it validates that the, the website is going to the correct your, uh, IP address, right, um. There's, it used to be rather difficult to set this up, but now there's some really nice, uh, services that do this sort of very easily for you like Certbot, you can, you can just, uh. Um, go and, you know, submit your domain name if you have your if you have a domain name sort of with a domain name service or, you know, internet provider, uh, you then, uh, can essentially, um, you know, create a certificate for your, for your website and then you do some site of like Apache or Nixx or one of these tools that it creates a like a nice little proxy, um, to, uh, you know, it would, it will just. Basically manage all of the, the certificate, um, information so that when you go, because you might have noticed like sometimes you go to an HTTPS. Website and they'll get a warning from the browser saying that the certificate is expired or something so you basically don't want that you want the browser to say oh yes the IP address that I'm going to matches the certificate and it's valid and so on and so forth and so there's nice services that do do that for you um. But like I said, it's out of the uh out of scope to kind of go into the details of how to set that up, um, but. Essentially whenever you go to an HTTPS site you're it's doing HTTP it's doing that protocol of, you know, request response but it has that that secure sockets layer sitting on top so it, it just, uh, it encrypts I mean there there's, uh, there's a, um, an extra encryption layer, uh, that sits there so all the communication that happens between the client and the server is, is, uh, hopefully cannot be peeked at from people. Um, and, uh, HTTPS, um, uses port 443 instead of port 80 by default, um, on, uh, you know, most servers, uh, so, um. You don't actually see that when you type in your URL, but if you do HTTP colon slash slash da da da da da, uh, if you, if you don't put the colon, you know, port number, um, by default it's 80 for HTTP and it's 4.3 for HTTPS. There's more detail on all of these sorts of things and some other courses. So, um, if you're wanting to get into the underlying like mechanism of, of how it works, um. So, sort of to wrap up around, I just wanna, these are some these are some. Bits of information from the OAS, uh, group about like sort of things, ways to approach authentication and and how to um how to handle it, um, and all the different kinds of things that you need to kind of keep in mind, uh, to really build a secure website and it really is kind of like, you know, once you create a public website and you have driving users towards it I mean you are. Essentially out in the wild west, right, and people are going to be are absolutely going to be trying to hack into your site and all kinds of things, um, so. Uh, I'll just go through these different bits, uh, uh, you know, just to highlight them. So we, we talk about HTTP is stateless, so that means that like we've said. Uh, if you want to authenticate, uh, um, uh. Into like, you know, a service, um, then, uh, you need to have some way to send the credentials with every request because HTP doesn't maintain that doesn't maintain that the set the next request has come from the same source as the last one, so. Uh, basically you have to do that. So in our case we use an authorization token right to send that across, um, but you should always also use SSL or HTTPS for, you know, everything ever that requires any kind of authentication. Uh, the moment you don't, you're sending plain text information and it's, it opens things up. That you have to be aware around session management so we talked about a session, uh, earlier, uh, and how it is that you know people might be able to exploit that, um, so. If you use like a session ID. To track the state, so you're sending some session ID maybe it's in some kind of uh it's, you know, in a header or maybe it's in, you know. The query parameters or whatever then for from an attacker's perspective that allows you to act like that that user so you have to be careful about that session ID then getting kind of sprinkled out throughout right your system right because. Uh, session ideas can be exposed in the network. It can be in the browser like, I mean, for, for example, you know, the history. I mean if, if you had if you had a session ID inside of your, um, query parameters, then that session ID then becomes part of the history of your page, um, so another person could go onto your web and and look at what that was and grab that information and then move over to another computer, um. It's often like if it's if it's in a URL it might get caught caught up in the logs, uh, you know, so maybe you think things are, are great because you've used HTTPS, but then you store some logs about the requests, you know, you're just, I don't know, the URLs or whatever, but you store that on some server that's not as secure or has an exploit in it. And at that point the people can kind of look into the logs and grab the, you know, information and start acting with that that session idea and so so you have to keep an eye on session management. Um, When it comes to authentication side doors are a big deal so when our side doors, it's basically ways for uh attackers to exploit. Um, sort of other aspects of your system, uh, to sort of coax out information, um, you know, not by directly looking at the network traffic, but in terms of doing something like, like, um, causing your, your user to do something that, you know, takes an action to expose some information and so there's all side doors can kind of exist in all the spaces of your website. Where people are kind of entering in kind of private information, uh, so things like change your password pages, remember my password so you know those kinds of things like, you know, often times it'll be like, you know what's your name of your pet or whatever, you know, oftentimes these things become huge attack vectors because. You know, they, you know, maybe that the entropy of their password is really high, which means that the, you know, it's very there's like a lot of randomness to the generation of the password, but the questions themselves are high are easy to like identify, especially if you know something about the person, you know, then in that case those are often used as ways to kind of get the password without directly guessing the password or watching the. The network traffic itself, um, so all of these things, you know, like, you know, forgot my password, so on, so you enter your email address, all these things are, are all spaces that you have to be, uh, um. familiar with and so the typical impact of like not managing these things is that user accounts become compromised or the session itself gets hijacked in some way, right? Um, So, uh, some guidelines, so I mean, you know, there is this cheat sheet which is great to look at, um, but you know there are some, you know, general guidelines. Uh, it's best to deal with authentication as in as simple or as centralized way as possible and ideally using some kind of standardized methods, so, um. You know, we actually roll our own kind of, you know. Uh, authentication, you know, build it up, um, but you know, a lot of websites have basically outsourced that to. Uh, organizations that they figure just know how to to to do this better than they do so that's why you have things like, um, oftentimes you're logging in via your Gmail account or something like that. I mean that's often seen as safer because people figure well Google is this like massive, um, you know, multinational corporation with some of. Best security researchers in the world, so they're gonna develop a system that's way more robust than anything, you know, we can do. And so they what other websites will kind of use their uh kind of piggyback their authentication off of the services provided by those, um, but in general like simplicity is good because it just reduces the number of like side door attacks and and other sorts of things, um. So, uh, using a standard session ID, um, making sure you use SSL, uh, to, um, protect like not only the, the credentials but also the session ID so not only when you're logging in and out but any time session ID has anything to do, it must always should always be over HTTPS, uh. And I'm verifying, you know, the implementation, um, I don't, you know, I don't really wanna go into too much detail on these it's just more to be aware that it's that like going from building a test application for, you know, a class and you know going through some steps that's part of it but you know probably if you're building a professional. Web application with a large user base you're almost certainly gonna have somebody on your team that is like specifically focused on the security side of of the application um but yeah I mean just thoughts of different things like so for example this one is is one that like verifying that when you log off you fully kind of destroy all of the session information and and so on. And if it's like highly critical information like that you're really dealing with um you know you you can even go to the kind of the the lengths of like you know having to deal with the fact that for example JavaScript is a. Garbage collected um. Uh, language and so if you're writing your code in JavaScript, it will have um. You know, maybe it's memory doesn't get cleared because the garbage collector hasn't been run so if somebody got access to the internal memory of the machine, they might be able to pull information out like that. I mean that's kind of more on the extreme side if you're, if you're dealing with highly, you know, you know what things like where maybe some kind of like financial information that you're dealing with and you really wanna make sure people can't. Grab information and you maybe are working on public computers well that's that's like one side of it but you know I think for just your everyday website you're probably not thinking about it on that scale, um, but you know really sophisticated attacks are possible, you know, to try to pull all this information out. Um, I guess the one other thing is that I would mention is they have a tool, um, called Web scarab, uh, that you can use to help test your implementation, basically stress test the, the authentication of that, um. All right, so. Any questions about, about this, um, about like authentication, authorization in general, like some of the concepts around that. Nope. OK, cool. So that's, oh yeah, so there's these 2 tutorials or take 46, or actually we have now new cybersecurity courses, um, that some of them might be, uh, relevant, but you can learn about a lot more about that. Alright, so this, this topic, um, is kind of like, uh, wrapping up the server side of the course, um, you're still finishing up your assignment or hopefully you know you're getting finishing that and you know at the end of this week, you know, we're basically moving on to the the client side of the of things so just as a brief summary of what we've covered, um, we covered. Uh, early on we talked about HTTP requests and responses. Um, we also talk about rest, um, uh, later on in, in the context of like. Building APIs, so you know what is it to make a restful API? you know what are the end points what like what are end points of an API? How do you, you know, develop or design an API? We talked about topics around things like versioning, uh, and so on, um, and we talk talked a bit about like the server itself, like the server side of the of the the equation like. Uh, you know how we're using Node JS and express and no packages to sort of create the server application, uh, and that was also done largely through the, the labs as well, um, and then the other big topic that we covered, uh, was around, uh, data persistence, um. So there's my SQL, but we also talked about lots of other kinds of ways like the SQL databases, um, that are now used in web applications to kind of persist data, um, for the system. Um, that in the labs we covered JavaScript type script, uh, no JSN Express, um, talked about data persistence and that like the model code as well as like, you know, building an API and, and, and accessing it so. All of these topics are sort of the scope of like what we've talked about and you know like when we come around to the exam which we'll talk about, you know, when we get around to to week 12 uh but you know all of these topics are sort of, you know, part of what we could think of as covered in the in in the exam. Um, uh, where it's going to cover really material both from the lectures, uh, largely, but also anything that's kind of main concepts from the labs as well and so these, um. You know, The the purpose of the lectures was sort of to cover some more conceptual material that we maybe don't go into as much depth and detail and in the assignment um but to try to just fill in some other gaps so we might see questions about some of those other topics as basically as what was covered in in the lectures uh for that. Um, so that kind of wraps up server side and so I. Uh, want to now just start in on the introduction of the client side because basically the rest of the course is going to be all on the client side. So in other words, the browser's application that that's running, uh. And so for that, uh, we're gonna talk about a number of different topics um you know uh we'll spend a fair amount of time on JavaScript frameworks for building applications or interactive event driven applications uh on in within the browser, uh, but then we're gonna also talk about other kinds of browser technologies that we can use, um, to sort of enhance the applications that we built. Um, So, um, To Sort of start in on this whole, whole shift um I just wanna kind of pose. Like pose the situation that we have in the browser and what's actually going on. So, um, When you go and open a web page like the stuff page, right? You have a lot of contents just appear inside of the browser, right? You know, you've got like text and images, buttons, all kinds of stuff. Sometimes it's advertisements, all kinds of stuff. There's a, you know, title of the uh title bar. There's all kinds of things happen, right? So. All of this stuff is what you as the user see uh but then they're behind kind of you peel back, you know, from that there's the content like the actual source of the page itself that is used by the browser to do all of the rendering and compose the page um and so. The browser basically looks at all the source material uh and like has to first of all like compose it, you know, present the like you know what the content looks like and everything. But then it also needs to excuse me, respond to user events as they happen and perhaps dynamically redraw it or change the information in some way and and so on and so forth so the so the user has this kind of interface that they're working with but behind the scenes there's like you know a representation of of what's what's going on. Um, and also, The pieces that kind of go into what that representation is are actually you know even on a website like Stuff, so this is just like a media website um for that it's like essentially a um. You know it's drawing information like making multiple network requests pulling down all this information it's arriving asynchronously and the browser has to kind of build up kind of a view view of that um in real time uh so I just wanna show you actually um I opened up stuff. Uh, I'm just gonna reload it, but right here, so it's uh. Loading all this page and there's some ads coming up um and so on. So if you look over here on this side of the page, these are all different like network requests. So if you open up this is in Chrome, um, but other browsers set the similar sort of thing there's a a network a tab here and you could see. All of these every single thing listed here is a different web request that was occurred the moment we went to that uh URL um so the very first thing that happened. Uh, was, you know, it went to stuff uhco.nz, uh, and we got some kind of, uh, document, um, it gave a 304 status code which is kind of interesting, um, but then what happened is the HTML that was kind of pulled from there, uh, then got parsed by the browser and it then had it started to see that there was other stuff in in there so. If you go into the sources, you'll see there's um these sources. Let me just make this look bigger. Uh, there's a bunch of JavaScript code here. Some of it's more or less understandable, um. And so each one of these JavaScript, these are JavaScript files that were pulled off the server. Um, I mean some of this is injected from uh I have stuff up here um but uh you know a lot of this stuff is from from the from the stuff uh website, um, and it has a CSS file um with some fonts information and so on so you can see there's actually like a huge amount of requests that are happening, um, and it's pulling in stuff, you know, advertising, uh, so on and so forth. Um, so effectively, and here are some different, uh, web files, so these are type of image files. So What's happening is there's like a whole bunch of flurry of activity um in any kind of website like this where it makes a request pulls down usually like an HTML file it starts to parse that but within that HTML file it's gonna have all kinds of different scripts uh that it pulls in. It might have other resources like images, CSS files, and so on and so forth, um, and as it's taking that what it's doing is it's, it's generating a memory model. Uh, we call it a document object model, so it basically creates a, a model of what the web page contents are that's a uh an abstract representation of that. And that browser then. Engages with that like we read that document object model and we will actually render it and paint it into the into the interface so that whole thing is happening, you know, behind the scenes and it's, it's actually, um, quite a complicated set of of actions and all of this is, um, asynchronous so like every time it gets back a response it needs to then you know deal with it in in one way or another. So it's actually quite a complicated system that's happening and that's just the loading of the page. If I were to interact with the page then you might see more requests happening. So in a single page application as you start to kind of interact, you're you are, um. You know, continually modifying this document object model, sometimes you're making requests to the server, sometimes it's, um, you know, sometimes it could be different servers so you know they're not all the requests have to be from the same place and, and so on and so forth, um. So So a lot's going on behind the scenes of what the user sees, um, and that all sits, you know, that's in the the source of the of the page as well as, um, you know, other kinds of, of files that are loaded in. Um So yeah I mean this is effectively you know what the client side app has to do to assemble all the data from some end point in our case we're just going to a URL um initially uh is make a request over HTTP. Um, and then that will send back, um, some resource like the HTML inside of that HTML will be some CSS, some, some JavaScript. The JavaScript code, uh, gets executed. Uh, that execution, um, will potentially pull up, make another request for some data or something like that, um, and you know if it's interactive, then, um, you know, every time the user interacts with an element. Uh, it can potentially trigger some other JavaScript code that is gonna make another request, uh, maybe some other, some API endpoint, uh, and so on and so forth. So the client side application has to kind of assemble the data, um, that comes in into some kind of user interface, um. And that's sort of what you're building in your application is sort of how it handles the data, how does it render it, and how does it respond to the events that the user both both events that the user triggers via their interaction, but also events that might happen from another source like, you know, maybe you make a request for some data when the data comes in you then use that to change, you know, what's displayed on on the screen. Uh So to make all of this work, um, well we have some fundamental technologies um so uh you know in terms of the client site technologies, the main ones are HTML CSS and JavaScript, um, so there was a lab zero about looking at things like HTML and so on. I'm not my my plan is not to like kind of go in depth. You know it's a 3rd year computer science course so I figure um you that that part of it, uh, you can start to, you know, filling gaps around what HTML looks like and so on, um, but the key bit is that, you know, the HTML and the CSS uh sort of are sort of how it's displayed and then all but the JavaScript is the part that's all of the. All everything that is dynamic and interact that the where the user interacting it's gonna somehow manipulate um. Essentially manipulate the data model that sits behind these, these two, other, uh, formats, um. So JavaScript, um. Uh, is. Well, I mean, so first off, um. You know JavaScript is a little bit different than other languages, so we've already seen it in JS, um, that you, uh, write. I mean you write a program right and you you're doing things like uh like maybe you receive an image and you right to the file system right um and so there is kind of a notion of input output there in the no JS um. Kind of engine that that that the JavaScript is running in, but the language itself, the JavaScript language unlike many other languages, doesn't have a concept of input or output. So JavaScript is meant to always be run inside uh any kind of JavaScript code runs inside of an environment and that that's that environment that host environment is what provides all the mechanisms. To communicate with other things, so. The fact that you can write to the file system is in in JavaScript is because that's provided by the node JS engine that is running your JavaScript. It's not like a core element of the JavaScript language um, similarly in the browser right. It sits inside of a browser environment and that browser provides different kinds of ways to communicate with the outside world. You can the browser will not let the JavaScript code right to the file system because that would be a huge security flaw, right? Like you can't just have, uh, you know, people opening up web pages and writing arbitrarily to your file system. Um, so instead, you know, they provide APIs, uh, in that, in that broader browser environment that, that. Allow you to manipulate sort of what's being presented on the browser screen and to uh handle input from the user like a click event or things like that but all of that is really provided from that outer kind of um uh host environment so that host environment it gives you that uh and then the language itself uh doesn't inherently uh. Allow for that. It's unlike, you know, just like a print statement in in Python, right? It doesn't. Exist. There's lots and lots of um. To this, I, I, I don't wanna read this all, but I, I wanted to say that there's a lot more information about this on the Mozilla page. Uh, it's quite interesting it's because it's a little bit different than how we normally work with programming languages, but. The key thing is that the most common host environment for JavaScript is the browser, so that's what people think about of course no JS is also another environment and we, we kind of did it a little backwards we started with that, but you can actually have JavaScript be in lots of other domains as well. So for example, uh, inside of, uh, Adobe Photoshop, um, you could, there could be a JavaScript interpreter. Uh, SVG images themselves can have JavaScript can can execute JavaScript. So like if you open up an SVG viewer, it can execute the JavaScript if it has an engine, uh, to do that to manipulate. So SVG is support vector graphics, so this is just like a a. Type of vector web graphics, um, but you know even some new SQL databases and so on all have those as well. So, so the key thing to remember is that like JavaScript in one environment is not the same, doesn't have the same kind of capabilities as JavaScript in another environment because whatever input output features it has is provided purely by that that host environment. Um, So when you are in the browser you're dealing with the user um so input and output happens. The uh the elements that are defined in your HTML and your CSS um and uh so and behind the scenes we'll talk about document object model in a moment but there's a that kind of. Memory representation of what those files, uh, describe, um, so. So the JavaScript can inter basically manipulate those types of elements, right? Um, so for example like a paragraph tag on your HTML is JavaScript can manipulate the text inside of that tag, right? So that's a form of input, um, and uh or a form of output or an input being like it can take a button, click and respond to that. All right, um, let me just finish up the slide then we'll do it. So when you deploy your app. Uh, it's then because the browser is the environment, of course. You have to do your code, the JavaScript code you're running is running potentially in different environments that provide different functionality. So like what browser you're in and so on matters, um, the kinds of features that are enabled matter because, you know, like cookies, whatever, even things like the computing power, the host machine is gonna be totally dependent on the end user. So it's very different from our experience of like building the API because you, you can control the environment uh completely. They're completely different APIs in the browser. We'll talk about Ajax later, um. When you want to import new libraries, um, it can be done it's done in a different way sometimes instead of installing all the packages on the machine, it maybe we'll use what we call a content delivery network which will go into more detail on that, but that's where it pulls them from some other third party source that's that's a quick kind of easy close server that hosts it like a mirror. Um, no packages are not all available, um, in there. The structure is different when you build your structure of your application. You're not just gonna have your JavaScript code inside of a source directory, but you also have HTML. You also have CSS. You have other assets and all of that has to be kind of, so the, the, the way your code is gonna look is gonna be different. You're not gonna look, it's not gonna look like what you built with the API. Um, and then then sometimes when you're comparing them there are notions like routing for example which we'll go into more detail on and bottom line is that these, these ideas sort of play out differently in the two different codebases so. This is just to kind of prime you that when we start to develop, it's even though you've already done a lot with JavaScript and TypeScript as soon as you move into the browser, the whole project structure the kinds of libraries you use all of these sorts of things are changing even though it's the same language that you're using. All right, so I'll just stop there, um, and you know, starting next week we'll dive a lot more into the client side applications. Good luck with the, the assignment, um, due dates the end of the week, um, so yeah, just, uh, let us know if you have if you have questions about that.

SPEAKER 1
Oh yeah, you just That's the man on the mission. Well So I go to. Um, yeah, yeah, I'll, I'll, I'll have my review. Yeah, we should do it. With that I. Yes Yeah question. I would like actually figure out how. with Oh Man I Getting to. Just. It was a stupid one.

SPEAKER 2
Yeah, my friend said that question. He had the correct moment equation. The correct graph, like the graph how it goes like that, then it jumps and then it goes up to 0, he somehow could not figure out where the maximum was.

SPEAKER 1
To be fair, I spent a while looking at that like, it's a point of inflection. Like it is there and I'm just like, oh, it's in.

SPEAKER 2
like he's, I was just like so I know what you like and he seems to be the perfect spot and I'm like.

SPEAKER 1
Yeah.

SPEAKER 0
the Yeah.

SPEAKER 1
Like.

SPEAKER 0
Yeah. Um, so on it and I read that.

SPEAKER 1
And it's Oh, so I'm gonna have to go and

SPEAKER 0
recheck it and make sure that.

SPEAKER 2
I All right, uh But All right, uh, sorry about yesterday. I'm, I'm hoping I, I can't project too much because I'll just start coughing, but I've got the microphone, so. Hopefully that'll be all OK. So, Welcome to the last lecture of uh term one. So my plan is to just finish up what we're talking about last time, um, and get you kind of prepared to start on, uh, the, the front end, uh, side of, of the course assignments. So this weekend lab, um, we, well, we actually have 3 labs that are available now on on the learn page. So, uh, the first one is lab 3, and so that one is gonna be, um. Where you start to learn about um using JavaScript frameworks on the client side, um, and then it kind of builds from there um I'll have the assignment to specs all up, uh, in the next day or two. it should also, um, should not be too long until we get the marks available for assignment, uh, one, Once we have, uh, done that, um, we, uh, we also will release a reference implementation for assignment one for the code itself so you can use that to build off of for assignment two. Um, so you don't have to build off your assignment one, submission. All right, uh, any questions about that? OK So, um, on going back to the client side, uh, just last week I was talking about, um. JavaScript, uh, as sort of the language, um, that obviously is, it was originally the scripting language that lives, it, well, it, it lives inside of some environment, um, and in the case of the browser which was originally designed to work with, that's the browser environment, but obviously we've seen in OJS that you can also run it in a server environment now. So I wanna talk about a few of the other client site technologies just to give kind of a baseline of all the pieces that are coming together. Um, and then we'll move on into the, uh, more on the JavaScript frameworks, um, that we're gonna be using in the course as well as some JavaScript frameworks that we use in, you know, outside of, uh, that, that aren't like kind of covered in, in, in the assignments as well. So on the client side, we have JavaScript, but obviously we also have HTML. So HTML is hypertext, uh, markup language, um, so, uh, as this quote says, it's the most basic building block of the web. It describes and defines the content of a web page. Other technologies besides HTML are used to describe the appearance and functionality, so the CSS and. Is the appearance and presentation and, uh, functionality is JavaScript, but they're all tied together with HTML, which is the actual content of, of the web page. Um, so as we go forward, it's important to kind of just differentiate between the content and the data, um, so the content is sort of. What is in the HTML, uh, fields, um, and, uh, in the memory representation we'll, we'll talk about the document object model as well which is the memory representation of what is encoded in the HTML. So that's the, the content, but then the data, um, is, uh, the stuff that is oftentimes stored inside of a JavaScript, uh, you know, variables and that sort of thing, so. Also be careful when thinking about like what the concept of what a web page is. I mean what a web page is it kind of changed over time. Originally it was literally. I mean, you would go and request HTML and that was. You went to the path, actually the, the literal path on the file system and got the HTML, uh, for that and then that was your, your web page and then you would navigate to a new HTML page, um, but like, uh, web pages have become more dynamic now, um, and they are not always just the single, you know, HTML file, uh, by any means. There's lots of other. Other pieces that go into what what what we think of as a, a quote unquote web page. um, all right, so what is HTML actually so. It's a declarative language, um, declarative meaning you kind of describe, um, you kind of declare what it is you're looking for it's sort of like a pattern matching style language, uh, similar to SQL also is a declarative language, um, and so. Although it's not really I mean it's it's, it is kind of a language, uh, but it's not a programming language it's, it's more of a markup language um and so it's just a kind of a hierarchy of elements, um, and those elements are nested within each other so you have elements that are identified by some kind of tag like a P tag is for paragraphs and so on, um. Elements, um, typically contain some kind of content to display. um, so for example, you have a paragraph tag, you'll have the actual text of the paragraph, which would be the content that you would display inside of it. Uh, elements have attributes, um. And Uh, so, so the attributes are used as a way to characterize in some way, some, uh, characteristics of, of the elements themselves. So, uh, for example, um, you know, the. Paragraph might have um. Some kind of uh style attached to it or or it might have a, um, you know, an ID field or something like that. um, so oftentimes that attributes to our values it's they don't have to, but they, they often will and. The attributes are sort of the key thing that connects together um the elements to uh information that's in the CSS or in the JavaScript so like you know if usually you have some kind of ID field or some class field um attribute that goes into these elements and then that's how you sort of address into those elements um you can also custom define uh attributes, um. You know, make up your your own one and also HMLL has also had multiple versions over time. So, um, there were a smaller set of possible elements you could have and those elements, you know, that's been increased with HML 5, which expanded the language quite a bit. So example of an HTML page, um, it's essentially you have a document type declaration here it's saying it's this exclamation mark doc type HTML. And then you'll have uh elements that are organized into this hierarchy structure so it's a hierarchy so that means that the closing tags of a tag of of an element, uh, have to sort of you you can have the, uh, one tag open, um, and one element open and then have the closing tag outside of the containing tag. So for example here we've got HTML tag, head tag inside of that a title tag. So the closing tag is the one with the slash, and so the closing title tag has to be inside of this head tag cause so it's all nested in a hierarchy. Uh, an example of, uh, uh, attributes, um. You would here's the tag and then this is the attribute. So in this case the attribute is language or lang um and its value is uh the string E N right? um. OK, and then similarly here this one attribute is, uh, chart set and its value is ETF. So, yeah, so this, this kind of shows more explicitly, you know, that it's like it has an explicit tree structure. Um, and we'll come back around to this because the, the memory model, uh, for the document is itself also a tree, a tree data structure just like this, um. And that tree structure also has kind of a. I mean, you can kind of think of it having kind of a nesting structure in terms of the actual view of the page, although this is not strictly speaking, always the case, um, you know, sometimes you'll have elements that. Uh, you know, are out outside of their parent elements and and things like that, but, uh, generally speaking, when you think about the layout of your page, you can think about it as these different kinds of components, um, and it has this kind of, um, hierarchy, uh, in here. All right, um, so that's pretty straightforward. I think, um, you have a chance to play around a little bit with some HTML in the lab. Um, So, uh, you know, for an element, um, you know, you have this opening tag here and the closing tag, so the closing tag, like I said, has the slash in front of it and then so the element itself is what constitutes the entire thing all the way from the beginning of the opening tag to the closing tag and then everything inside of it is content. Um, so in the case of this paragraph tag it has. Just a string as the content, but it can also have other elements as content as well because it's nested. So this creates a paragraph that says JavaScript callbacks or turtles all the way down. Um, The attributes, they have a name and value. So here we're adding a class, uh, attribute. And so uh attributes go in, you know, there's a series of attributes you can have, uh, associated with a particular, uh, tag, and it's always with the opening tag, not the closing tag. So this is just saying this paragraph, uh, this is a paragraph element but it also is, uh, has the class, uh, common. Uh, why would you do that? Well, for example, you might want to style all paragraphs that are comments in a certain way, so you would reference this class comment in your in CSS, which is the, uh, style sheet to sort of style all all comment paragraphs in a particular way, for example. Um, And then, yes, so obviously you can have nested elements, so here. This is a paragraph, but in sight, we have, uh, a strong element, which is just a bold style. Um, All right, so that should be pretty. Uh, straightforward. So, JavaScript then is the way as a way to change the HTML content, um, so, uh, if for example you have a paragraph with ID equals and ID is the string 4 maybe in there it says Oro world inside the paragraph tag, then you have JavaScript, um. And you can do something like the following where you say you wanna get the document so document refers to sort of the the document object model of, you know, whatever is being represented in in the current page and then you call that you're gonna call um uh a function get element by ID on that um so this is provided by the document class. Um, and so you pass in, you know, what you're searching for, um, so it's trying to get it by ID4, so it's gonna look for an ID attribute, uh, that equals 4, and then we're setting the inner HTML of that the those elements, uh, to hello world. So if you were to execute this in some script tag, um, then. This is what your paragraph tag would now look like. It would look like a paragraph ID4, but it would have replaced the inner HTML to. Uh, hello world. So effectively JavaScript is our mechanism for manipulating, you know, what's going on inside of our inside the content inside of our HTML. Oh So get element by ID, um, there's like many methods that are kind of built in for this, and you can just write, uh, scripts that will directly, uh, change the content of your document that way. Um, So there's lots of custom attributes that you can do as well. So you can, you can obviously define your own attributes for elements of all you want, um, and use them however you want, um. HTML also offers something called data attribute, um. Uh, so, uh, so it has this thing where it's basically data and then start, whatever. It's just a, a string of characters, whatever your choice, um. And so, um, those. Um Those data attributes, um. Can be uh useful if you want to kind of. Associate some piece of data. Uh, to various elements, but, uh, the problem just to keep in mind is that, um, it all is kind of attributes all kind of live in a global name space inside of your, your HTML. So if you define something like a data student in one library and then you divide data student in another library, there's potential for those clashes, um, to happen. Um, we're trying to talk a lot about frameworks, um. And we're actually gonna be using React this one JavaScript framework, but there's other lots of other frameworks, and many of these frameworks will use custom defined attributes as part of their, um, binding magic which we'll I'll talk a lot more about, uh, shortly, uh, but essentially it like will put in specific, um. It has different kind of custom attributes and that's the way it identifies which elements to kind of automatically update when some data field changes or something like that. Um, so angular and view are just two examples of popular frameworks that that do that. Um There's a lot of, uh, more pointers um elsewhere if you want to learn about how to, you know, validating HTML, um, and learning about various HTML 5 elements, um, for the most part I mean you're gonna be using some pretty standard ones, um, and you'll see some examples of these in the lab that you can pick up and then obviously I mean there's heaps and heaps of resources online about all kinds of, you know, uh, different examples of how to do things with the HTML, um. All right, um, any questions about HTML before I move on to CSS? Uh, so, HTML is the content um and then CSS, um, it's just cascading style sheets is basically another language that kind of pairs together with HTML that specifies how the contents are meant to be presented to the user so it's really about how, how those elements get styled um in within the actual browser itself so things like the fonts, the colors, those sorts of things, right? Um, so. What is CSS, um, so it's basically a series of rules, um, you know, that specify how the content, uh, should look. So a rule has, uh, the following elements it has a selector, um. So the selector is basically how it matches to the elements in the HTML. So for example it might the selector might be for you know um all elements with of a particular class, all elements with particular ID, um, and where the class and the ID are those attributes that I was talking about before, um, so there's some kind of selector and it and it will, it will kind of apply. Uh, based on that selector, it will identify elements and then it will use a bunch of set of properties, um, and values for how the content should then be presented things like the font size, font weight, you know, these kinds of all kinds of things like that. So there are selectors for both attributes and elements so attribute selectors will select on an attribute name, you know, like ID or class or something like that. Or you can do a selector on elements so you could say I want all paragraph tags to have this or all header tags and so on and so forth. So basically the, you know, you define all of that. So you can contain your CSS in different spaces, um, in your program. So you can have it in an external style sheet. So this is this external file like it's like usually with like dot CSS as it's, um, extension. Um, it can be an internal style sheet. So internal style sheet is sort of, uh, it's like, um, inside of the HTML itself, but it, it's like in inside of a style tag, you have all your CSS. Or you can actually do inline styles which is where you actually put CSS rules uh directly into the elements themselves inside of your HTML. It's not generally recommended because it's of course, um, I mean the whole point of style sheets is that you could take the same content and potentially, you know, style it in different ways by just changing out your an external style sheet for example. Um, So here's some examples of the kind of rules that you can have, um, so, uh, the top one, you know, the, the rule has here's the selector, so it's basically saying I want all each one elements so each one is the is the largest header tag that there is, and you basically want to say I want all of these header tags, uh, to have three properties the color blue, background color yellow. And a border of uh like one pixel solid black. and so. Whatever properties you have are also tied um so like what your element is but like in this case color means the text color of the header um so it's gonna be blue text on a yellow background with a one pixel solid black border around it for any time you use the H1 tag in your in your uh website, um. Uh, here's another example, and this one just sets one property, the color red. Um, So yeah, this is what I was saying before like when you in terms of being where it gets contained if you have it in a separate file where you have all of these rules, it sits you just have this um link, uh, element. And, um, use REL attribute to say that it's, it's a style sheet, um. And then H ref is going to be the actual file name that has the style sheet, um. So that's the recommended uh way to do it, um. Here's an internal style sheet where instead of doing it external that you just use a style tag and you put the actual um style in there like that. Uh, or You do something like this so you can probably see just based on this example why it's, it's not recommended it just creates, you know, code that's hard to read. It's hard to, um, you certainly can't apply rules across all your different tags. So in this case you're applying the style rule here just to this H1 tag. Um, if you had another H1 tag, it would not then be applied so it doesn't have the same kind of selector thing that the other two examples have. Oh So you see it, it's, it sits in here right inside as as one big attribute inside this header one tag. And here it is in the paragraph tag as a. That's the attribute, oh. So how do these technologies all all work together? Well, Um, So when you make a network request, um, you. Uh, you get your HTML, um, within that HTML there might be, um, Uh, usually, um, you have your CSS is in the HTML header head tag. Uh, it's usually recommended to put the JavaScript if you have an external reference to your JavaScript inside of your HTML to put that at the bottom of the page. Why is that? Because it will start to render the HTML, uh, before it has received the JavaScript, um. So if your JavaScript is going to take some time to execute, you know, some fraction of a second or more. Before it starts to kind of show things on the screen, and so it's usually best practice to put the, the JavaScript at the bottom. The page, but essentially you make your request and you get your HTML, you get your. JavaScript you get your CSS and maybe other resources so for example image files and other things, right? um. So the HTML gets parsed by the browser into the DOM, which is document object model. The CSS also gets parsed into uh a similar object model called the CSSOM. Um, and then the JavaScript, when it gets executed, it's not actually manipulating the HTML or the CSS files. What it does is it's actually interacting with these two memory models that that the browser has, uh, for, for the, um. Uh, you know, for the page itself for the document that you're rendering. So the browser then takes the DOM and the CSSO and it renders it layout, uh, does a layout and then it paints it. So it's just so just extra. Steps of kind of, you know, actually creating the visual uh web page that you that you see. The important point being that. You know, the JavaScript, um, is the key thing that gives you the kind of interactivity, um, for your web page because not only does it manipulate what's in the DOM, um, but then you can also have it, uh, trigger do things like call backs so like if you have events where the user interacts with elements in the DM, like click on a button for example, the JavaScript can some JavaScript could be executed uh based on that. Um So, Altogether, uh, HTML has selects of elements. Many of these are predefined. Um, but you can define your own kind of custom attributes if you want. Um, the elements are referenced by the element type, for example, paragraph tag, header tag, so on and so forth. It can have a unique identifier usually that's like ID equals and the idea behind the ID is that it is indeed unique for every element. It doesn't have to be actually. I mean, you can if you want give two, fields the same ID. There's nothing that limits that. But generally speaking, the idea of the, the ID field is going to be some string. It's unique to the element and or uh you might reference by a class and so that would be like a class of elements that all share some property right? um and there can be other ways like you could have um other kinds of custom attributes and other things. Other ways also you can do is you can actually parse through if you know the structure of the tree you can say I want the third paragraph element under, you know, the top level, um. Div tag or something like that. Like you can actually, if you know the structure of your tree, you can parse through the tree like that and find an element that way. Um, that's generally speaking, not like, uh, the best way to do it. It's much better to use like an ID or a class to do it. Um, Then the CSS has the rules. It applies the presentation to all the various reference elements to the selectors. And then the JavaScript will both get and set um element content and the element attributes and values based on these references um that you defined here right um. So, The HTML document is the primary source, um, it has the HTML obviously, but it also has within the HTML, the, um, a either it like CSS directly in the HTML file or reference to an external style sheet. And it also has the JavaScript inside of the HTML, uh, either in a script tag or as a reference to an external, uh, JavaScript file. So the HTML is like kind of the first thing, uh, that has everything and then from that, uh, it links in together the CSS and the JavaScript. All right, uh, any questions about any of this? OK, cool, um. So as I said, content versus data. Remember that the data is what's in the JavaScript data structures, so things like arrays and objects and also what maybe what's in your database, um, for your for your program, the content is what's in the HTML elements and so you need to have some mechanism for the data to be injected into. The HTML content. This doesn't happen automatically, right? There has to be some mechanism to have that happen, for example, some JavaScript setter or something like that that that puts the data into the content. Um, Also, when the user enters information that you want to retrieve from rendered fields on the screen, uh, you might need things like JavaScript getter functions that pull that information out of the field. So You can do all of this um by writing JavaScript code directly that like using the the the kind of like the example I gave earlier where you you go into the document object, you select items by ID you set them you get values and so on and so forth. Um, The challenge is that because um. There's so many different things happening in all kinds of different order and kind of a uh web environment and the users interacting with the page in a totally unmanaged way, right? Like they can interact with different elements um however they want. Um, It's very often hard to kind of maintain a clear sort of like link between the data and the content right and making sure things are lined up correctly so this is where frameworks come in so JavaScript frameworks have been developed to sort of facilitate this binding to between the content and the data um and. They have there's different ways to do binding. There's one way binding. There's two way binding, but essentially they all have some mechanism to sort of inject the data into the content and retrieve the content into the data automatically so you just define uh your. You create kind of your components or your elements of your page um and you just describe sort of um which ones you want to um are kind of important in your in your code and then depending on the framework and how that you know there's different ways it's actually implemented it will more or less automatically bind between the data and the view uh or the the content so for example. If a data field changes value it's gonna automatically inject that into the content so frameworks are super useful and powerful um and allow you to build really interactive web pages, uh, rather easily. Um, All right, so. No, I just The 7 slides. Uh All right. So This then uh brings us uh to. Uh, the next topic, um, because we want some nice way to map our content and our data together, um, and so this is what leads us to building single page applications which I've already talked about a bit earlier in the course, um, and in particular our JavaScript frameworks are used, uh, to help us, uh, do that. Um, So here's the outline, but I'll, um, just dive right into it. So JavaScript frameworks have been uh developed over time, um, and have been, there's been kind of new ways they've been kind of um. Like basically they've been refined over a over a long time, um. So early on, Uh, when JavaScript was first created, um, it was like around the mid 90s, it was introduced and for many years there was very poor uh browser compatibility. um so what this meant is that like if you wrote some JavaScript to work, um. Uh, with, um, you know, maybe one type of Internet Explorer and then you wanted to use some other, uh, one like Netscape way back when that was one of the. Um, popular, uh, browsers, uh, you know, you often had to have like custom kind of JavaScript depending on like what kinds of. The browser you were running and so on and so forth. Um, Come, so. Over time, um, people tried to like move away from that because it was a really a real pain to try to build an application that's gonna run on no matter what browser people have, um, so some of the changes that started to happen is in 2004, um, we, we got standardized, um, Ajax. I'll be talking a little bit more about what Ajax is but Ajax is essentially um. Uh, the framework that allows you to sort of request, uh, JSON data, uh, from the server. Um, and sort of update the, the, the, uh, web page dynamically based on that, um, and so Google Gmail was sort of the very first application to use this, uh, you know, really, um, in an effective way in a real application, um, and it was really kind of maybe the first example of a really true single page application where we think about a web. Page that is really truly an application that behaves something similar to what we think of a regular desktop application doing like. You know, you can interact with it. It maintains some state over the session. It's doing. You know, you might have multiple views and so on and so forth all just based on your interaction without ever actually changing, uh, the URL, um. But um sort of along with this, um, you know, because people wanted to start to uh use um. Ajax, which I, I will explain in more detail in in coming weeks, um, that people needed to, they wanted some kind of standardized frameworks to work with, um, they wanted to be able to build these applications, not worry about what browser version they were using and so at this point, um, JQuery came about and so JQuery was a hugely popular library that allowed you to sort of write, um, programs. To interact with elements of the web page, uh, without worrying about what version of the browser that you were working with, um, it basically hid behind the scenes some kind of, um, you know, it hid behind the scenes different, um, you know, idiosyncrasies of different browsers and implementations for kind of common, um, uh, actions you might wanna do, uh, with when working with the content of the web page. So JQuery was hugely popular. I'm guessing there's probably still many web pages out on the web today that are built using JQuery um. But then, uh, the next big revolution, uh, happened, uh, with, uh, in the 2010s with this idea of model view controller, uh, data view binding framework. So what that's a mouthful but essentially what this is is is that um. Basically Um, there's gonna be some kind of, um, like framework code, some JavaScript that's going to do some kind of automated binding between the data values that we have in our JavaScript. And the view of our actual web page, um, you know, our, you know, all the elements that that we have there. And so Angular JS was the first big one. There were other ones it was like a flurry of these different ones coming out. Some of them have since fallen by the waysides and nobody ever uses anymore, um, but Angular JS was the first really popular one, but it was a super heavyweight framework, um, and it over time, um, you know, people wanted something that was more lightweight and that's when, uh, REA came along. Um, so React was developed by Facebook, um, and then View JS, um, came along as, as sort of it was also built by a team at Google similar to Angler JS, but it was they wanted something lightweight and they had learned some things from RA. Later on, Angular actually had Angular a next version of Angular which adopted many of these other features and so on so there's over time there's been like a lot of uh development, but I, I think it's fair to say that probably React is sort of is the most popular but you know by no means like the only uh framework out there now, um, for React is very um. Is, uh, still, I mean has a huge number of libraries so it's very easy to kind of build on top of it, um, lots of different applications so that's part of the reason why we've, we chose to use it as the framework, uh, for this course, um, but, um, but yes, there's other ones like view and and Angular and uh more, uh, like I mean not that recently anymore, um, but there's also, uh, newer frameworks like Spell, um, which are coming on board which are. Kind of going back, um. To, um Uh, so, so the way that all these other frameworks work is they have like a large framework code, um, that is basically running an engine on the client side to manage this data binding, um, Sve has kind of gone back to the earlier days of directly compiling, um, sort of directly to the JavaScript, um, the, the code of your, um, of your application without having this external library. Um, and so it, it, it's sort of like, uh, it's kind of going back to first principles and some people, uh, prefer it, but you know, everybody has their own ideas of, uh, what, what they like, um, so. Um, so this move to this, this JavaScript frameworks, um, basically drove was driven by the desire to move to the single page application model, so the users want a lot of responsiveness and interactivity, um, that helps the the user experience, um, and so, um. It you they wanna, you wanna feel like when you're in a browser like you're it's no different than working with a native application or a standalone application right? um. So, uh, Also, um, but alongside this managing the interactions with the user, um, is, is very, it can be much more complex than just managing communication with a server. So if you were if you build a web page and you just wanna make a request to servers like you have your API that's fine, um. You just divide your end points, um, people make their request and then you send back the response and, you know, maybe. You have some state management system built into it either through tokens or cookies or whatnot. But It's still a pretty kind of easy thing to to work out, but imagine you've got a web page with all kinds of different ways someone can interact, different click events they can do those click events in different order and every time you click it puts the web page into a different state, and so on and so forth. It can get very, uh, complex, um, so these, so, so if you're building a single page application um. It you basically, um, what something's gonna make it an easier, uh, experience to actually program the behavior of the application. And that's where what the uh. The, the frameworks do for you, um. So a key thing is this quote is that um single page apps are distinguished by their ability to redraw any part of the user interface without requiring a server round trip to retrieve HTML and so this is achieved by separating the data from the presentation you essentially have a model layer that handles the data, um, and a view layer that reads uh from the models, um. So Uh, like I said before, you have your data and you have your content, but those are quite explicitly kind of, uh, separated out and so, um, you separate those out clearly, um, and then if you have a single page application you want to sort of because people want interactivity you wanna try to reduce the um the amount of communication that you're sending to the server um and so you're running more and more of the application on the client side. Than you would have previously, um, so you might occasionally download resources that you need some HTML CSS JavaScript you might do background fetching of data, um, using, um, different types of technologies, uh, for example, connecting to your, um, API. And generally you're only gonna fetch data. You're not gonna fetch new web pages, you're not gonna fetch new HTMLs or CSS. You're only gonna be fetching data and then that data gets pulled into it, um, modifies the content on the client side. um, it's not coming from the the server, you're not asking the server to give you some new HTML content or something like that. Um, there's other, um, uh, issues that we need to deal with that we'll cover in later lectures. Um, so for example, you might need to fetch data from other servers and so this introduces new concepts like cores, which I'll, I'll talk about, um, just giving you a kind of a, a sense of where we're headed. um, we'll be, we'll talk about that. There's certain security issues or considerations we have to take into account if you build a web page and it's collecting information from multiple pages, um, and then. So then on the client side the. Uh, you actually do all of the handling of, you know, you, you, you request those resources initially the HTML and the CSS JavaScript, but then from then on you're just collecting data, maybe some JSON data, and then you are going to sort of navigate or the user is gonna navigate through your application all through using a client side JavaScript, not by making new requests to the server so. Um, the the JavaScript handles the routing within your application, um, uh, using the, the page history. So, um, if you kind of click through your application, you might see you're clicking through different pages of your application, for example, and and the URL might be changing, but what's happening behind the scenes is you're not making a new request to the server, uh, you are. Just, uh, kind of rewriting the content of the page dynamically all on the client side, um, and, um, it's, it will record that in the history of your of your URLs but there, you know, in each of those steps it hasn't made a new request to the web page. So all the routing happens kind of within the single page application itself. um, it doesn't, it's not routing in in the traditional sense of going out and getting new web pages, um. So. So when you have this kind of thing, uh, you kind of, um, you have to think about the balancing of the workload of your of your application, um, so you'll have a server side application which will be something like the Node JS server that we've talked about. You have the the client side of your application and so this is going to use various front and library code, um, for example, React is the framework code that we're gonna be using. That library code is gonna be there and then the communication between the client and the server um is basically API driven you will make some request um and get some JSON data back uh from each of those, uh, requests, um. So, um, when you build an application like this, um, you have to think about, um, how you manage your assets and your resources, um, things like, uh, um, managing, uh, dependencies in your application, we'll talk about that and get more detail of that later on. I'm partly trying to just set the scene here, um. And also as you design and implement your application um you wanna think about things like modularization and design patterns in terms of how you actually, uh, uh, build it, um, and, um, a big piece of all of this is, you know, whenever you use, uh, front end up, uh, frameworks this is this notion of templating you're basically use some kind of templating for your web page to sort of describe the elements of of your page, um. Uh, with sort of these templates, um, and then those templates are gonna be filled in, uh, with the data as it changes, um. So going back to just the reference um. Uh, model that we had before here in uh in the browser we're gonna make you're gonna there's all of these different technologies being used to connect to the server but on the client side we're gonna have react as our framework, um, and it's going to, um, be we're gonna be interacting with a lot of concepts here, um, that we'll, we'll talk about in various degrees in the coming, uh, lectures, um. All right, um, so, uh, just in the last few minutes that we have, um, before we finish up for actually for the whole term, um, but I hope you have a great break, um. So the first of these is um I wanna talk a little bit about design patterns because design patterns although um I mean design patterns are something that comes up again and again in in computer science, it's certainly not limited to, um, web programming, but it is kind of an important uh concept uh to think about, especially as we talk about uh frameworks. So how many of you have come across, uh, design patterns in previous courses? OK, a lot of you, yeah, OK, so I'm not gonna spend too much time on it. I just, um, so, so design patterns are um. I mean they actually go back to architecture so it was originally a concept that came out of a um. There's this architect, uh, Christopher Alexander who was, uh, wanted to create design patterns for like, you know, buildings and, uh, communities and so on and so forth. He wrote this big book of them, um, and then it got adopted into into software, uh, design, um, and so. You know, back in, in the 80s and 90s, um, but essentially the, you know, the part of what it's all about is how is this notion of a separation of concerns. um so we've already, I mean, we've kind of hinted at this already when I talk about data versus content, uh, but essentially. Um, the whole idea behind design patterns is you want to kind of separate software code into different sections, and each of those sections deals with a separate concern, um, so it helps you solve the complexity of doing software development, um, so for example, object oriented programming is one example you decide you divide things into classes, objects and methods, right? Um, in web computing, we have HTML, CSS and JavaScript as as a separation of, of, of concerns, um. When it comes to building uh a web, uh, application, um, I'll just, um, quickly, uh, talk about this and we'll we'll finish up the, the key thing, uh, like I already said is that we have data and we have content in the case of where we're thinking about content being in HTML, um, in the, in the design pattern world we think of that as data and or the model and the view of the data. So for example, you know, if we have a data model, it could be an array an object, it could be whatever that could then be represented in any number of views, right? So the data itself could be a table, it could be a bar chart, it could be like a pie chart, whatever, right? So you have the management of the data over here and the visualization of data and you wanna kind of keep those those as separate as you can, um. So a generic approach to this, and this is something that you see over and over again is this sort of model bridge uh view structure right? and there's actually many, many, many different kind of models out there, um, people argue over them and it really doesn't matter so much, um, from my perspective. The key thing is that you, you have different data, uh, and you wanna keep the data independent of how it's presented. And so you're gonna need some connection which we'll call a bridge, um, sometimes it's like what the controller is often in the model view controller, but there's other models as well but you have some kind of bridge that maps the connection between. The data, uh, and the view. And just to wrap this up, uh, the what the JavaScript framework does is it it basically creates the bridge for you, um, so that when you change your model you will automatically see that generated in, in the view, um, and some frameworks are two-way binding, which means if you change the view, it will go back into the model and other ones are one-way binding, which means they only go from the model, uh, to the view. Um, all right, so I'll wrap up with that. Um, we'll talk a little bit more about some different kinds of frameworks when we get back, but then we'll really just plow right into React in particular because that's, there's a lot to learn about, uh, React and how it works, um, beyond even what you're doing in, in, in the assignment itself. All right, well, thanks everybody. I hope you have a great break and I'll see you all, uh, when we get back.

SPEAKER 0
OK. where I was you. The land Thursday. OK I Yeah it Uh Oh, uh-huh. Right. What I don't. So Thank you. No. Well that OK Yeah I don't and then I just realized. Yeah. OK. Politics. I Right.


SPEAKER 0
I I. Yeah. Yeah. Yeah. Yeah. Yeah. I just like. I watch. I I. I don't know you and I. Yeah. I Yeah Yeah. I do. Yeah Now. OK.

SPEAKER 1
All right, hey everybody, welcome back, uh, from Terre. Hope everybody had a good break, um, so. First things first, uh, if you haven't already seen, I've put the marks for assignment one up, um learn, um, I didn't put all like the full detail of all of the how all the tests, uh, when if you've got questions, uh, just send me an email um there's a few people I'm already, uh, there's there's a few, uh, cases where the tests, um, maybe failed halfway through, uh, for. One reason or another, um, for example, um, if some type of code wasn't put in all properly into tri blocks, um, occasionally something would occur in a test that was new that, you know, maybe it wasn't, um, in the tests that we had given to you while we're developing and so that, that, you know. Can crash the crash your server things like that happen but um there's a few cases I'm I'm looking through um so if you contacted me uh with questions about your grade, um, hopefully I'll get back to you, you know, by this later this week, um, because I have to go through them in a little bit more detail. But overall, uh, you know, people did, uh, pretty well, um, pretty much on par with, uh, way, you know, what people have done in in previous years, um, for the same assignment. Um So the second assignment it's gonna be about building the front end application. Um, so, um, first things first, let me just show you here. Because I've had a few questions about this, so in the on the learn page here, um, uh, you can see here there's information about assignment to here, um, implementing web client and the user stories that you you need to develop an assignment to as you go through the labs, um, you know, you'll you'll get a sense of, uh, what's involved, uh, for those, um. It's a similar structure as last time around where you know it's a few weeks in labs and then you're working in the labs to finish up the assignment. The 12th week, um, please be aware that you need to be available in lab session to come to help sort of, uh, run through tests for all of the various, um, Uh, you know, other, other people's submissions, so we're gonna set that up as, uh, where you kind of anonymously get assigned, um, three of, you know, other people's, you know, submissions, and then you're, you're gonna kind of run through a series of tests or a Google Forum. I'll have more information about that, but just be aware that. You're expected to, uh, participate that in in week 12, um, ideally you come during your scheduled lab session so that we have enough spaces for everybody. Um, if for whatever reason you can't make it during your currently scheduled lab session, you can come to a different one, but yeah, if you can please try to come to the one that you're scheduled for just so we don't get too many people in one session, um, but the assignment to information is here, um. Uh, I will, uh, go a little bit more detail about it, uh, probably next week, go through the, the user stories a bit more, but importantly, so I had a few questions about this already, um, I've put the reference implementation for assignment one up there, so there's a link to that. So you, you can use that to develop against. So download the code from there, run it locally, um, so that you're running the API server on local host port 4941. Uh, and then you can develop against that, uh, directly, um, that way you don't need to kind of develop against your own assignment one submission or anything like that. Any questions about that? OK, uh, cool, so, um. Yeah, hopefully, you know, in the labs you'll see um that uh. Excuse me. There's, um. Uh The labs go through, uh, developing client site applications to react. I'm gonna talk about react in the lectures, uh, starting this week, but I'm gonna go a bit deeper into some topic areas and cover some, some aspects of REAC that you don't, we don't do in the lab. So it's really supposed to complement that. Um, so yeah, once you've completed lab number 5, then you can kind of move on to the assignment from there. All right, uh, cool. Um Any questions? Yeah. When making the front end, I know it's it like just focus on. Uh, you mean resizeability as in like a different kinds of screens, yeah, um, not really. I mean, don't worry too much about that. I mean, you wanna have a decent enough user interface that it's usable, uh, but don't worry about different form factors, all that kind of stuff, that's fine. Yeah. All right, cool. OK, so, um, Going to our. Slides and where we were. So I was a little bit running a little bit behind. I'm um going to open up week 7, Slides, um. And I'm just gonna kind of pop ahead a little bit, um, the stuff on the, um, design patterns, um. Um I, I don't wanna, I was running a little bit behind in the in the material, so I'm just gonna pop ahead to this, um. Because I think the the design pattern itself is pretty self-explanatory. You can look at the signs if you want, um, but since I'm not covering it, I mean, there, there won't be like a question on the exam about it, so you don't have to worry about that, um. So Essentially what we're doing now in this term is we're switching over from the back end uh to the front end and so the front end, what that means is we're developing an application that's gonna run inside of a browser uh and it's going to be sending some requests over the network to the API, uh, but we need some way to kind of develop that front end, right? Um, so, Over the years there's been a lot of work in sort of making. Uh, front end, you know, JavaScript, uh, applications make it easier to develop complex applications on the front end because, um, uh, you know, applications have become more, well, they've become more like applications rather than static web pages over time. Um, and so they of course become increasingly complex and we need kind of better ways to develop, uh, in these kinds of environments and so part of that has been the development of what we call data binding frameworks or oftentime called JavaScript frameworks, um, so there's a number of these different ones that come up over the years, um. Some of the more popular ones are angular react, which we're gonna use here in the class, uh view, uh, and some others, um, so I wanna give you a kind of a, uh, you know, a foundation like overview of different kinds of frameworks, a little bit of the differences about them before we kind of switch over into specifically looking at react. Um, So, um, Uh, like I said, there's been a number of these different ones over the years, um, and some of them have come and gone in popularity, um, some of them they were never as popular as other ones, um, and they kind of work in some slightly different ways, um, so, uh, I'll explain a little bit more about what data binding, uh, means, but effectively we want some way to match together some model of sort of the state of our application. With the view of our application that is all of the different visual elements and the interaction, uh, all the, the widgets and things that we can interact with on in the application, we want to have those kind of be binded together so if the underlying state, the model changes, then we should expect the view to automatically update, uh, and if we interact with that view in some way, then it should in turn affect the state um. And so What these frameworks do to varying degrees is they kind of they automate that relationship between the data uh and or the model and the view uh and so um. There's, uh, this is sort of. You know, a kind of a general schematic, but you can see, you know, that they do, um, the, the data binding that occurs is can be more or less automatic across some kind of spectrum, uh, it can be in a more simple or more complex and you know, different, uh, frameworks have been developed kind of sit within within the space, um. So, um, What we're gonna be what's what's been kind of new in the JavaScript frameworks that have been been developed since really around uh 2014ish I guess, um, is this notion of uh client side uh rendering. So what this means is that when you um when you go and open up your web page in the browser. Um, you're going to kind of initially put in a URL, right? So what that URL does is it goes and finds an HTML page, downloads it, and then inside of that HTML there might be some JavaScript and other sorts of things, um, so the way that most of these, uh, JavaScript frameworks work is that you get the initial HTML page, um, and. It is essentially very kind of bare bones in terms of what the actual content is inside of that that HTML but inside of it is some sort of. A script that calls some kind of JavaScript file. We'll just call it bundle. JavaScript, um. And so essentially what's gonna happen is that bundle is going to execute a bunch of JavaScript and it's going to populate all of the elements in your HTML um in one way or another. Um, and so, um, this is when, when you get that initial bundle that's called getting the first, uh, content full page. So this means you're, you're getting the first, you're getting the HTML and you get that that page, but at the moment it, it executes the JavaScript at that point then it's going to go inside of that JavaScript at somewhere it's going to call some kind of rendering method. Um, and inside of that render method it's going to actually then populate all those HTML elements, um, so. You get that first bundle and you can kind of say that it's loaded the the web page, but. It's only after it executes that render function inside of the JavaScript, uh, then that at the end of all of that different things execute, um, and you get to a thing called time to interactive which is basically once the render function is finished then you have an interactive uh web page. Now all of this happens relatively quickly, um, you know, depending on the complexity of your application, you may or may not notice all of this stuff happening. Um, but that's effectively the way these frameworks work is that there's usually some bundle of JavaScript, um, that sort of does the act has some kind of render function and then that render function is going to, you know, pull all kinds of information together and actually turn it into the HTML page, uh, that you see so we don't normally see HTML pages that are like the actual HTML. Tags and all of that stuff in the kind of the the root like index. HTML file or something like that um usually that file is very, very minimal um and it's only then populated after it executes the JavaScript, um. So the way that the frameworks work from a development perspective is that um well, there's a few different ways it can work because some of them use a thing called templating. So what this means is that you. You kind of develop your, what you think your HTML, um, is going to, to look like. So you write some HTML like this, um, where you have some tags. Here's a div tag. You have some elements inside of the HTML and then it the templating is this idea that it uses this what they call a mustache syntax where there's some kind of syntax that indicates this is a this is actually referring to some variable uh that's gonna be set within our within your framework um and then that's what that's how the data binding occurs so it binds some some variable to some other. Uh, type that's defined inside of your JavaScript code. This is some viewJS code, um, just as an example, um, so where it's creating something called the counter, um, basically it's a kind of an object, um, and that, that counter, um, is, uh, basically has a function for initializing the data and it creates an application with the counter and it mounts it into. Uh, this things with the ID of counter, um. So, um, in this kind of format, so this is what what viewer does and what Angular does is you still kind of separate out the HTML and the JavaScript are sort of two different things and then you use this kind of notation, some kind of templating notation to kind of hook together elements in your JavaScript code to your HTML, um, so all those things sit in separate files, um, turns out React does something different. It kind of inverts the whole thing. Um, it kinda starts with the job, something that looks like JavaScript, uh, and has the HTML like stuff inside of the inside of the JavaScript, uh, but we'll come around to that. So This binding then like if you if you write some kind of code like this right what what this does because you're using this framework this this view framework it is when, when you run the program, um, it's going to turn this into whatever value counter happens to be so in this case it's set to zero, but you might have some logic inside of your code. That changes that value like increments it or something like that in which case because they're bound. Through this kind of uh representation, it will like automatic like if this value changes at all, it will automatically change the number that's written here for for counter so. If you're doing kind of uh data binding, there's there's different approaches you can take and different frameworks will kind of implement them in different ways. So 11 is called one way data binding, um, so one way data binding can kind of go either way it can go from the view uh to the model or it can go from the model to the view. Uh, generally speaking, um, we're normally, um. Tie it to, I mean, most of the frameworks, uh, that I'm aware of, um, kind of automate that that are one way binding they automate from the model up to the view. So the model is like your it's like that counter object, right? And so that counter object then gets merged together with the template. And it generates the view and so if you were to write some code to change the model, you know, say it changes the value of counter, then the then if you're using the framework, it will automate that to update the view directly. There are some frameworks that do two way data binding automatically where they hook together the. The view and the model together um so that um you have something like a a template that becomes the view um and then there's some sort of basically kind of a a loop that's going on inside the framework code that's watching both and and updating them uh as needed now those kinds of um so angular. Um, has, has implemented that kind of a model, uh, but when you use a framework like that you can get into situations where you get like loops, uh, happening, um, so you have to, to be a bit careful about that. So, um, React is a one way, um, binding, um, so what this means is that. When you develop your code, you're gonna be doing things that change the uh change the the data right? um, sorry, when, when you have when you when you write code that changes certain uh data items it will automatically update and re-render the view. Um, but you need to describe like how taking certain actions like clicking on a button, what, how that changes the value of of the model. We'll see that in in in with some more examples as we go. So effectively the way the JavaScript frameworks work is that they are, they have, we we talk kind of abstractly about there's the the data or the view sorry the data, the model and the view right and it it pipes automatically from one to the other but what do we actually mean by the view um so. In this example, if we go back here, right, it looks like the view is some HTML code, right? But in reality, you know what the browser has in its in its memory is not some HTML, but what it has is something called the document object model. So this is essentially like a tree's memory structure, uh, that shows uh. Like, basically it's the structure of the document and it has all of these elements as similar to the structure of what you think of HTML, but it's a memory representation of, of it's basically a tree re representation of of what we think the document, uh, looks like and so when you write JavaScript code. You're not actually rewriting HTML. The HTML's already been parsed, but you're, you're actually directly executing and and manipulating the elements within your the document object model, um, so this is kind of a standard for all, uh, HTML documents and it just kind of looks like you would expect, right? I mean, it looks a bit like you have elements and elements inside of them have other elements. Uh, and they can have other children and, and so on and so forth. So it's basically just a big tree structure, data structure. Um, so, Um, when you If you're writing JavaScript, right, that is changing your document object model, you can actually do that quite directly like when you write your JavaScript you can say, you know, go to the document object you can set the value of different elements and so on and so forth. But the framework because it has the data binding, essentially what's happening is it is updating the document object model automatically, right? So you change a value and it should update the document object model, um. But what happens is that in a lot of big modern kind of web applications is that those document object models like very quickly grow in size in terms of the number of elements they have. So these are just some random websites and the DOM counts that you get like you can just load up any page that you want like go go into like Chrome or whatever browser it is, go into the developer window and if you just type in document. Get elements by tag name and then just do star meaning get all of the elements and that's gonna give you back an array of elements that are in your um in your document um and you just call the links or get the links property on that array. And I'll give you a number. So I right before I did the lecture actually I tried this in the Canterbury.ac.nz website and it was like over 5000 elements. So, so there's a huge number of elements, um, and so if you have a JavaScript framework that has some kind of data binding potentially. You are changing that tree very quickly, um, and, and often so it has to be re-rendered. So imagine you had some kind of counter right? um, and. In that example where it was just like putting a number inside of some field um and that counter was just ticking off every half second or or fraction of a second and it's like 123456, whatever like then if you're doing that basically what you're what you're doing is you're updating the document object model multiple times per second, right? um. When the DOM size gets very large, this becomes, um, basically the browser just is gonna look at whenever any any DOM element changes it's going to want to kind of re-render the whole tree, right? Um, and so one of the things that the frameworks have done is they, they need to be able to work efficiently so that it's, it seems very fast like so if you're, if you're updating the data it's going to be responsive and it's going to be you're gonna have a dynamic website that's redrawing, uh, very, uh, quickly, um. And so given that the it can become very large and there's lots of nodes to uh traverse you could potentially get into some big performance impacts uh with uh if you are if you are actually resetting the DOM like over and over and over again so the the way that um. The way that a framework does this is they've they've developed something called a a virtual do so within the framework code itself they actually have a whole complete memory uh mirror copy of the document object model and it does it it it kind of very efficiently does these kind of diffing operations on different elements of the tree, um, and. They, they use this in the background and they don't like they manipulate that virtual dumb and then ever so often update the the the whole um in a in a very efficient way so all of this happens this is kind of all bundled together in the in the framework code that you're using and you don't really need to manage uh any of this, um. But it's part of why you can use these frameworks to build really fast interactive applications that seem to redraw, uh, very quickly and can have lots of renders without having to worry about, uh, performance, uh, hits, um. So So it's basically an abstraction of the object model that's in the that's in the in the browser um and then the framework when you are changing the model it's not actually it's not actually changing the whole document object model inside of the browser but it's just modifying, uh, the virtual one, so like, yeah, like React view they all have developed this this idea of the virtual dom sort of behind behind the scenes. Now, React was the first framework to do this, um. But then some other ones kind of like adopted it uh soon after um so you don't ever need to directly when you're writing your code, um, when you're using a framework, you never have to directly interact with the dumb so you can, you know, you can call just regular JavaScript functions and manipulate elements within your page, um, but you should never have to do that you should only have to. Kind of change state variables, uh, and then if those variables then are referenced in whatever templating format, you know, the framework has defined, then it should kind of automatically, uh, hooked together and you can pretty much be guaranteed that it's gonna be pretty, uh, performing, uh. So, um, There's a bit more to how it works, um. I don't know. I mean, basically, it has to keep track of sort of the data, what data has to be changed. And that it needs to be updated, uh, and then it needs to, uh, so it basically has behind the scenes this kind of polling mechanism, um, so, so the framework code is all running inside of the browser it's sort of a bundle that's that sits there and. It has some kind of loop internal loop that's doing this checking. It's called uh uh dirty checking and so it basically pulls the data, um, all it has to keep an eye on all the different data elements, uh, in, in your, uh, code that are are tied to, uh, the view, um, and it sort of checks that and then it kind of recursively goes through. Uh, the different elements and then it sits there and it and it's got something that's as it's checking it's observing, uh, for the state changes if nothing's happened it won't do anything but then if it does then it knows exactly what to update, um, and then, and then it will kind of bundle them together like in a way that like if you. If like one element changes and then another child element changes, it won't render twice. It will kind of go through and know to kind of bundle those together and and do it all in one update to the real, uh, do, um. So it has to have like inside under the hood it's got this kind of diff algorithm. So if you've ever used diff it's that's like program that can differentiate between sort of, you know, one data structure and another in this case it's like two tree structures and it tries to kind of look at what's the difference and then it batches together the reading and the writing operations of the real DM, um, and then it will only update efficiently certain like subtrees that are that are needed, um. They actually under working. I mean, I'll talk a little bit more about the under under the hood how it works, but the real details of is they are quite like complicated in terms of how it it manages all of this, um, um, but I mean the key takeaway is just to realize that you know when you're using a framework it has these efficient mechanisms through this kind of different data structure, the, the virtual dumb that allows it to kind of efficiently update the, the view, um. And not cause lots of redraws, uh, from the browser, um. So that's kind of a visual of that, um. So So all of these frameworks have this kind of virtual dumb and that's sort of how the data binding. Is hooked into it via this whatever kind of templating that you have um so I just wanna highlight a few different kind of frameworks that are out there uh so that you're aware I mean if you learn React React is probably the most popular one around now um. But you know it didn't used to be and who knows in the future it may not you know and you may come across some any number of these other frameworks if you go out and and develop so it's good to be aware of, you know, some of the different ones that are out there um so the first of these is Angular so Angular actually came out before React it was um it was developed by Google, um, and they kind of wanted a system to build kind of enterprise scale software. Um, in the web, so like you want to build something like a, like a do like software engineering for a, um, for an enterprise environment, but it's gonna be a web application. How do we go about, uh, doing that, um. And so Angular is very opinionated in terms of how it works and how it's, it's designed and actually has gone through a number of different, uh, iterations, um, but the key thing is, um, some features of Angular is that it's first of all it's typescript only you can't, it's not, uh, compatible with with JavaScript it's, it's relatively complex because it's so opinionated about sort of how we're supposed to um behave. But essentially, um, the way it works is that you have these things called components. Well let's talk about components and rack, but you know components are sort of like your elements, your your visual elements that are in your that are in your, uh, web application and those um kind of get mapped to things within whatever in your templating, um, uh. Uh, templating engines, so like if you write some HTML and you, you use that kind of mustache type syntax, you in there you'll have, you'll have use the templating to just find your variables that are that are gonna be kind of dynamic and then it tight it binds together those um directly. So there's things within the template that bind to events in the components and and things in the component that bind directly like property values that bind directly to values that get displayed on the view um and so it kind of has this two way binding in here. And they have other kind of uh things like you can have services there's sort of background services that are running that can inject into uh different components, uh, and so on and so forth, um, so. It uses this kind of, uh, virtual dum, uh, just like, you know, many of the other ones, uh, to know when the DOM changes, but it's, um, It's a bit of uh from uh I, I haven't done, I did a little bit with Angular early on although it's changed a lot over the years, um, and adopted new ways of doing things. I'm, I'm not even sure what version they're on now. I think it's like 5 or 6, but generally speaking it's, it's seen as kind of like a heavyweight framework, um, really designed for kind of building large, um, software applications as as web applications. So Angular came along first and people thought that this data binding is really great, um, idea, but because it's so heavyweight and complex it wasn't really very easy uh to work with and so sort of a response to that, um, Facebook originally developed React, um, because they didn't want to, uh, use, uh, Angular, um, but they wanted some kind of framework, um, that had some data binding, uh, together. So it's, it's a little bit different, um, it doesn't use this kind of templating thing where it doesn't have HTML, uh, with those those templated, you know, uh elements inside of it, um, instead it uses something called JSX which you will have seen gotten some kind of introduction to in the labs, um, hopefully this week, um, and. So JSX is sort of like JavaScript on steroids, um, and so it's JavaScript, um, but it has, it kind of inverts it so that like there's a there's a function inside of of your JavaScript that kind of renders the the HTML and so so the thing that looks like HTML sits inside of this bigger JavaScript blob essentially um and so. So it pulls the HTML inside of the JavaScript, um, and then it has basically define a number of different components where each of those components has its own life cycle um it gets created, um, it's running, it gets destroyed and so on and so forth, um, and so. REACT, um, was, uh, it kind of took off, um, after, um, after Angular had been kind of had to run for a little bit because people find it way easier to kind of pick up, um, it was not as complex to learn all the ins and outs a little bit it was a lot more flexible, um, and I'd say it's the most popular framework at present. I mean one of the great things about using React is that there are literally thousands of third party libraries, so you can. Easily kind of, you know, people have developed components for every different thing you can imagine, um, and you can just import them directly into your project and use them, uh, easily um it also uses a virtual DO in fact React, even though Angular came out first, React developed the notion of the virtual dom. One of the problems with Angular initially when it came out was that it had the two way binding, but then it, it was getting slowed down because of the, the way the DOM. Was being rendered too much um and so React developed you know initially the, the first idea of the virtual do and then later on Angular came back around and adopted. Well, we'll talk a lot more about React um in the coming weeks. Sort of to round out um these I I should mention View JS so ViewJS is is another framework um it was also developed by a Google uh developer who found Angular too heavyweight, um, so it uses some of the concepts from React but instead of um. Putting everything inside of JSX inside of this big JavaScript kind of format and and sticking HTML inside of that, it goes back to the idea of still keeping the HTML and the JavaScript and the CSS sort of in separate files, um, but then using templating to, to hook them together, um, so it's it's a little bit closer to kind of native HTML like it looks a bit more like that. Um, as opposed to kind of react where you kind of the starting point is, is the JavaScript, um, so I guess if you're, if you're sort of a traditional old school kind of like JavaScript and HTML developer picking up view is probably a bit quicker, uh, than React, um, we used to actually teach with view in this course, but I switched it to, to React just because React is, I mean, view is actually used in production. In some places, but it's not quite as popular as as React, um. Uh, so I, I should also mention that's not the, the only so, so those are all frameworks that that run sort of in that way where like I showed before where you, you load in the HTML, then there's a big bundle JavaScript file that calls a render function and then that render function actually isn't it's basically a. A rendering function that sits inside of your um in that runs in the JavaScript engine in the browser and put fills in all of the elements in the DM um so some people don't didn't like that and they wanted to kind of go back to sort of the original uh idea that you don't actually have framework code. Like you don't have this big bundle of framework code that's running in the browser, um, instead, um, what Svet does is it it kind of has uh a templating, um, uh, templating format similar to kind of what what view does, um. And it compiles into JavaScript, but it doesn't have any, any kind of framework code. It basically. It basically generates it all into um kind of it basically compiles it all into the components directly um and and interacts directly uh with the DOM but in an efficient way like it it tries to handle all the efficiencies for interacting with the DOM directly into the compiled uh code. Um, so it's, it's, it has a, it's a different structure entirely, um, it tends to be even smaller and faster than things like, uh, React, um, for people that are a bit more purist about working at the HTML and JavaScript, um, and don't wanna. A lot of bloat, um, Svet has become quite popular. Um, it's not nearly as popular as things like React and View and Angular so it doesn't have as many libraries out there, um, but it has been growing in popularity in recent years. So, um, you know, if you're interested, it might be, uh, worth, uh, looking into as well. Um, so that's just like kind of an overview of 4 kind of big framework, JavaScript frameworks, uh, that are out there now. They, like I said, there are some have come and gone. There's spent, there's other ones that were on that, uh, initial chart that I showed that. Have essentially died off and they're not being used anymore um but now, um, you know, who knows what will come up in the next few years maybe they'll be, uh, new ones that come out, um. So The next stage is to switch over and really dive into react, uh, before I do that, uh, maybe some any questions about what I've covered so far in terms of, you know, the virtual do or, you know, other frameworks or anything like that. Nope. Um, OK. So let me just switch over to that. And we'll just start doing that and then we'll go into more of it tomorrow. Um. So you'll get a lot of experience working with uh React in the labs of course um. But I'm gonna go through some things here as well. No. Alright, so. Uh, I'm gonna talk first off about JSX, uh, and components. Um. To begin with, um. So one of the things that, so I'm gonna just introduce JSX obviously good experience with this in the lab, so it's sort of to complement that, um, but then I'm gonna talk about components in particular and so components are like kind of the building blocks, the pieces of your application that you're you're developing and in in the labs we almost exclusively use function components, um. Because, um, they're for for most purposes they're probably better to work with um they have a lot of nice features but there are these things called class components as well and there's certain things you can only do with class components um so I do want to cover them so you're so you learn about them. So yeah, so let's dive into JSX and components. So first off, um, When creating uh your React project, so yours you have, um, you know, in the labs there's uh there's actually like lots of different tool chains out there to, to build and create, um, create, uh, different kinds of JavaScript, uh, frame, uh framework projects, um, and some of them use different kind of bundlers than others, um, and so you, you know, you can follow the instructions in the lab and that's fine. Um, I did wanna, you know, talk a little bit about it that like essentially for React, um, you know, if you want to just create an application, usually the easiest way to do that is to use something like the Create React app, um, uh. Tool, uh, which you can just, uh, install, um, but you can also modify any like existing project you want, um, by you can actually add in the react uh JavaScript in using script tags so you can can pull react down from as a as an import, um, off the, off the web rather than kind of building it directly into your application, um. But generally speaking you kind of create your project using one of these tool chains and at that point you've got kind of your, your building blocks of of your application uh ready to go so let me just. Um, So when you're building an application I mean usually it's best to start um thinking about sort of your components from a visual perspective um I mean sometimes you might be thinking like if you say you're building a game or something like that you might you might be thinking about building your application in terms of the state of the game right? like how do you how do you represent the, you know, um you know the state of the game. You know how things change, uh, values in the game and so on and so forth um so so you can work on the on the on sort of the the data side of it, uh, when developing, but for many kinds of web applications I think it's easier to kind of think about it from the perspective of looking at it from the view. And thinking about sort of what, what are the elements that you're the building blocks of your of your application, uh, from that side. And then maybe that kind of will get mapped to some, some data model, uh, that fits that, um. So generally speaking, imagine a web page like this where you have like a, a header bar, you've got some kind of, you know, main section maybe you've got a sidebar so this would be some kind of like social media thing or or something like that, right? Um, well, generally speaking you can kind of decompose hierarchically your page into these different components, right? So you have like. The top bar here is a component, but like within that top bar you have a text field that you may enter in you might have a couple of buttons so each of these things become components that have other components inside of them, right? This main page has a whole bunch of different components that might have an image, it might have a, a user profile image, it has, you know, these different, um, sort of status, uh, uh. Boxes or widgets, um, this can be a post, uh, this can be, you know what, um, other users are doing so each one of these different elements is components that also have components inside of them, right? So generally speaking, you know, when you're kind of building up your application, it's a react application you kind of wanna put each one of these components inside of a separate file, um, so that like you'd have a header component, uh, some kind of, I don't know main main body component sidebar component, but then you would have components for each of these individual elements as well, um. And so, You could then organize your code um in different ways. There's not really like a canonical or correct way to organize the source files um for a react application um sometimes uh people will organize sort of based on function um. Uh, sometimes it will be sort of I'm gonna put all the components, so these are all the visual elements here and then maybe some other utility kind of, um, code goes in another folder, um. So there's not a one right way to do it, but basically we wanna think about sort of the structure of your application in term, you know, one way to think that is just how, how are you gonna import one component from another because if you think about, you know, maybe, um. You know, if if the feed has a, you know, has profiles inside of it and so on, then you're going to have to kind of go down through directories and up through directories and and this and that sort of thing and so basically you just kind of wanna organize it so that you can manage, you know, the relationships between your components well when you're importing other uh components from one source file to the other. Sometimes people move the the style sheets into another folder and so on. The key thing is just try to be consistent, you know, across the board, otherwise it can get very confusing and messy, um, over time. So once you get into um. A react application. Um, it's time here. Um Sorry. So the um. Basically the root of your application looks something like this, right? So there's a render function and so that render function is going to render a component and so you'll see here actually in JSX it's it's a bit of a mix it looks like JavaScript but this right here is not that's not JavaScript, right? Like you couldn't put something like that into. As a pass it as a parameter so you can kind of mix, you mix a little match a little bit of the uh HTML with uh with what looks like JavaScript but essentially what this is saying is I'm gonna render my. Uh, the, the sort of the. The the app component and I want to uh put it at the root element of my page, uh. And what it does is it imports a thing called app, which is another component in there, um. So, uh. This has changed a little bit, um, so this was previously it kind of looks like this, um, here, it's a bit different. There's a create root function. Where it's basically saying this is the root element that I'm kind of I'm kind of plug my my react application into and then at that element I'm going to then render and then you pass in the the the component that you want to so this is sort of your entry point into the entire REACT application. So this root element is going to be defined inside of your HTML, so you'll have some kind of basic HTML file and when you create a react app there is automatically an element with ID root that's that's generated for you, um. So Redo is this library so see it's, it's importing it um so it's a JavaScript library uh that then actually renders the JSX uh into the elements in the document object. Uh, model, um, so this is being executed in the browser, right? So the frameworks, it's the frameworks there, it's been loaded in and so React Dom is a, is a whole library function that all gets loaded down into your browser and is executed, um, and, and it actually build that builds out then your your application. Um, OK, so, uh, let me just, I'll just end with this because I see I'm out of time. Um, so the. The application components are all written in in JSX. When you import a component, you can use JS or JSX as an extension, um, and you don't need to indicate it here. Um, I would recommend just using JSX to differentiate it from JavaScript because it's not actually really JavaScript, right? It's a different, uh, language entirely. All right, so I'll just end with that, um, and then we'll dive in tomorrow a bit more about into the different elements of reactive.

SPEAKER 0
Alright, cool, thanks everybody. Yes. OK. I. Uh Yeah, that's. Oh. Yeah. I just ticked and my grade doesn't seem to have popped up yet. Oh, OK, um, well, maybe can you send me an email and then I'll check on your user ID. OK, thank you. What's up? Thanks. Hi. I. Well. You're gonna need. You're gonna need. Yeah. Let's take another. Oh that'd be 100, 200, 300. It's one thing Right, oh, that would be. So what you see in those user stories. And. The basic, so I think they just. But I think it's the That's So Wait, sorry, So, so when you uh. Oh. the. Yes. I'm sorry. Yeah. Um. Sorry, I. Yeah. It's just This Pretty good, right?

SPEAKER 0
Right. It's OK Exactly Yeah because the integration that actually. I I didn't even know that. Yes, Yeah. you should. I was in the. people Yeah. Could I do. Yeah. Yeah. I I So Oh.

SPEAKER 1
All right, hello everyone, um, so welcome back, um. So I, I still haven't had time. I, I, I need to catch up on some of the submissions. I know I've had a few people come and talk to me, uh, but I've been extremely busy, so I haven't had time to, to look back into some of them. So if you, if you've emailed me or talked to me, just, you know, bear with me. I'll, I'll get to it by, uh, later in the week, um, for the first assignment. I also pushed a little bug fix to the reference, uh, server, um. So, uh, if you've, you know, for whatever reason, if you, if you started, you know, early on the second assignment, um, uh, you can pull that change. It's just a little minor change to one line of code, um. But uh yeah, so any questions about that about the assignment about the um labs or anything I've covered so far? No, OK, great, um, so let's just continue on, uh, talking about, uh, React then, um. So yeah, so, so react, I mean the framework, uh, like I was saying before is it's this bundle of JavaScript code that what happens is you, you go and you know request your HTML, uh, from the server and then it runs some JavaScript and as part of that bundle, um, you have all of the react code and inside of that react code is this, um, uh, react um. Object that will kind of will render the application, um, take all of the, the JSX and render it in in a way. Uh, that is, um, you know, uh, based on sort of, you know, what you've designed inside your application, um. So the components in when you write in JSX it looks like JavaScript, um, but the elements within it, you know, can look kind of like, uh, HTML as well, um, so it's like a little bit of a hybrid, um. So when you, you know, are rendering kind of the root of your application, you have your basic application, but then you have to hook that into your HTML somehow into that actually into the document object me to say this is where all of my racked components are gonna start at inside of uh my website. Um, and so that's what's done here is that the document, um, it's just the normal JavaScript, um, document object, uh, that's provided whenever you open a website, and that has, um, you know, allows you to select the different elements within your document object model. In this case we're gonna get the element that has the ID of root and we're going to attach whatever gets compiled from this app file into into there, um. So, um, Yeah, so JSX, it's, uh, the syntax. I mean it looks like JavaScript for the most part it is JavaScript or TypeScript really. I mean you can, it can be either JavaScript or TypeScript, um, and it looks like a bit of a, a mix of the two, so it compiles, uh, to the HTML with the um. Uh, with the bundled JavaScript, uh, as well, um, to run inside of the browser, um, and so what happens is your project has a thing called a JSX preprocessor so you won't have actually seen this. It's all like if you were to open up the package. JSON file in your in the root directory of your project after you've created it. The react application you can see um that it has you know some kinds of these things like called babble or you know other things that are essentially these are the the preprocessors that do the actual process of taking the JSX and converting it into the format that the browser can actually uh work with um. So yeah, so just real quickly I'm gonna go through a few examples. I mean you will see this in the labs as well so um uh hopefully you know if you're going starting into the labs then, uh, it should be, um, pretty straightforward so you can kind of take things that are HTML element types and set them equal to what we would look at as a JavaScript variable so. You can have like for example a title and say that title is going to be. You know some text welcome all inside of an H1 tag, right? So this is HTML, uh, but this is, it's being assigned to a variable, um, called title, um. So you can do all of the stuff that you would normally be able to do with HTML in there so you can, for example, um, set attributes, uh, for your, your elements like here we're sending an ID equal to example for your this header element. Um, It's a little bit different than HTML in a few uh key ways so um if you want to have something that's like a multi-line expression, um, something that you know has uh is on multiple lines in order to write like you would normally write some HTML across multiple lines and make that one. Element, um, then you have to surround it with these brackets here and there can only be one outermost tag for any element that you're assigning to a variable um so in this case we're creating a my list uh variable and we're gonna use define it as. An unordered list, um, HTML tag with three list items inside of it. Um, So All every element can have inside of it things that are evaluated JavaScript, um, so basically what happens is that that whatever goes inside of these curly brackets if that's inside of an element you can um. Essentially write whatever JavaScript code you want to be in here. So in this case we're creating like an expression, um, and that's gonna be an element type and it's just a header tag, but what the internal like the internal HTML of that tag is going to be whatever this this JavaScript, um, evaluates to. So in this case it's 10 times 10, so it will convert that to 100 and then. It will be rendered as if it's like a header 1 tag with the text 100 inside of it, right? So this is not very exciting, but obviously you can imagine you can add in, you know, these are just constant values but you can add in variables and those variables could change, right? So then you start to see how uh in effect this is the kind of the templating, uh, that you see, but, uh, you know, like I was saying with the examples from, uh, yesterday that what's different about React is that here we are, um, you know, kind of. This is all inside of a JSX file and it's sort of you've you've got this JavaScript style notation and then inside of those elements you can then have once nested inside of that you can have more uh JavaScript evaluated code um. So, uh, things like conditionals can be kind of tricky, uh, in the way that they work. Um, so, uh, here's an example. Um, most of these examples are just from the regular the React, uh, website. Can you see that OK? Maybe I can try to turn off these lights here. Um There is that better? Um, OK, so in this case, uh, we're gonna create an unordered list, um. And uh you know it's it's a multi-line statement so we have it around the brackets and you have unordered lists um and then we have a number of list items but this first list item that's just, you know, going to be apple sauce, um, but now what we wanna do is we have these see here these are curly braces so these then become evaluated. JavaScript, um, and so one of the ways that you can kind of do conditionals like a kind of an easy shorthand way. Is to use uh Boolean short circuit evaluation so short circuit evaluation is just the idea that if something, if you say you've got uh a logical statement and it's got a logical and in the middle of it, if the first statement is false, uh, then it will short circuit and it won't continue to evaluate the 2nd, 2nd 1. In this case, um, the what that what that ends up being the way this gets evaluated is that if this, so if there's some variable called baby, um, if, if baby is false, that this evaluates to true and then it will add in this list item, uh, uh, pizza, um. Here we have other kinds of logical conditions so the age is greater than 15 or age is greater than 20 and it will add in uh other um options inside of there um so this is one way to do it it's, it's kind of a shorthand way it's it's not so intuitive I don't think to like look at this and and try to understand what's going on, but after you've seen it a few times you start to just get used to it. Um, but this is, um, one way that you can do conditional statements inside of your, your JSX, um. Another way is that you can use a turnary operator, um, so, uh, in this case we've got an element, uh, headline, um, and it's a header one tag, and inside of it we want to have one of two values for the text and so we're gonna use the turnary operator which is you've seen in some different languages, um, where it has the first expression question mark, um, and then two expressions, uh, separated by a colon. So if the first expression is true, it tells the first item. If it's false, it evaluates to the second expression here, um, so in this case, um, if the age is greater than equal to the drinking age, then the headline will be buy drink, otherwise it will be dote stuff, right. Um So, um, this is a notice all of whenever you have this kind of evaluation you always have to have it inside of the curly braces because otherwise it won't actually evaluate it as as JavaScript, um. So those are two kind of uh key ways um so uh the other thing is that you can uh use kind of these different kinds of functions uh such as like map in order to unpack things like arrays into elements in, in a list, um, so here's an example. Um, Where you have some numbers and the numbers are going to be an array 12345, and so then we want to create, um. Uh, some, uh, expression like list items and we can call the map function on numbers so the map function is, is just a function that you can call on a JavaScript, uh, list and it will sort of apply the function that's passed in each of the elements and then you know map that into a new array of the same size um so in this case it's we're taking a an anonymous lambda function where it. Passes Number as a parameter and the return value is this uh element this list item element and inside of that we evaluate to the number, uh, you know, whatever number values coming in. So basically what we're getting is list item with 1 in it, list item with 2 in it, list item with 3 in it, and so, uh, for all 5 of those then, um, this. Here can be put inside of an evaluated statement between two unordered list tags, um, and so then you would have an unordered list of list items, um. So this is a way to kind of match these things, uh, you know, basically unpack a list of items, uh, into elements that would actually turn into different sort of HTML elements in your page. This expression will generate a warning message, however, uh, that the list items should have a key, so. One of the things um that REA does is it it's tries to um you know in order to kind of be efficient in sort of understanding how different elements change right uh in order to update the view it actually needs to keep track of when it's doing that kind of dirty checking thing it needs to understand. Which element in the list actually uh changed if if an element changed rather than you know the whole uh list um and so the way this works is that um whenever you create a list like this you should really have a key as well um so uh the way that works um is that. Um, if you were to map like this, you actually add an attribute key to the element and give it a unique, um, a unique value for each of the elements, um. Because uh if you don't do this, um, then it won't know, uh, you know, whether a render needs to happen like, um, if some element list has changed or not, um, it, it just basically can will only knows to re-render the entire list of elements or none of the elements it can't kind of individuate between between the different elements. So these are some of the little things like niggly things you have to be aware of if you know because you probably have some kind of construction like this. So imagine you're like creating your website and you're listing your different games you might have them in an array of games and then you want to kind of create some construction, uh, based on that, um, so if you start to see errors like, you know, that they should have a key, well now you know, uh, you can add in a have to add in a key for each of the list elements, um. So, um, basically in that case, uh, it's, um. It's sort of like um. Uh, taking it the value of the number, um, but, uh, perhaps, uh, a slightly better way to think about it is to think of each of the elements of your list as some object where the object it might have some value but it also has or it might have multiple values associated with it or properties but it will also have a unique ID field associated with it so. In this case, um, we have uh something called this is a larger uh function component we'll talk about that but in here you can see that there's something there's an array of cars where each car is itself an object that has an ID and a brand, right? Then down here when we do our map function on the cars, um, we create, uh, in this case we're creating a car. Uh, component, so we're creating another kind of component, not a list item, but something that is that we've defined elsewhere, um, and we pass in the key as the ID and in this case we're passing in the brand as a different parameter in here and then that ends up being used by the other, uh, component. Um, but the bottom line is this way if you separate the ID, have like you, you, you know, it's sort of like standard practice with databases right you wanna have a unique ID and you wanna keep it, you know, have it be, um, separate from all other elements. So the easiest way to do that is to construct your data in a way where you have the ID field as a kind of a separate, uh, property in whatever objects that you're, you're trying to create a list over. Um, OK, that all makes sense, uh. All right. Um, so, Those are just a few niggly things that I think it's just good to be aware of um as you go through the labs obviously you will, you know, um, get more experience kind of working on how you construct your components and and work around with all of that, um, so, um. Now like what's actually going on under the hood though? I mean it's, it's obviously. Well, maybe not obviously, but the, the, the browser itself doesn't doesn't know anything about JSX, right? All it knows about is how to run JavaScript and how to parse HTML and from there. And so what happens uh when you compile your code is it actually takes all this JSX that you've had. And it converts it into actual uh JavaScript code and then that's what that's what actually runs inside the browser um so. Uh, you can, you can see here, here's an, uh, a, a, um, an app component here that app component has a few, um, variables now which is set to the date when the component is created. Uh, A and B which are sent to integer values, um, and then when you create a component, the what gets rendered when you use the component is put in the return, uh, value for the function that you've defined, um, so in this case we're creating a div, um, and it has a couple of paragraph tags and you can see that it has the JavaScript evaluated code. Um, so in this case it says hello world it is and it's going to take whatever is in this variable called the two string method on that, uh. Make you know, get, get the output of that, uh, and, and that's gonna get put in here as a string value oops. Um, same, same with these. So, but actually what runs inside of your browser is something that looks more like what's on the right side of the page, um, so it, you can see that we're still still have like a JavaScript function here. Um, but the important key difference is that this bit here that doesn't look like JavaScript actually gets converted into a call to a function called create element in a and it's basically like a nested uh call where it, it has some, some, uh, parameters, um, in this case it passes div as a string value in there. It has another parameter no well I mean that would. Don't need to worry about that one right now and then it then it has, you know, one or more other elements uh inside of this um. You know, so here it, it doesn't see it call it in in a kind of a nested way it calls react to create element inside of that passes the return value in of that, uh, and same with this here. So it all just becomes it's, it's not like magic it actually is just, uh, you know. JavaScript and then that this create element function is something that the react framework provides you don't have to worry about that that's sort of part of, you know how the framework uh code is is written, um. So That create element if you actually say you open up the console um and you've got your, you know, you open up a page that where you're using um you know you've imported the react library you can actually call that. And take a look here and see uh what the return value is um so create element um it takes 3 parameters there's the type so the type is like kind of corresponds to this type here in the HTML um. It has um a thing called props so props is just properties, but this is sort of a way to pass in sort of um. You know if you have parameters that you wanna send into your component, um, we saw an example of that actually earlier. I'll just go back here like in this case. You have props which is sort of a properties of the car type and you're you're passing you pass, you take the properties of of what looks like the HTML version of the component and that gets put into this object called props and then you can then reference it so you passed in brand here and then you've accessed it through props um. So that gets passed in here uh and then it will have you know children in there as well and so what gets returned is the JavaScript object uh that has you know some different, you know, fields, um, and so on. Oh So You know this can all be kind of nested and in fact it's like when you if you were to have a look at that main root call and the react app is you you're you're when you create that initial like when you hook it into the root element um if you look deep inside of it it's just a bunch of these nested um elements um and you can see here that um. Uh You like in this case you got a div and inside of it the children there's another call to re create element inside of that which creates a paragraph tag um which has, you know, some text inside of it um and so the return value of that becomes like this react. Element type. And inside of it it has children and those children will have one or more of these these more react elements and those in fact will have children as well. And so on and so forth. So the react um render call is just sent one of these nested objects, um, and then it just does, does all its work on on that. Um, so, So it's not magic, it's just, uh, you know, it has to kind of the, the, the JSX is the like some really nice syntactic sugar you could, you could actually write your React application just making a bunch of these react.cre element calls with regular JavaScript and that would be fine, but then it would look really um. It would just be hard to read and not very nice, so what we like to do is use, you know, the HTML style, uh, notation inside of our JSX and then, you know, the compiler converts it all into the JavaScript that it needs to, um. So Uh, So you can define your own components, um, so components, you know, going back to yesterday, you know, those are those like building blocks that you can build your page out of. You think of them as the visual elements of your page, um, although they don't, don't always have to be like visual elements, um, but generally, um, you know, they, you know, because they're returning some HTML type stuff usually that can translates to something visual that you see. On the page, um, so, uh, in, in the labs and for the assignment we use things called function components they're sort of the, the more streamlined and, uh, newer way of doing it, um, but, um. There are also things called class components that are still kind of useful um for a few types of things that you might want to do. So I first wanted to show you how you can define a component as a class rather than as a function. Um, so if you do it as a class, then you, you know, you define it as a JavaScript class like this, um, and then it will extend the react. component type so you're, you're extending an existing object and instead of having a return value for the function component you have inside of it a render method. Uh, that's called and that then returns whatever, you know, HTML is that you want to do. Now when you have it in this kind of construction because it's a class, it also has uh this um element right so this refers to the the instance of the of the class that you're working with um so if you want to to access the properties of the component, uh, then you do that using something like this props and then whatever property you you want you want to get at. Um, Unlike the function components where that's the props is passed in as a parameter, um. So here's two equivalent ones. So here's this shows the fun this is the class component that I was just showing, and this is the function component. So the difference with the function component, um, is that you're defining a function and it has, it has to have a capital, um, like for act it has to have a capital first letter, um, but the properties is passed in as a parameter. And it's just the, the return value for the function itself, um, and then to access like a name property you would just do props.name instead of this.props.name so those two things are, uh, essentially equivalent and as you can see I mean there's a reason why people tend to use function components because it's a lot cleaner and and simpler, um, right, um. So, um, yeah, so this is sort of what you'll see. I mean some of the other examples that I showed previous are also function components even though they showed it as const instead of function a keyword that's just the, the cons uh form of a function that that you can do in JavaScript. That's just the way it is with JavaScript. You could have like multiple different versions of the of the same thing, um, so here I'll just go back to that to show you exactly what I mean so here. This is a function component. This is the equivalent of saying function app with the parentheses, um, all, all that this cons function notation does is it's, it, it, it's basically setting, uh, app equal to this anonymous function that returns this value. So those are it's exactly the same as a function component using that kind of notation. So sometimes you'll see it like this you see it like the other, uh. But it's exactly the same as this kind of notation here. Uh So you could define your own components um and then you can compose components together that's the whole idea is you wanna build kind of like modular application with the different building blocks of the things that you want to to show um so the props is the is the properties and that's it's a read only object um that gets passed into the component, um, so here we have um. An app component, um, and here it's saying they have to start with a capital letter like I said, um, that helps, uh, differentiate them, uh, from HTML tags like div which do not have a capital letter. And in this case we have an app, um, it's just a div and inside of it it has 3 welcome tags essentially, right? But those are welcome components. And so What that does is it uses, uh, this welcome, um, component and the name property gets passed in as into this props object. So then you can refer to it as, it'll be like, hello Sarah, OK, that, that kind of thing. Um, So you know that's that's basically you know composing the different uh components um so uh let's just kind of walk through this to make sure it's all clear about like what what what this is doing, um, so here we have two function components uh that are using the same I'm using this cons kind of notation uh for defining a function. Uh, and in it we have an app component we have a hello component and so like assuming the app is sort of the root of our application, you can ask what does this actually render right? um, so. Here, um, you can see, uh, it's got a name and an age, uh, so those are uh variables, uh, for the app, and inside of it it's returning some diff with three elements in it, um, inside of it's gonna have a header tag, um, and then it's got two of these hello components, uh, one after the other, um. And so those hello components pass into properties, uh, name and age, and these are evaluated, um, in these cases where all the curly braces are they get evaluated based on, you know, either this expression or in this case whatever value happens to be in the variable, um. So like the name of the age, uh, Peter and 10 get passed in for these two. In this case, 36 will get passed in here for, for age. Um, and then what the hello, um. Uh, component does is it creates a div tag with internal of that is a two paragraph tag and it writes hello so and so you are, uh, you know, X number 10 years old, uh, and it's gonna take those values based on whatever got passed in here, um, so. It looks something like this, um. So the data binding comes in um when you start to change the like the values in here become dynamic values and that then re-renders the page um to update uh the values um. Does that make sense to everybody? Yeah, OK. Um, So, um, components in react have a life cycle and they also manage a state so once they are created they're gonna have a state and then that state can be changing and as that state changes because of the data binding it's gonna push into uh the view so the render function that gets it's gonna get re-executed when the model changes um. So, um, In order to make a component stateful that is to make it something that responds to the model changing and updating the view, um, you, uh, need to use something called state so we've already seen props so props is sort of this read only parameters that are passed in, um, and they cannot be modified so once you create it they are kind of constant. Um, but state changes, um, can happen asynchronously, um, so they can be things that are responding to, you know, some maybe it makes a network request and gets a response and it updates and it can be modified in the case of a class component using uh the set state, uh, function, uh, inside of the component. It looks a little different with the function components. Um, but you have to actually call this a, a function to set the state, um, is in order to trigger that it that it needs to render, um. So, um, You know, basically there's sort of a data flow that happens in RA, so you can either pass data in as props, uh, into a component which then, you know, we'll pass on to its children components and on to its other children, um, and then. Or it can kind of create its own state and that gets managed over time so that's like updating and updating. Oh Uh, so Uh, for a class component, um, essentially you can. The state is is is inside of this state, uh, field for the class, um, so, um, you, you, you access it with this dostate and then you can set it to some object in this case it's setting it to an object that has a date field and it sets it it calls new date which is just the JavaScript function to create a new date with the current time. Um, And so um you initialize state inside of the constructor for the class, so you have a constructor and constructor takes props as a as a parameter. Um, and, uh, it's always, uh, important you always have to call the super class, um, that is the react component, uh, uh, constructor first, uh, passing and props, and then you follow by doing whatever you need to do to initialize the state, um. So the state object then that becomes um how we then change the view of our of our component. Um, so. How this works is that every every component has a life cycle so the life cycle has multiple stages, um, and so you can um basically take different actions for a component based on the life cycle. So this gets all exposed very nicely with class components with a function component you have to do something called using effects which we'll talk about, um, but with a with a class component you can directly access the lifecycle functions that get executed at certain points in kind of the the creation and the basically destruction of the component um so for example there is a um. It has life cycles, things like a component did mount component did update, component will mount component will unmount things like that, um, and so these, um. Uh, you, you can basically take actions based on sort of when you want things to happen with relation to to the rendering, uh, that occurs, um, so. In this example what we're seeing is we've got a a clock component, uh, it doesn't actually we don't have the render part, but the whole point here is that we've initialized the state to be some object that has a date field so that gets initialized, uh, at the beginning. Then um what we do is once we know that the component has mounted that is um that the um. The initial, you know, the component has initially been rendered. Uh, once we create a new field called timer ID for our class and we call the set interval, um, on it. So what set interval, uh, is it's sort of like set time out. I've shown that example of set time out with JavaScript before. Well set intervals a similar sort of thing. It's, it's basically uh a call a JavaScript uh function that allows you to. Sort of say I want to like after some X amount of time has occurred I want to execute a function um so the time out the way it works is it just does it once so you set a time out, say for 1000 milliseconds, so 1 2nd and so after a second has happened that whatever function you've passed in will get executed automatically. Um, with set interval it will do it, it will just kind of keep doing it after every interval. So like in this case we're calling set intervals, so it's saying basically every second I wanna call a function, an anonymous function that calls uh this dot tick, so that's this this function right here. Um, so basically what we're saying is once the component has been, has come up and is is starting to has is is ready, you know, and it has been rendered first now we're going to create an interval that's going to call this tick function every second. Um, and so what that tech function does then is it calls the set state method which is uh a method that we get from react component. And it resets the state to the update the date field to whatever date is now now currently is, right? So essentially what we're doing is every second we're updating the date to the new date which is because what date gives you is it's like a it's date, time, all this information so it's a way to kind of have a tick that's gonna update this date field um as every second goes by um. So some important things to see here is that. this.state and if you, if you want to modify the state of your of your application so that it updates the view, you don't actually like in the constructor you just set it equal to this state initially but from then on you actually have to call the set state uh method uh in order for it to trigger a re-render. And what you do is you pass in a new object and this object here is merged with this object here so when you call set state it doesn't actually um replace this entire object with this entire object in this case we only have one field which is date but imagine you had. Like 3 or 4 other fields in there, um, you, it would if you call this.set state and you only passed in date, it would only update the date field and it would leave everything else the same. It's not like it would get rid of those other, other, uh, fields so this gets merged in, um, and then this, uh, here we have another lifecycle function that we get for the component. And this is just sort of cleaning things up so when you call set interval here. I mean, basically you're, you're, you're just calling a JavaScript API function to just trigger something that goes on every second, right? But if for whatever reason this clock component gets take is unmounted, we don't need it anymore. You go to a different view of the page that no longer has the clock component. You don't want that interval to keep continuing, you know, calling tick and not doing anything worthwhile, right? So here, uh, we kind of call the clear interval function which just kind of cleaning up what we set up when we mounted initially so we called set interval here but and we stored its ID inside of a inside of a just a field and then we passed that field back in to clear the interval so it's a way of just kind of cleaning up after ourselves if we've got some process that's running, uh, in the background. Um, so Life cycle is quite important to think about when you're developing um components um but when it comes to a function components they they kind of look very different in terms of how they work but if you're using a class component, you can just there's actually a number of different um uh life cycle methods you can look through the react, uh, documentation if you want to kind of you can get quite uh nuanced in terms of how you how you want your. Your component to behave, um. So, In Um, at the end of this all, if you, if you reference the state inside of your render function here, so here the render function for this whole clock is that it's gonna create a div there's a couple of header tags. It has hello world and then it has another header tagger that says it is and then what it does is it takes the date field out of the state and it calls this two locale time string method which just converts it to the local time zone, um. And so it converts it into a string, um. It, um, you should not, uh, so, so basically what happens is that with the data binding is because you called set state here and you update it with the tick whenever the state essentially gets invalidated it's it's no longer up to date, um, the component knows it's gonna kind of put it into the pipeline that it needs to recall the render function again. Um, and so then it's gonna, you know, re, rerun this, and it's going to change essentially the state of, of the, uh, of the, uh, document object model to represent the view to be like how you, how you want it to be, but of course it's actually doing it with the virtual DM and then there's a whole another level of management that's going on behind the scenes to actually map that into the actual document object model for the. Uh, for the, the browser, um, but so essentially this render function gets triggered this way. Um, now I say here you should never update the state inside of this function. So in other words you shouldn't call this set state inside of here. Any guesses about why that might be just out of curiosity. Why, why would you not want to call it in there? Any thoughts? Yeah. Yeah, exactly, it causes an infinite loop, right, because that when you call this doset state, um, here, that's the notification to react that it has to recall render. So if you do it inside of the render function, you're calling renders, calling the render function over and over again, so yeah. Um, so if you find, have some weird behavior, check for things like that going on. Um, Uh, so, Uh, this is kind of, you know, doing this based on intervals, so the next, um, question is about how to, how are things, uh, done. Uh, by Uh, user actions and I think um that is, um, I think what I'll do is I'll, I'll go start with that, um, for next time because. Um, that's kind of a whole, whole new piece of it, right, because what you wanna do is you want to have things happen like for example inside of this this kind of curly brace things you want, um, for example buttons on, on when things like a click event happens you want it to execute some uh method that you've defined uh for your uh for your component. Um, So, um, I think I'll just stop there because that's a whole new section, uh, to move in and we're almost out of time, um, and you'll get lots of experience working with all of these things in the labs obviously so any questions before I wrap up? No, OK, um, so, uh, yep, just uh let me know where the tutors if you have any questions as you get into this, into the labs, um, and, um, like I said, I'll, I'll follow up uh for those of you who have questions about your assignment one grade. I'll, I'll get to that by the end of the week. All right, thanks everyone.

SPEAKER 0
You has been more on. a couple of hours. like a head dryer to the back. Right And That He gave one last step. Oh my God, it's still cool. What you should do what you gotta do is just suck it up and hear it because then you. Do I look like someone that produces for? Yeah I feel like that's a you gotta change it. Yeah I I want some nice. I'll just force you. It'll be like That's a new. this No, I haven't started, but apparently this is on the toilet now I know what has transpired over they had to put aside. Uh. you Yeah. Well, No Um, I just wanted to ask, um, in

SPEAKER 2
terms of like exam revision, find an exam where to find potential like resources or materials.

SPEAKER 0
But also I, I update the statements quite a lot each time.

SPEAKER 1
I don't usually recommend people study prior exams. I prefer, I mean, it's essentially based on the material that's covered in the lectures, so working for the lecture you know the lecture slides, but you understand that it's

SPEAKER 0
probably the best preparation rather than there are a few things. I have, but I also I'm a little bit of study and they think that's exactly what I have, yeah,

SPEAKER 2
but I mean like with the past exam papers they're like, are they still kind of like the same or like similar content, yeah, I mean it's right so but

SPEAKER 1
I mean I don't actually have them.

SPEAKER 0
I'd have to. Uh Yes. I Yes. Yeah, so I'll I'll OK.

SPEAKER 2
Yeah, cool, thank you.

SPEAKER 0
No Yeah you feel like just the. I Yes. No Yeah Yeah. Uh, the like. the Honestly, so. Yes. I just Mhm Right. Yeah Yeah, I know, I like.


SPEAKER 0
Yeah, I was like. No. Yeah. Because I can. Yeah. I Yeah. I I. I that's. OK, well. Not How. I No. Oh.

SPEAKER 1
All right, uh, welcome everybody. Uh, so I have responded to many different people about assignment one, so for, you know, if you had questions about that. Uh, about your grade or anything like that. So I, I think I've responded to most people, um, but if, uh, you still have questions, uh, please. You know, come talk to me or I, you know, send me an email, um. And hopefully things are going OK, um, I think, um, that, uh. You fixed a bug, another bug in the. Uh, reference implementation for something that we didn't have a test for previously, um, so, um, you might want to just, uh, check, you know, and, and do a get pull on, um. On the assignment, uh, repo, like the assignment one repo, the reference limitation if you, uh, you know, just to, to fix it. It was just like a little minor issue certain condition that, uh, threw a 500 error accidentally. Um, Apart from that, I think that's it for in terms of updates on that. Um, any questions about any of that, about the labs, about the assignment, uh, anything so far? Yeah.

SPEAKER 2
In the game You be able to delete the game that's the wish listed? Because currently like this reference in both tables the reference implementation. Uh, I Actually, that's a good question.

SPEAKER 1
I, I need to check, um, let me check over the back and get back to you about that. That's a good question. Yeah. Uh, No, not directly, no, um, I mean. You know, it's, it's more on the, the whether it matches the, the user stories of as well as a little bit of the presentation. Um, but yeah, I mean, it's um. Primarily on, on, you know, matching those user stories and how well you know people can essentially replicate a particular user story with your code, um, there's a smallish percentage of the grade that's just sort of meant to capture sort of your general effort on the design and the development of it but we're not going to be, you know, looking at. Code quality and from the perspective, like, you know, comments and all of that sort of stuff as well. Good question, anything else? No, um, oh, I guess what I could do is actually, um, give a little bit of feedback. I mean, I, you know, obviously many people's, um, tests worked fine for assignment one, but we had a few, there were a few common errors, and, and it's probably worthwhile mentioning them, um, I mean, first of all, the most common thing was just when people would. Didn't, um, kind of cover all the possible situations where an exception could be thrown. um, so for example, um, if, uh, they made a call to like the back end, like the model, um, code, and that made a, maybe just a request from the database and maybe there was some condition that wasn't fully tested, um, in, you know, in the tests that we gave, but for whatever reason caused the database query to fail in the way that it was constructed. Um, in those cases, um, when we're running the tests, um, it would actually crash the server because, you know, it would happen, you know, for whatever reason it wasn't included inside of a trib block, um, and if it's not in a trib block, it just pushes out and throws an exception and then the server's crashed and it's not running anymore. So one thing is to always make sure that you always, you know, use the tri-catch blocks to really capture everything, um. And, uh, another point that came up a few times was also around calling, um, not, not always remembering to use kind of that the await. Um, keyword when calling, uh, a function that returns a promise. So if you're making an AI function, you know, occasionally there'd be cases like that, um, and it didn't always show up in the testing and what was interesting about it was it really only showed up in cases, um, a similar sort of thing where an exception was thrown, and what would happen is maybe you make a call to a function and that would indeed be inside a tri block so you would think if there is an exception it's gonna catch it. Uh, and that's all great, but because it's actually an async function, um, what happens is that. You, you make your, if you don't put the await keyword in front, then you make the call to the function and then it's pending and it's probably making a database request and then at some point it gets fulfilled, but once it gets fulfilled, it's all the, the rest of the program has already gotten come, it's come outside of that triblock. Um, so by the time the exception is actually thrown, you know, the program is no longer inside of the trib block. So that's kind of a weird thing you wouldn't necessarily think of. It's like a combination of, of different things happening, um. So when it comes to the async of weight stuff, uh, you know, there's sometimes cases that are a bit odd and and you gotta keep an eye out for that. Um, I think those were. The primary things, um, that I came across. All right, um, so. Last week, uh, we talked a bit about React, um, you know, I introduced some concepts and I'm gonna continue talking about React this week, um, and you know this is really to sort of expand upon what you're already learning in the labs and that and so this week in particular I want to talk about event handling. I mean you are doing some event handling already in the labs, uh, but I wanna talk about it sort of in the context also of class components, um. And then I'm gonna talk about hooks, uh, and, um, how they work a little bit more like why, I mean we use them. You know, in the labs, but we don't fully explain like what's happening and why they work, um, and then. I'm gonna talk about global state, um, which we also we use uh a simple way of managing the, the global state of the application, um, but there are other ways so I wanna introduce this to you, um, and then also not here on the title slide is also talk a little bit about testing and, you know, approaches to that, yeah, so like in particular how you how you go about debugging a react application, um, because there's some tools you can use for that kind of thing. Um, so I think I could talk about everything. Oh yeah, and, and also about a bit about routing as well. Um, all right, so event handling and hooks. So REACT is a one day one way data binding, um, framework. So if you write your code and you have some state, um. In your component and that that state is changing, it's updating um then that should re trigger like a render right like it should actually redraw the um the user interface but of course there's the other way around too where the the user interface itself you want to be interacting with that and then maybe that should also then go around and update the state right? and so uh that's what we're gonna talk about first um so. Uh, so first off, I'm gonna talk about event handling from the perspective of class components. So if you recall from last week. We have two different kinds of components. There's class components and there's function components, so you're using function components primarily in the assignment, but class components actually allow you to do a few more things and so they're still useful to learn um for certain circumstances and sometimes you might come across class components um in the code that you you're looking at, um, and so, uh, the first part of this I'm gonna talk about some things to keep in mind like how you actually. Handle events that are going on uh with class components because the class components essentially it's a JavaScript class right? so it's a it's a class that has its own this um member so that would be like you know the the thing that like in our methods we use to refer to the various properties of of the class, right? Um, and so we have to, we have to look at that and how that, how that's handled with, with events because we want to be able to essentially invoke, uh, things. You know, different methods and things on our class when an event happens. So, so when we do event handling in the component, um. Whether it's a function component or a a class component really it it's it's kind of in react they they make it look similar to when we wanna treat respond to an event with the document object model and just regular JavaScript events. So if you just write JavaScript and you want to manipulate, um, you know, if you want, for example, you have an element like maybe a button tag or something like that you can have it, um. Uh, respond to what we call DOM events, so like a click event or a submit event, um, and so, um, it's quite similar in React. I mean they use the same kind of terminology, uh, but they, uh, use slightly different notations. So like if you wanna click on something, the events called on click, but it's in, it's in camel case notation, uh, you know, where you, um. The first word is lower case and then every subsequent word is is capitalized all in one as opposed to like being, you know, lower case or something like that, um. And so, uh, essentially, uh, you pass in some kind of function that's going to be the event handler so whatever your your element is, um, so you've got all these different elements in your, in your HTML you've got buttons you've got divs, you've got. Uh, whatever, you know, like all of these different things you can define event handlers for, and for each one of those you essentially want to define a function, um, that's doing that. And then when, when you execute that function, the component, it's going to modify. The state in some way or another, um, so the function can be a method inside of a component class but cannot be called unless this is explicitly bound so that value doesn't mean anything to you because I need to explain what binding functions is and so we need to step back a little bit, um, and I just need to, to talk through that. So we we've got roll back to our, our earlier JavaScript, um. Uh, JavaScript lectures, um, and so, uh, if, if you recall, um, when you. You know you can create things like objects and then you can assign other other variable names to those objects um and sometimes when that happens um this the um meaning the reference to the object itself can kind of be lost right? um so. Show you an example of this. So imagine we have a an object here called module. Module has, uh, two properties. It has X, which is just a a value. It's the number 42, and then it has another essentially a method property which is a function. It's a function element if you recall back to what we were talking about JavaS earlier. And so essentially get what get X is is it's, you know, you could think of it as like an access or or you know kind of uh method that's going to to just return the value of this whatever this object is there that's X value, right? So what it should do, you would presumably if you have an object like if you were to call get X on module, it should return 42, right? That should be obvious, right? Um, so if you do that, um, on module, that would be fine, but, uh, recall you can. Essentially make references to uh other functions you could take a variable and make it equal to sort of a one of the function elements and in this case it's it's this get X function that sits inside of, of module. Um, so if you were to do this, um, where you say I want to create unbound get X. You're essentially creating a new function object, um, and it's, it's assigned the value of this of this function, right? This anonymous function. Um, but if you were to call unbound get X. Um, because I'm about X is not actually part of module anymore. Um, the way that JavaScript deals with this is it just kind of, um, it, well, it depends on sort of where, what kind of JavaScript engine you're running in. If you're doing it in OJS, it will, it will make it part of the global scope. If you do it inside of a browser, it will be the window scope. So it sort of depending on the engine, it will just decide basically a different. This reference is something else than what we thought. It's no longer this module object anymore. Um, so if you call that, you would expect the output to be undefined because the global object doesn't have an X value, um, so it doesn't work, right? So there's a way around that, um, and that's using this, uh, function called bind. So if you take an object and you call bind on it, you can kind of essentially grab the this from that object and, and, and grab it as your own. Um, and so what that means is that now bound to get X is another function, but if you call it, it's actually will have the output of 42 because when it call when it when you execute, you know, bound and get X, it goes into return this.x and this.x now refers to. I mean the, the modules, uh, X, um, so that kind of binding, um, it's just like weird it's, it's kind of esoteric JavaScript stuff right that you're looking at but this becomes into this becomes important in our class components because what we're going to be doing is trying to, um, we, we, we have to use this bind uh method when we want to create our event handlers, um, so what's that look like, um. So something like this, OK, so. Let's just look at this, uh, class component here. So, this is a, uh, A class component it's, it's, it's usually easiest to start with the, the render part, you know, to try to work your way back and what, what is this component actually look like and what it, how does it behave. So it looks like. This toggle, uh, component, all it is is it's really like a button component, um, but it's a button component that has a an on click event handler, so that means if we, if the, if we click on it, it's going to do something, um, and then inside of it inside of a button tag, it's gonna have some just some HTML that is sort of um some value like a string, uh, that's the label of the button. So essentially what this is saying is if, if the, the state of my component, um, if the is toggle on, uh, state variable, if that's true, it's gonna have all like the text is gonna be on for the button, otherwise it's gonna write off on the button, um, and. As you can see, um, on click we're giving it a value, um, and recall like the curly braces is like some kind of, um, you know, it if you want to sort of, uh, have it evaluate some JavaScript, you put it in the curly braces, um, and so in there you're passing in a function this dot handle click. So what this means is that we have, um, if you look up here into our full full component, we have a constructor. And we have a function handle click so the construct inside of the constructor, um, we just initialize the state of our of our object, um, and then something else that we do is we bind we we basically create a uh handle click and we we bind it to this function here. Um, and so when then the, the hand what the handle click, uh, function does is it calls this not set state, um, and what, um, what set state does is, you know, if you recall it, it kind of, it will override the state variable and it will also then when it changes it will trigger a render like a re-render, right? um, and. It's a form of set state that takes a parameter, that's called, uh, that's the previous state. So if, if you, if you just set this uh set state, then you could just pass in this object, um, and set is toggle on to some value. But because we want to know what the previous state is, uh, upon before we set the new state because we want to essentially do like a Boolean knot operation on it, we, we have to pass in the previous state as a, as a parameter. So we get the previous states isagalon. So it's taking whatever istagon is currently set to, and it sets sets the new states is tag along to that, to not that, right? Um, So, so all this is doing is flipping that boolean value, um, and that's gonna flip the state. And so if you were to click the button every time you click the button, it's just gonna change the label from on, off, on, off, on off, right? Um. But the important point is that if you want to access some kind of component method for your event, um, you know, this is one option. You define it as kind of a, a method inside of your class. Um, and then, but then you have to bind it and, and, and reference it with this here because if you just put handle click here, the problem with that is that it's not first it doesn't tie to the to the uh to the class, um, object, right? All it's doing is, um, it's it basically it's looking for some kind of global handle click, uh, function or something like that. So you have to. You have to use this here, but, um, but the problem is that the way that react works um it's it it it's something similar to this kind of operation when it creates when it actually creates the instance of your component so when that happens, it loses the connection. Uh, and so that's why you have to explicitly do something like this, right? So that's one option. You have some sort of construction like this, and this will kind of wire together your click, uh, function, uh, and it, and, and then you can actually make it so you see here it's actually passing in the function, it's not executing the function. So what this is saying is when an on click event happens this is the function uh that that needs to be executed but it doesn't get executed during the render like if you were to put the if you put if you put the braces here at the end, um, then it would actually execute it every time it was rendered so it would actually be changing the state. Um, Does that make sense? OK. Um, so that's one way of doing it, um, but, uh, There's actually a much easier way to do it. So, so I went through all that rigor and morale of saying you have to bind to this and so on and so forth, um. So in here, notice we say handle click and so this is a, this is a, a function like a method in our class, right? Um, But What changes here is that instead of being just uh a definition of a function. Instead, make handle click equal to an anonymous error function. Um, and if you do this. Uh, because, uh, because arrow functions are treated differently in the way they handle this. I don't know if you recall, but way back when I talked about that in the first semester, um, that like that when you use an arrow function this does not refer to, uh. Does not refer to the um. The anonymous, uh, function, but it refers to the outside, uh, class itself. um, but anyhow, so, so if you do this, um. You got a much nicer thing you don't have to do the binding and it's all good, um. And so this is probably the way you wanna go, um, for whatever reason it's sort of been treated as experimental syntax for a long time, but everyone I, but I mean uh it's used all the time so it's probably fine to just, uh, use it. So the key difference is that. Instead of defining handle click with. You know, round braces and not as an arrow function, you can get, get rid of all that, that stuff, right? Um. And uh. The third way to do it is to sort of push the arrow function down into the on click. Call back. So the difference here is that this is sort of like the original construction where you where it's just handle click is a function it's like a method inside of your class, but what gets, but what gets passed into on click is actually a newly constructed anonymous function that's kind of like a wrapper function around around this and then it actually. Uh, notice the difference here is that you do have the curly braces because this is, this is the body of the anonymous function. So when this anonymous function is executed, it will call this do handle click and and execute it. So, so actually I see this kind of um construction most often, um, but it isn't actually as a performance like if you care about them I mean you probably don't notice in most applications right there's probably no difference uh but you know if you're really worried about like optimizing for performance, this is not as performance because what this is doing is every time render is called it has to create this new function. Uh, whereas, whereas in this construction, the function is created once when the class is created and then you just have a reference, uh, to it, uh, that you're that you're passing it, um, but these are, you know, just little things but you know these little niggly things can get kind of a become kind of a pain if you're like working and trying to figure out, you know why things aren't working so just be aware that like. You know, the, the event, you know, the, the function that's been triggered by the event, you wanna make sure that it is in fact being triggered like correctly, um. And you know you could just use one of these, these formats. I mean this is obviously a lot more. Probably more than you need to for most, but use one of these like option 2 or 3, works fine. Um. Now with functions components I mean you can just uh because they're functions and they're not classes they don't have uh this element you're not actually working with that you're just working with um kind of uh sub functions inside of the larger function so it's a bit it's just a bit cleaner all around, um. So, so right, so, so that's what with class components if you want to do that kind of stuff. So, but then there's function components, um, and so when you're using it dealing with state, um, I mean, first of all, function components have been around. Uh, for a very, very long time within React, um, but they were always previously just stateless, um, components, so they were basically just sort of like you want a hard code or you wanna kind of have one kind of simple like construction of a component like maybe it's like a label or something like that you would just do it as a function component. But what what changed was the introduction of hooks and that with hooks it allowed you to essentially use function components to act like class components um so nowadays most of what you could do with class. Components could be done with function components and then the syntax is much lighter and easier to read. So it's probably as you've seen in in the labs. What you can't do is some of the kind of, uh, things that I'll talk about a little probably won't talk about it until tomorrow. Um, but there you can if you want use because classes can be extended you can actually build kind of like, um, abstracted components, um, and, and build up, you know, so, so you might want to or or extend a component with a, you know, make another component that extends off another component, things like that. So if you wanna do that kind of thing there's that's still quite a useful reason to use class components because you can't do that with a function, right? You can't inherit like you can't have a function that inherits another function or something like that, um, but for many other things, um, function components are more, you know, because now we have hooks you can actually do a lot of the stuff, uh, that you could previously only do with class components. So, so what are hooks? So. So hooks are these, well, I mean we kind of see hooks initially um with how we handle state in a function component so um here's a function component here and in this function component, um, it's just rendering a div tag inside of it it's got a paragraph, uh, that says you clicked whatever number of times and then it has a button and when you. Uh, click on the button, it, it should, um, essentially it's gonna be incrementing the count, right? So it's just a very simple counter thing. So, previously, you know, when we, when we were working with state in the, in the class component, you would take. You would take the um. You you basically set the state right and you would, you would set certain kind of fields by sending sending an object, right? um if uh. In, in, in with a function component if you want to modify the state then you would use a hook such as use state so hooks all have this format of like a lower case use and then some word uh so use state is one type of hook, um, and essentially, uh, what it does is it takes in. A uh parameter, um, so when you say you state that the first parameter is going to be the initial value of it and what it does is it returns a a kind of a tuple like a, you know, a two element array where the first element is the is uh a value, um, and the second, uh, is a function that updates the value. Um, so these, this is, this is the actual value and its type is gonna be the same as whatever you, whatever you set it at and set and set count this function is going to be, this is actually a function that will update, update the state um so once you do this, you can see it's quite simple. You just, you just declare it as like the first part of your function, the very first line of your function. You don't have a constructor or anything like that with the with the class component and in this case, um, you know, you can then now reference count and and use set count to update uh the value, um, so here I mean count it initialized to zero, so when you first kind of render this component, it's gonna say you click 0 times. And then here we're we're using this this is kind of the 3rd, uh, 3rd option of how we kind of handle events we pass in an anonymous function that's defined inside of this um return block and what that's going to do is it's gonna call set count, um, and it's just going to pass in whatever the current count is plus one, right? So all it's doing is incrementing the count. Um, So Uh, we have to use this arrow function notation here. Like you, you wouldn't want to put set count in here, um, because if you put set count in here, you will get yourself into an endless, uh, loop. So that's an important uh difference that you actually have to use this um this arrow notation because basically what you're saying is you're passing in a function rather than executing a function uh uh when you click so that's a that's a key distinction um so so this is basically how it works and so you state is a type of hook um. Uh, So if you don't want to use an arrow function like say maybe you wanna pull it out like you don't want, maybe you want kind of your render part to be kind of more streamlined, uh, then what you do is you just create sort of your your different, um, uh, functions that modify the state. And you just define them as cons like some and give it a name up and then set that equal to the anonymous function. So here you're basically saying increase by 1 is being set to uh an anonymous function that calls set counter and increments it and set to zero is this. And then all you do is on clicks you just pass in the name of the variable that's referencing the function of. So this is a bit cleaner, um, so but you know it's partly kind of your preference in terms of, you know, whether you what kind of style you like to to use, um, and so here also just uh you know this this is also just I mean we've seen this a number of times before but like functions are, uh, you know, depending on sort of. I'm not sure. Like, it just seems to be sort of developer preference, but, um, you know, oftentimes, um, developers nowadays will define functions this way where instead of defining with the function keyword, they'll call like they'll use cons and set that equal to some kind of anonymous, uh, function, um. Uh, so this is equivalent to saying function app and then having that, that, uh, content in there. Um, so, um. So just like we, I, I showed an example where you have access to the previous value, you can do that also. With set state so. In here, um, this set count function actually, um, if you. Uh, you can either, you know, pass in. Uh, a value or you can pass in a function if you pass in a function, it's going to be a function, uh, that takes as a parameter the previous state value, um, and then you can do what you want, uh, with it, um, so in this case, uh, like here, um. All of this is doing, so this is like a, uh, a div that has, you know, whatever it shows the count as a reset button, a minus button, and a plus button. So minus should decrement the count, uh, plus should increment the count and reset should set it back to zero. So you might, you know, you, you in this case we're passing in the initial count as a as a parameter, um, in the props. So here we're just gonna set when we create it we have an initial count um and uh so if we click on reset it's just gonna set the count and you're here we're just passing in the value so that's just the number it's gonna reset it to whatever initial count used to be, um, but, uh, if. We click on the the minus button, uh, then instead what it's gonna do is it's gonna, uh, call this anonymous it's, it's gonna set the count to the result of this anonymous function where it takes the previous value, um. And uh returns whatever that previous count was minus 1 and then here's the previous value and the previous count plus one so what's happening here is that set count um will depending on what kind of, you know, input it gets, it's, it will kind of handle it in different ways, right? So here it actually sets it to the value that you've provided here it sets it to the return value of the anonymous function that you pass it, right. Um, so that makes sense with by following that, OK. Um, OK, so, uh, so that that's how you access previous state, uh, that's fine, and then you can use state to, um, kind of use all kind, you know, do all kinds of different things. So a few things, um, so key distinction from, from in class components. So if you recall when I talked about setting a state in the class component. What happens is you you pass in an object but it only replaces the fields that you actually pass in so you're essentially kind of setting fields with an object, uh, that makes sense if you don't include certain fields, those fields remain the same in the state so the state is just one big object, right? With new state it's different. This is actually literally overriding the value for whatever state value you're you're working with so there's not like one big state object, but instead you've just got different variables. The state variables and each one of those is set kind of individually um so it's just a little distinction in terms of how they work so it doesn't merge the value like it does uh when you use this not set state in the class components, um. All right, how many do we have time? OK. So, um, so, so you skate is a is a hook, but actually there's lots of different hooks and you can define your own hooks. So hooks are just things that you can essentially um. Sort of, uh, you know, they're functions that you can can hook into your function, um, component, uh, and they will do they basically allow you to modify state and do do things like that, um, so one of the, I mean kind of most basic types of hooks is is something called a use reducer. So, uh, in fact, um, use state is just a special case of a use reducer. Um, so the, the use, uh, reducer. Uh, basically, um, what you do is you pass in. Some kind of reducer that takes a state as well as an action, so it takes two parameters and then it returns a new state, um, so before we set with you state you pass in the state and the action that's taken is that it just replaces the value, right? But you can actually customize and define what the action actually does um so when you, when you do this, um. It returns a state and then something called a dispatch method um that can be used to trigger um different kinds of actions entirely um and so you can use this to maintain like the state of complex objects and things like that so let's kind of look at, look at this an example it's probably easier to kind of talk it through with an example. Um, so this is a counter component. It's similar to the component before that was incrementing and decrementing. So in this case, it does. It's like a minus and a plus button and depending on when you click it it's either going to call one function or it's gonna call a different function, uh, but, um, it's not calling set stay what it does is we, we are creating, uh, we're we're calling use reducer and we pass in it. Reducer, which is a function that we have defined the pat that takes two different two different uh uh parameters, so it takes a state parameter and it takes an action parameter, um, and then it also has uh an initial uh state parameter and then based on that it will return. Two other, uh, two values. One is the state, um. You know, a state object, uh, and the other is a function called dispatch, uh, that we can, we can call. So what happens is when we call dispatch then. It will basically take the action that's passed in. Uh, and, uh, call the reducer on it, right? So let's take a look at the producer. So the producer has a state and it has an action. So, uh, the basically what this is saying is that. Action is gonna be an object of some kind that's gonna have a type field. And that type field is going to be a string, and that string can either be increment or it can be decrement. Otherwise, if the action type is something else entirely, we just throw an error because it's undefined. Um. Now if somebody passes in an action object, um, and the type field is increment, then what we want to return is an object that has account field uh and it's gonna take the current state. Take the count field for the current state and increment it and then return that so it's basically returning a new state object uh based on sort of the previous state. Object so we're not we're not dealing with like individual kind of elements of the state but we're not dealing with like this kind of a state object and we are kind of referencing the elements of the state and setting the new values for the state um so you can increment and then decrement is the same except it subtracts by one. So if you, if you define this as the reducer, then what you can do is you have state so state is an object now um it's not like uh you don't have a count we're not we're not using count as a value, but we're gonna have count inside of the state um and so uh we access that here where we say the count is whatever the count is for our current state. Um, and then when we want to take, when we want to click on it and, you know, handle the event, we execute the dispatch method. That the producer has created, and we pass in an action object where the action object is a, you know, it matches this action object here. It has a type field and it's a string. So what this means is when we click on the minus button we call dispatch it's gonna take this it's gonna pass in this object as the action, um, and it then it's and then what happens is react is gonna call the reducer it's gonna pass in the action that you've passed in along with the, the, um, uh, the current state. And it's gonna part, it's gonna look at it. It's gonna say the action type is decrement, so it's gonna go here and then it's going to return a new object, uh, that has a count field equal to whatever the current count is, uh, minus 1. So this is kind of the same thing as you state with the counter, but it's more complicated because you have much finer grain control over what's happening here. So here we are just simply updating values, but if you want, you could make a you could do anything you want you can put any kind of code in there you could, you know, make, uh, network requests you could do all kinds of stuff, right? So your, your reducer is um. And basically you can deal with much more complex state changes or maybe you need to combine values together maybe your action itself can be complex, have multiple variables in it, and so on and so forth, right? So, so you, but you know you state all it is is it's just uh a version of this but that's like simplified up. And I, I, I guess finally the one last thing is that you have to, the initial state of course is this that you've defined it as like, uh, you know, an object with the count of zero, you know, if, if for example you came in here and said the state.count plus 1, I mean if if counts undefined, I guess well JavaScript will try to turn that into a 1 or something because we'll probably treat the undefined like zero or something, uh, but. You know, normally, the you need to set the initial state on all of the different for whatever fields in the state you're gonna access inside of your producer. Um, it's a little bit complex to kind of work your head around how the pieces work together, but you know, once you do that, you can really create some really interesting kind of, um. Ah, interesting things, um, so. So if you, you can actually look in the back source code and in fact see that you state is, is in fact just it is using a user reducer. I mean, it's actually built off that um in the code base, um. So, um, We have about 4 minutes left, so just end with this, um. So So there's you state is reducer, um, if in with a class component, it's very easy to kind of know what where you are in the life cycle of your component. So they have these sort of life cycle, um, methods that are passed down from the react component object. With a function component you don't have access to those, um, so instead what we use are effects and so basically the word effect comes from side effects um so it's basically. When it by side effect it means that like after the render has happened then it should do something and then so so basically it guarantees um so so after it's it's rendered it will do something that might also then trigger another re-render uh to happen so it works similarly to the life cycle methods in the class component, um, but. You know it's a bit different. So like if the class component you could say you could call component did mount or I mean sorry you could override component did mount or component did update and do something to your your state that way with use of effect what you do is you just pass in a function, uh, and you do something here, um, uh, so, so basically this so the important thing is remember it happens after. The render, so you in this case we're creating account, uh, it's a similar sort of thing where you click on a button, you set the count and it will increment the count, but every time the render happens, it's gonna then go and change the title, the document title, so that's all that is is sort of like, you know, the title bar in your browser, right? It's gonna update it to you clicked count times um. So it doesn't, uh, you know, once the render uh has finished. So that's essentially how use effects work. Um, there's a little bit more I wanna talk about, I guess I'll just pick it up next time, uh, because if I go on more slides, it's gonna go over the time, um, but we'll, we'll talk up like tomorrow we'll talk a little bit about how all of these things fit into sort of the underlying like how the processing of REA works, um, those things kind of the. The how the virtual dom works and and all these pieces kind of fit together, not, not too deep, but just to, just to kind of give you a sense about how these things tie together and then we'll talk about state management after that like more like global state that kind of thing. All right, uh, any questions about what I covered today? No, OK. Um, yep, and I, uh, I guess, 011 quick thing is that I also, um, I mean I've gotten the feedback from a few different people that you like more information about the exam. I will provide more information for you about that, um, in, you know, coming lectures. All right, thank you.

SPEAKER 0
Yeah OK, I have a quick question. Uh, assignment to hand down, uh, it says like we

SPEAKER 3
should get. I'm wondering if that's a requirement or if it's just like a suggestion, uh, what's the recommendation you don't have to turn it in that way so we don't need like a, that's fine, yeah, um, and then also I know I did say that like we're allowed to use marks, but I'm wondering. How far we can take this like, for example, we're allowed to use, uh, bit or bite, uh, instead of

SPEAKER 1
reaction, yeah, yeah, uh, maybe even something like, uh, yeah, I mean, I guess the important thing, um, hold on, let me actually think about that. So, so the important thing is when people need to test it they need to be able. To very easily just spin it up, you know, so they'll follow some steps. So normally we would just give them the normal, uh,

SPEAKER 3
thank you, uh, what do you mean by that? Do you mean like it or yeah, just make sure

SPEAKER 1
that they can build it easily, yeah, so that, so

SPEAKER 3
we're building it in the, in the, yeah, so basically

SPEAKER 1
what's gonna happen is that we will, I'm gonna anonymize, uh, you know, basically I'll probably take all the code, um. And put them in the Dropbox folder or something like that without without people's identifying information and then and then people will be assigned, you know, do 3 of them and so they, they basically just take the code and they have to be able to build it and run it on their local machine like in the labs, the labs, yeah, in the labs. So as long as you have very clear instructions on how it, you know, to get it running in the lab and, and it will, it will kind of assume that the, uh, you know, that the server is running on local hosts as well like the API server.

SPEAKER 3
Uh, so then if, if, if, if we use some like like, could I, uh, basically just do like a

SPEAKER 4
run that without full building it, or would that count since it's all a local host, or would we have to like build it?

SPEAKER 1
Uh, yeah, no, I mean, as long as it's all just runs on the local host, it's fine. I mean, so the point is it just, um. You know, they will, there's gonna be instructions like he's gonna set up the API server and then once that's running, you're gonna go and you're gonna just take the code and and follow the instructions to load up basically load up the web page and try it out.

SPEAKER 3
So as long as it builds and works and works

SPEAKER 1
and that's the only so we can use something like, yeah, yeah, totally, yeah, yeah, yeah, absolutely if you, if you want to go for it, go for it, yeah.

SPEAKER 0
Uh, so I.

SPEAKER 1
Oh right, OK, um, let me, not sure. It's possible there was uh something that happened with the testing and the, so let me just uh. Uh I guess what would be easiest is if you give me your user ID and then I can just look it up that way because then I can just run through the test to see what's going yeah, yeah, totally. You know what, actually, sir, if you don't mind just send me an email with your user ID because then I'll have it in the email. That's probably the the best way for you and then I'll, I'll run through the test and check and see what it is and I'll show you the test yeah.

SPEAKER 0
In that last example you state, um, no, not used it once. Does it have to have to spend at that moment of time and with that with that. doesn't catch it. Like Yeah directions. Yeah. OK Yeah. like So yeah Council Yeah it's a function to um. example. Yeah. I. Yeah I. OK. I. I.


SPEAKER 0
Yeah. You like. Well, I don't know. No. No. He's not thinking about that. Why was originally like as opposed to one of yours. Yeah. You And so I think it's like. So My No, but. That And it just does not go back. Yeah. Sure Hey, everybody, it looks like somebody walked off with

SPEAKER 1
the mic, so I just have this mic, but hopefully you can hear me OK, I'll just have to stand very still. Um, Alright, uh, cool, so. I just got an email from Locky. Um, there's a typo, I think, in lab 5, for using zoo stands, so I'll update the lab. Uh, with that, but hopefully, your tutors help you out with that. If you have questions about that. It's just the, the import statement, um, for zoo stand needs to be updated, um, so I'll get to that later today. Um, So, yeah, but I mean, if you have questions in the lab, just ask, just ask the tutors. Are there any other questions about segment 2? Or the labs. Oh, right, there was the question about the. Um, I, uh, if I can characterize it correctly, let me just look it up. Uh The, um, right, so. So, apart from the one thing with uh with Zoosta, um, there was a question about whether a game can be deleted. Um, if it's wish listed or owned, um, and so the way that the. API server that you're using is implemented so that it will not allow it to be deleted. Uh, so we'll just keep the API server the same, and just make sure that the user stories match that. Um, I mean, in a way, like, you know, we wouldn't test. That you try to delete something that has been wish liststed when we test it, um, because the API wouldn't even let you do that anyways, um, but, well, I'll just make sure it's consistent. So I'll do, I'll set an update on the user stories to make sure it's clear. Um, I think that was it. Any other questions from anybody on that? No, OK. Um, Excuse me, um. Just pull the slides. All right, uh, so, uh, I was talking about react and, and talking about some different, uh, aspects of it. So when we finished, we were talking about how we, uh, basically there's, there's different forms of hooks that we can use. We talked about use state we talked about use reducer as being really kind of like the. The basic version of that and that you state is is it's just an implementation of of the um. Uh, reducer But then we were starting to talk about using effects and so a use effect, uh, hook is a way to do something after a render has happened. So if it was a class component, you could just override one of those methods, you know, um, I forget the exact name, but you know there's a, there's a method that you can, um, call for the class that you know is executed after the render has been occurred, but since we have a, a function, um, component, you don't have that, you need something else so so we use use effect, um. And so to like I had a question too towards the end, um, after that was that, oh sorry, it's right here, yeah, actually, uh, component did my own component did update are the are the names of the uh methods in in class components um so use effect does something similar. So, so just to clarify, right, we have, we have kind of a series of steps that happen. So we'll have a state, uh, for a component. That state, if it changes, we call set state on that. Um, so, for example, you know, here we're calling set count. Set count will, um, is the Is the function that we've now gotten from the state hook, so that is going to trigger the react, um, application to know that, OK, the state has been updated. So at this point, we now, uh, need to, um, you know, re-render our application. So it will re-render that. And when that re-render then happens, once that is completed, then it will look at the effects, and the effects will then. Execute whatever it is that they have to do, so. You know, it all happens very quickly in this example, like you wouldn't actually as a user notice it, um, but what would happen is that the, the content of the page would first get re-rendered and then the title bar for the, the web page would then be modified to match this because then the effect is executed. Um So, uh, So use effect, uh, you know, works that way. Um, so use effect, like if it's called just like this with only one parameter, it just says the callback function, and that's the, that's the function that gets executed after the render, but you don't always want it to always call effects, you only want it to do. Maybe if a particular state variable changes, um, so you can actually just add a, a list of different items, an array of, uh, different state variables, um, and it will it will watch only those. So in this case, this will, if you put a dependency array in here, it will only, um, Execute this callback function if count itself has changed, not if any element of the state has changed and in this example, of course, there is only one element to our state, so it doesn't make a difference, but, um, in some cases you're probably going to have many different state variables and it's much more efficient to only do it, um, you know, when a particular variable changes, um. So that's always a good idea to put that kind of optimization in there if you can. Um. So, uh, So you've got we've talked about use state use reducer use of fact. There are actually other, uh, hooks, uh, that are, um, you know, predefined and react that you can use, um, if you, if you click on this link and take a look, um, I'll do that, uh. Um Uh, I guess this is a link to a slightly out of date, but you can see there's uh use context, and then there's a whole bunch of different ones that they implement. Um, they might want to use for whatever reason. Um, So So there's certain rules to hooks because I mean essentially what happens is for for the react uh framework to, um, you know, look at your JSX and really know that something is a hook versus just a random function, um, it needs to have certain kind of features in order to work as a hook. So it could only be called at the top level of your function. So you can't call use, uh, state or, uh, you know, use effect anywhere inside of your component except at the very top, uh, level of the, of the function. So you can't have it inside of a loop, it can't be inside of a condition or anything like that. So just look at the previous example here, right? Like. Use state is just called at the top level of this example, uh, component and use effect is also called at the top level. If you had some kind of condition or some for loop or something like that, you could not, you couldn't use it inside of that. Um, You could also only call it. In one of two places inside of react functions, so inside of a function component, you actually have the of the hook or inside of a custom hook that you yourself have defined, so you can make, uh, you can make hooks as well. Um, so. To make a custom hook, um, it kind of it's a function, um, and it has a similar, it has to have the similar kind of structure where it starts with the word use, uh, in lower case, um, and then in camel case it will have kind of whatever other name you want. So instead of a use state or whatever, you're gonna create a brand new hook called use friend status. And the key thing is that when you build this function, it must also follow the rules of hooks from the previous slide, you know, particularly it has to only be use other hooks at the top level, um, and it can only be, you know, a, uh. React function so you see here it's sort of like, um, you know, you're building a hook out of other other hooks um so this is not a this is not a component, right? So this doesn't have a uh uh a rendering, you know, it doesn't return a render, um, but what it does do is it returns some, you know, result of some case. So like in this, you're saying like use friend status and it takes us a parameter, some friend ID. It will um uh create a state and a set state function, um, using new state, and then it will also have um a use effect um and so what this means is that this use effect. Will trigger like some execution to happen when the state of the hook changes, right? So, um, you know, the hook has its own state, um, and if that changes, um, it will, and then whatever, whatever component the hook is living inside that re-renders it's going to call this, uh, this effect, um, in here. So in this case, um. What it's doing is it is going to. Uh, Uh, it defines a use effect, um, that introduces a an inner function called handle status change. And so, Uh, that will take a status, um, and will essentially call the set is online. State setter function, right? So it's gonna take whatever the result is of the status parameter and it's going to update the state. So that makes sense, but how does it, like what actually calls this handle status change? Well, in this case, we're actually going to use some API that's pretty defined somewhere else, we don't know, but, um, you know, it's going to, um, subscribe to some friend status, um. And, uh, it's going to pass in this handle status change along with the friend ID, um, and then, um, Uh, the, uh. Uh, return, uh, value here is going to be a function for how to, like, unsubscribe. Um, so that, so that you could then use that, um. Uh, elsewhere, but the point is, is that. You are essentially using, you know, you've you've created a a hook that's going to call some external API. Um, function, you know, so to find somewhere else and that's going to and then execute this set is online and it's, it's going to, so depending on whatever the API says if the API says that the, the friend status has changed or you know, is, is online or is not online, then we're going to get that value and it's gonna hook right into the state, um, and so it then returns we decide we're gonna just return the state. So if you use this hook inside of another component, then you would, all you need to do is say, you know, something like um cons is online equals use uh friend status and then the ID and it's, you know, it's all kind of encapsulated inside of this hook that you've defined. So, So it's a way to kind of like uh package up, you know, the logic around around state with other kinds of execution and and really kind of it's, it component break it up even more into like, you know, building blocks and and module or pieces, right? Um, so we have that use friend status and so if we have a friend status, um. Component, we can just use it, um, and it's gonna have a value here. And so then, um, Uh, you know, you can, you can in fact kind of just treat this as if it's like a state variable that's changing, right? So if, if this changes, um, it's gonna change whatever is, uh, being kind of this is basically returning a, a string, um, and then inside of this one. Um, it's doing the same thing, but it's using it as a, um, in sort of a condition where it's changing the color, um, uh, of the name. Either it's gonna be green or black, depending on whether or not the friend ID is on, is, um. Is online so you know it's a, it's it's a way to kind of, you know, build up, you know, pieces of your code so that you're, you don't have a, you know, all of the all the logic for example, to hook into some other kind of API inside of like your each one component, you could break this up and actually use the same code, you know, essentially the same kind of state management code in multiple components, um. Now, if, if you do this important point here is that. Even if you do this, um, these two components. Um, even though they're using the same hook, they don't share the same state, right? So, um, you know, when this one, uses the friend, use friend status, this is online, is different than this is online. Um, so it's just something to to keep in mind and um. So it's not like a global, a glob a way of handling a global state. Um, they're sort of each independent to the different components. I mean, you would imagine that this would Result in the same same value if they're both executed as rendered at the same time, but yeah. So So that's kind of how you can, you know, expand on this and, and create custom hooks. So under the hood, I mean, it feels like a lot of this is magic a bit because you're kind of, you know, you've got this react framework and it's hooking everything it's you're using hooks and it's and it's it's updating the um. Doing things to stay, it's, it's kind of executing side effects and all of this other stuff and so, um, you know, the question is sort of how does this work under the hood and I mean we honestly could spend a few lectures, um, really deeply down into looking at how it works under the hood, but what I, I guess what I what I wanna do here is just very briefly kind of show that it ties into like what I was talking about before about the virtual DM. Where we need some, I mean the inside of the of the react framework there's some kind of essentially like a loop going on where it's it's continually checking whether things are changing or not, um, and it's doing this kind of dirty checking on the dom tree and all of that kind of is, is implemented, uh, within the react, uh, you know, program code. Now, we often use the terminology of virtual dom um as a way to describe what's going on there. That was sort of like, um, you know, that term was introduced, but in, in reality, you know, nowadays, like if you look inside. Deeply down into the codebase, you see that they actually they call it reconciliation rather than um the virtual dog doesn't really matter about that, but that's essentially there's some kind of differing algorithm that happens between the trees, the the document object model trees to try to understand what has changed, what do we have to re-render, how do we have to handle that. So, so there's there's the reconciliation phase, which is the one where it's saying it's just trying to keep track of what has changed and then there's the render, uh, which is where that it takes whatever the the result of that reconciliation is and then it will update the, the view of it, um, inside of like, you know, under it all, they have this thing called fibers which are just an object. Uh, that contains various information about every component, so fiber kind of knows what are the inputs of the components, what are the outputs, and then it has some kind of like, uh, worker thing that's kind of, um, you know, each one of these fibers kind of sits on and, and it is sched it has a whole scheduling mechanism, you know, that essentially like hooks it all together, um, but I, I mean it's a bit of hand wavy, but you know, to get more than hand wavy is obviously a lot more. Um, detail that we have time for, um, but it's partly to just, you know, demonstrate that this is not really magic, that it's just that we're relying on a framework that has a whole scheduling mechanism built in, um, and, you know, it, it does all of that there in some very clearly defined, uh, steps. Um, so it, I mean, it looks something like this. I don't expect that you remember kind of this particular diagram or anything like that, but this is like, you know, This is sort of like the tree diffing thing that we're talking about, so you have some kind of representation of the rendered tree in the user interface. Um, it does some computation. It looks at the nodes, it tries to find out which ones, uh, are used next for rendering, um, and then that's sort of our the reconciliation, um, and then, uh, then it goes through a whole kind of, uh, rendering process once it batches those things together, um, and it has a whole workflow. You know, mechanism where essentially what it does is it follows sort of a depth er depth first search through the tree of the components, so it starts at root, it'll go down to a child. Um, that child will then see if there's other children that has to look at, it goes down that, and then it goes, once it's done, it goes to a sibling node, um, you know, if there's, cause, uh, you know, components can have different child nodes, and each of those, you know, they are handled in turns. So it's essentially like a depth first search through the tree, uh, to try to see how these things work. Um. So Uh, so that happens, um. So, so that's the reconciliation phase, um, and then, and then the. When you have a it goes to actually render it, uh, then it then each one of the hooks that you've defined has its own dispatcher, um, and so whenever, so when you say things like use state use effect, essentially what you're doing is it it passes the render call over to the dispatcher for each one of your hooks that you've that you've put in, um. So That render is the thing that actually like when you write that function, that's the thing that you, you have the actual return. Um, well, I mean, you know, it's an actual function, right? So you, it gets executed, um, and so as it goes through there, it knows the full like the as it's executing it, it kind of executes the function and then it has a linked list of all the hooks that are associated with that component. Uh, and then it goes through them in, in turn. Um, so it has kind of a a wrapper context around the component. It understands what all the hooks are and it, and it runs through them. Um Anyhow, um, that's, you know, I'm I'm just trying to give you a sense of like the bigger picture around that. I mean there is more to learn about this, um, uh, but I think it's beyond the scope of what we can cover in, in the course, but here are some additional resources that really dive deep down into, you know, not just using React, but understanding how in fact the framework itself works, um, and handles all of this different. Um, this whole mechanism for, for scheduling and and configuring everything, uh, and how, how it works and really I mean at this level is where you start to also tease apart the distance differences between the various um frameworks that we have. So I mean RAC works in one way, um, another framework like view has a different, uh, implementation. They might share certain principles, but. You know, you really start to see it once you look under the hood and see a little bit of, you know, how, how they're actually implemented. Um, So, I think that's enough about hooks. Um, I Uh, I also wanna talk about. State, uh, a bit more because we've talked about a managing state in terms of the components themselves, um, but then there's a concept of more of a global, uh, state, uh, but before I do that, maybe some any quick questions or anything about, um, you know, about what I covered with hooks. I mean, you, hopefully you've had some, you've seen them in the labs now, so you see how they work. Um, Oh, OK. Um, so, So We've already talked about state. Uh, in previous lecture where we talked about how every component has its own state and that state is internal to the components and the state is the thing we can change, right? It can, um, it can, you know, be, be, you know, you can set the state of a variable and it will then affect and change over the life span of that component, right? um. We also talked about props, so essentially props are like properties, right? And those are sort of read only values that get passed from the parent down to the child. So when you, uh, when you pass, it's it's basically like a parameter to the component itself, um, so. Children can also pass information back up to the parent, um, but in order to do that, what they, what the the parent has to do is it essentially has to pass down a function a setter function as the prop to the child, so. So if you have, for example, a function that changes the the sets the value of X inside of the parent, then when you include the child component inside of your component, one of the props might be, um, you know, X setter, and you actually pass that function in as, as the prop. So instead of passing a value down, you're passing the function. Then inside of the child, you can, you have that prop, you have that function, and you can just execute it. And so, the effect of that is that it will, it will call the parents set X function and update, update the state. So you can kind of have, you know, it's not always that the parents are pushing the state down through to the child components you can construct things that will kind of, you know, move it back up so if something happens to the child component, it's going to affect the state of the parent, um, but. It, you know, once you get beyond sort of strictly like parent and child, uh, you know, relationships for components, then it's, it's very, it's, it's very hard to kind of pass that information up and down and around through the tree, right? Um, so you need some other way to have some shared state that kind of works across all of the components themselves. Um, and so that's where you get the notion of a global state or a store that sits sort of outside of, of the tree. Um, so, You know, you might have different kinds of ways that components in your tree kind of interact with each other, um, and if for example, we have, you know, this component down here at the bottom of our tree wants to initiate a change, um, and it happens to be that that I mean you could do something like say whatever is happening in this component should affect this component over here, um, well. You could have things like, um, you know, when this component. You know, defines the child inside of it. It will pass a setter to some state in this component. Um, same thing happens when this component does it for this, and then this component passes that down to this one, sorry, down to this one, but you know, that's pretty hard to kind of keep track of and, and it creates a, it's a lot of extra boilerplate code because you're, you know, you always have to, you're always having to to sort of send these setter functions down through the children and, and so on and so forth. So the alternative to that is that you have something else that kind of sits outside of that, some store, um, you know, it's got a global, global state of somehow. And so, you know, different, um, components can Use that store to, you know, change values and then essentially you have a bunch of components that all observe relevant values inside of the global store um and and basically tie them into their into their state, um, so they map between something that's going on in the global store to their to their internal kind of local state and then if if that's tied together, then the local state will kind of. You know, trigger or something to re-render or something like that, um. So that's the idea. So there's actually a lot of different libraries that could be done. So this isn't just kind of vanilla React. These are usually other things that we use kind of along with with React, um, so there's lots of different libraries that manage global state, um, and so you define various actions that will update the state, um. And That global state I mean and it and it can be like a synchronous function so it could be something like I'm going to have a function like a, you know, some maybe I make a a web request to you know get some JSON data from a server. Once that server responds with the JSON data, then I, you know, there's some callback or something that will update that global state. So, um, we use, I'm just jumping down, sorry, to this one first. So we're using Zoo stand in the labs, so you're getting, you're getting familiar with that. We're using it because it's just the simplest and easiest one to work with, but I wouldn't say it's the most kind of popular one, or, you know, it's certainly, I mean, it's a bit newer, who knows? I'm not, I don't always keep track of like, you know. So maybe it's growing in popularity and so on, but you know, certainly, uh, redux is, is the one that is, you know, if if you're learning React, um, the one that that people oftentimes think to pair, uh, with React. So Redux is a, it's a library that allows you to manage a state, um, but it's, it is kind of verbose, um, and it has a lot of boiler plate that goes into it. If you can use it, you can use something called Redux tool kit, um, that works as long as you're saying in a more recent version of React, so it, it kind of works very nicely with function components and hooks and it all kind of, you know, works together, which has made it a little bit less, uh, verbose and hard hard to work with, um, but it is, um. I mean, it is definitely a bit more to it than than what what we use what we're using, uh, in the labs which is is this. I mean they they both they have different uh features and, and so on. Um, so, so those are two ones, um, I'm sure there's many others that are out there, um, but also there's a, there's another way that you can sort of manage, uh, state, um. And that is something called uh the use context hook um and so this is a way this is particularly useful for kind of doing some kind of um you know, sharing a global variable that you kind of wanna push down through an entire kind of element of the tree so because essentially what you do is you create a context around a component and then it gets kind of, it becomes the context for all of the children under it. Um, so it's the, the kinds of areas where I've, I've seen it a lot is for things like theming. So, for example, you might have, um, uh, a CSS styling. Um, that and say you have a dark mode and a light mode for your application, right? So you, they might use a context as a way, you might wrap that around your entire, um, sort of application component so that all of the different kind of child components that. access to that kind of global, um, you know, styling setting. And so, for example, if something happens where you change the styling from dark mode to light mode, then that will kind of trigger sort of re-render of all of the different child elements, you know, automatically. Um, so, so that's really great in that kind of situation. Um, however, um, you know, because it does sort of trigger or re-render, um, you know, when it like when the context itself changes. Um, it can be very inefficient, um, for things not, not like, um, not like a, you know, theming where, where you really do need to redraw everything. It can. It just, it has to trigger, you know, the full updates, um. So Since you get you're getting this down in the labs, I don't wanna really wanna go over it too much. Um, I do wanna kind of introduce you to the, the, the redux model and talk a little bit about the context of as well. So the redux model, um, basically. The user uh interacts with the view somehow. So you have a react component, um, you know, like your function component, you interact with it, um, and When the state. When a state update is actually required, the view dispatches what's called an action, um, and then that action, um, will, uh, Will go to a dispatcher and so this whatever the action is the dispatcher will then um do something similar to what we saw with the use reducer where it will essentially pass it on and update the state based on the various actions that are that are described so. So it's actually quite similar to what I was showing with the user reducer example before where, you know, so for example you might the the action is just it's the action isn't a is a code or anything. All it is is a JavaScript object that defines that describes what action needs to be taken. So for example, um. It might have a type add to do, and then along with that it will have text that goes along with that. So this is going to update some to do list inside of our global state or maybe you have a log in action and it has a payload alongside it. It's got a username and a password or something like that, right? Um, So, then the reducer uh is what we call a pure function. So, pure functions mean it's it's a sort of a a concept that if you've learned all about functional programming. We really teach functional programming, but, um, you know, they, you know, there's this notion of a of a of a pure function where oh thank you, yeah, it's all right. I've been just talking with yeah, no, no, that's quite all right. I tracked it down. Yeah, no worries, yeah, um. So, so the pure function is, is something that it's basically a function that can't have side effects, um, so it's common idea in, in, in functional programming languages, but the bottom line is that all it can do is it can update the state that's it. So it shouldn't do any other actions inside of your inside of your program, um, so in this case. It takes in kind of the current state or it takes in the yeah, the state uh with a default value along with the action and then you just create the logic inside of it. So you know, before we had, we had this action type, right? So it's just a string, right? And so it just takes whatever the string value is and then it returns kind of a new. New state based on the prior state. It's very similar to the use reducer that we saw before. If the action is not something that we've seen before, it just doesn't change the state at all, um. Uh, and so. Then, um. You can kind of combine this all together, uh, with the redux tool kit, um, so that you can create these things called slices, which, um, essentially have all the pieces together. It has, you know, it defines kind of, um. Like you, you have your, your, your actions, like I want to increase and decrease, uh, the value, you define your reducers as a field, um, and then, you know, increase and decrease here and it has an initial state and the slice has a particular, um, name, uh, value. Um, so you basically define it all, uh, like this, um, and then, um. When you actually build your counter, you can use this use selector uh hook to uh to um connect uh to That, uh, value and then um then you would, uh, you, you have a dispatcher and so the dispatcher is this thing so so basically you you create a hook that gives you access to your dispatcher based on the actions. So, so for example, if somebody clicks, if somebody's gonna click on a button, it will call the dispatch that we have, um, and in that we're going to pass in. The reducer that um that we want, um, and it will um. So you can see here that we have these actions increase and decrease. That's what we have, what we're actually passing in here, um, into our button. So it kind of hooks, you can see it's a bit, there's a bit a bit more complicated to wire up than something like um like soussand, um, but effectively, it's like you create a bunch of actions. These actions are objects that you can define. Um, and they have payloads potentially along with them, and then you define the dispatcher functions, uh, that will kind of modify, um, based on, you know, whatever actions that you're, you're taking, um. So, you know, you. You know, it's, it's mostly that like I want you to be aware because you know if you're going and doing rack development it's very likely you're gonna come across, uh, redus, uh, you know, in, in applications that are being built so it's not just using things like zoostand, um, but the the main concept is that you have this action dispatcher and reducer that kind of work together to update the state and then, you know, you, um. The you selector, uh, will, um, you know, kind of watch, um. Uh You know, basically, it, this is a hook that will tie it into our, our reduct state automatically, um. So just saying it's a whole lot easier, it's much simpler, um, you, you know, we've already seen this. This is just from the home page, but you know, all you do is you just create a store, um, you maybe have variables and then you define your, your functions for modifying or setting the state to a new value, um. So we go through all this in the labs. I don't wanna spend too much time on it, but yeah, I mean, you could see this is a whole lot simpler um than redux. So it kind of explains why, you know, it seems to be the pattern, you know, I mean, it's like the same story that we had with Angular I came was developed, it was really heavy weight. A lot of maybe overengineered and then you know people came up with React as a response to that and things like view and a similar thing. I mean redux was sort of the the initial one and you'll see it it's quite used quite often, uh, but then people are like, we want something simpler it's easier to work with and use, um, and so that then we see things like Zoota get get developed, um. So, um, the last of the state things that I want to talk about for the global state is how we is using the context, so. Essentially the way it works is as follows, um, you create something called a context object, um, calling the create context which is provided by, by, um, by react and then what you can do is you, you know, this context then is a component. That is what's called a a um a context provider, um, so, so you would say something like I'm a user context provider, um, so that component provides the user context to all of the child components that live under it. So you actually, it's actually kind of gets built directly into the sort of the, the more HTML style side of, of what we're doing. So, here, like the user is some state variable, you know, maybe outside of here, right? Oh, And then, you know, it can be uh used in in by by various components. You then can access it using something called a use context hook that will take um the user context um and then you know in what inside of your child component um you can actually you know have access to that value so instead of passing it through as props, you just get access to. The variable, uh, through this use context hook, um, that has been defined, you know, this has been created out here we have a provider and then once when we're inside of, I mean this is a different, so imagine a line here, this is a different, um, place this is inside of the, the, the child component you can just access that that user, um, directly with the hook. Uh, and then access it as if it's a variable, right? So, um, for the styling example, I mean, this would be kind of like, you know, there might be some CSS stylus or whatever that feed or themes, um, and those might go into the style of your different components in some way or another. Um. All right, so, yeah, I mean, that's use context. I it's only really used for things like I said for for theming and so on, but it's just to give you like a full picture. There's different ways ways to do this. Um, so last thing that I want, well, let's see, I mean. Yeah, based on my I've got like a little bit of time. So I'll talk about routing, uh, and then I think just very quickly cover, um, things like debugging and so on, probably when next week when we come back. Um So, so routing, um, is the idea, right, that when you go to your web page. Um, like in, in a normal web page, right, it's not a single page application when you navigate through things like you click a link, say you're on a page and you go to another page on your web page, what it actually does is it, it kind of goes to a new web page, uh, by loading, basically make a new request for a new, new, um. New HTTP request to the server, give me this new HTML page and, and render it, right? Like that's the bar, that's like kind of the old traditional way of building kind of a multi-page, um, application. But in a single page application that doesn't happen. We don't have that that new round trip to the server where we request a brand new web page for the other page. So like in, in the example of the labs that would be like you're on like the kind of home page where you list a bunch of games and then you click on a game and it goes to. A the the you know, the page for the individual game like you know, previously those would be just different HTML pages right? that you would load, but we don't do that now. The page is not actually reloaded. What happens is that when you click the link. Like it's actually like a a link inside of your like a tag inside of your your page instead of making the web request what happens is uh essentially React will intercept that, um, and it will just update the content all on the client side, um, without ever making another round trip to the server unless of course it requires some data from the server. Um, so, You don't re-render the entire page, um, and you don't certainly don't, and, and also you don't have to re-render and re parse the framework JavaScript code, which was bundled in with the original page. None of that has to happen, so it's potentially saving a lot of data, time and, uh, transfer time as well as speed. And the update and nice thing is that you can also dynamically update the page doing things like, um, CSS transitions and all kinds of sort of stuff just by, you know, clicking on links, um. So routing then in a single page application is not any anymore about navigating through to different HTML pages, but it's sort of it gets intercepted and then it it basically it is just a different view, um, and so what we do is we use React router, um, so react router is a a way of essentially, you know, pulling apart that what we put into the link, uh, and parsing it into to different things, um, so. The different basic concepts is that you have a URL, right? That's it's on your web page, um, you have the location, um, so this is some object that sits inside your JavaScript. um, if you were to type window.cation in the console, you'll actually see it as well as a history, which is just essentially like a stack of like the back stack of like what pages you were at, uh, previously. So. It's just it's a normal data structure like a stack, so you pop and you push and you can replace things uh it's not, well, it's more than a stack because you can replace, um, but essentially, you know, the history stack is a data structure and so that's hooked directly into the back button right in your browser, um. Uh, and so what happens is that you, the routing then is programmatically changes that history stack without making a server request. So for example, if I, if I am on my home page um of the games and then I click on the game and it goes to, you know, an individual game page, it's gonna update the URL. So it's going to update the history stack. It's gonna update the window.cation, but it's going to do all that without making a new web request. But what this means is from the browser perspective, all it has to do is if you click the back button, it's just gonna go back to the previous page also without re-rendering the web page, right? Um, and then the other thing that it does is that it does basically a pattern matching against the route, um, sort of similar to what we were doing on the API side, but this is on now on the on the front end side, um, it, it kind of you have certain pattern, um, and when it matches a specific pattern, it's going to render some sort of, you know, elements within your component tree, right? Um, So The location object, this is an object that's provided by inside of the browser. I mean, it has some, some information. It has some things like the path name, um, it, it separates out the search component out, um, it can, it, it, uh, pulls out the, um, the hash, um. Uh, which is sort of the thing after the, the hash character, so it basically can deconstructs your URL into a location object and you can manipulate that directly. Um, there's a few other things like the key. I mean you don't really need to worry about that, but it's sort of a, it's a unique key so you can, you can do caching and and so on and so forth, um, but essentially, you know, it's made up of these different elements, um, and then what React does is it will directly kind of. It can parse this all up and we, it reads those different elements and constructs, you know, basically as logic inside of it to say which components are we going to, to, um, render depending on the values of these different things, um. So, you know, you'll have something like this where you define ase you have a bunch of routes, um, and inside of that route, it's, it's like a structure where you have, um, it does basically the pattern matching. So, you know, if the route is, um, you know, a root element, it should have the app and then inside of that, you know, if it's, um, like just the index, which means, you know, nothing after it, um. Or that will also match, I think index, uh, the HTML I think uh I have to double check that um, you know, it will do the home element, but if it's slash teams then it's going to render instead of home it's gonna render the teams component and then after that, after teams, um, you can have dynamic matches so dynamic matches will be. You know, these can be anything could be filled in there, but it's gonna be put into that variable so like it it could be slash team slash one and so what happens is that that will create a team component but pass in a team ID prop with the value of one. So then you have it basically parses up the tree and turns them into variables that you can then use to to render however you want, um. So, you know, you basically build it up all like this, um, in here. So, and the element, it's this element of prop that tells what, what component are we actually going to render. Oh, sorry, I'm running out of time here. Um. All right, uh, yeah, so, um, that's, that's routing, um, I may pick it up real quickly, uh, next week and, and cover debugging, but then we'll move on to other topics other than react when we, when we come back next week. All right, thanks a lot.

SPEAKER 0
Yeah Hello.

SPEAKER 2
I think you're saying that they store like a stack of um the requests or would they put it back right so you don't have to render it when you go back. What if you want it to be re-rendered because for example you've logged out and you wanna, when they click back and be able to view their personal information from the.

SPEAKER 1
Uh, well, I think what we would have to do is you basically would have if they hit back right then you would probably have something that would be checking the login status because it will re-render it, it will like. So if you hit back, it will, it will, it will do the react re rendering. It just won't do a new web request. So if you have something like a logged in variable and that's false, then it should not no longer show the logged in information. Does that make sense? Yeah.

SPEAKER 2
Application we've made where when we're clicking back to Oh really yeah, yeah, yeah, yeah, I mean as long as

SPEAKER 1
the, as long as the component kind of checks some logged in variable like you have something like that in the state then you should, yeah.

SPEAKER 0
OK, yeah, yeah, OK.

SPEAKER 0
I There are single visit that us. No, no, I, no, no, I just, I just, I just, I just. it's. I right now. Yeah I can. And Uh Have you The OK How increases But Around So He's Which I Uh and. You can make the uh Yeah. And like oh I need to I'm like so. That It's like Is that what So Yeah I Oh, I. Yeah. I All right.

SPEAKER 1
Hello everybody, so any questions about anything before I start? Oh, OK. So, uh, I'm gonna finish up what I was talking about last week, um, so a little bit of, um, more material on react, uh, and then I'm going to switch to some new topics for this week. Um, So when I finished up last week, um, I had been talking about, uh, routing and react, uh, just as a real quick, uh, brief, um, review. Um, we talked about how, you know, when you're in a web application, you've got your URL it's essentially, you know, your location where you are, um, and, but behind the scenes within the browser it's got a location object and that keeps a history of, uh, kind of, uh, and with that is a history of like all the previous locations in a stack and so. Uh, when you build a single page application, the routing is actually redirecting, changing, updating the view of the application without doing a full kind of, um, back and forth with the server. So it actually programmatically just redraws the, the application, uh, on the client side entirely and it's done using a kind of pattern matching just like the route match, um. And so I talked about the location object, how it has uh things like path name search hash, so on so this object is then matched against, uh, using the react router so the different components can be you can essentially have them, you know, go to one, aspect of your application or another aspect or show 11 particular component or another. Um, and so, when you have routes, it kind of looks like this, you have a series of routes, um, and then it's a hierarchical, uh, kind of, uh, Nesting of these route elements, uh, depending on matches within the path itself, um, and so you kind of build up those elements as you go. So for example, the, uh, if you're just at the root, uh, and it's just the index and it'll show the home page, but if it's slash teams, it'll go to a teams page and then if there's additional elements beyond that within the URL, uh, then you can have dynamic elements to your. Uh, page, uh, and those will update. And so React basically parses that, um, and draws the elements of your, of your application, um, as you need. Um, So the element tag here is the thing that actually lets you hook in, you know, different components that you've built for your application. Um, so, uh, I kind of covered that pretty much. I think I got through that, uh, last week, um. So routing is important, um, it gives like it allows you to kind of give some, you know, structure to your to your application, um, you can if you want kind of more dynamically, um, you know, like investigate and like look into the route and and do additional things but for most intents and purposes like if you're trying to build an application, uh, in react. Uh, you basically just have your separate pages all kind of put into this main routes that is gonna be sort of in, in sort of the base element for your, uh, or component for your application, um, and then you kind of build up from there, um. So, so routing, um, is important. It doesn't actually have anything to do with the routing that we were doing on the API side, so don't confuse the two. Like, um, on the API side, we had a route the path that was like, you know. Told us what end point we're going to within our, our API spec on the front side, we have routing, but that's for kind of giving you a particular, uh, component, uh, you know, within your, within your react application. Um, so they're completely different, um, and when you make your web request to the server, of course, you are. Accessing an endpoint within your API, uh, but it doesn't necessarily match anything to do with the route of your, of your application, you know, in the browser if that makes sense. So just to confuse the two is the terminology is the same when we talk about routes, but it's routes and routing, but you know they're really talking about two different things on the server and the client, uh, side, um, all right, so. Uh, beyond routing, another aspect that I wanted to talk about, um, and part of the reason why I introduced this whole notion of class, uh, components in the first place, um, because, you know, you can do most things with function components, but, but, you know, I, I mentioned that there might be some cases where you want to use class components. And so I just wanted to highlight a couple of the things that you can do. Because once you have, um, kind of a class you can of course get all of the object oriented features and in particular you can do things like extending classes and so on and so forth which you can't do with a function component, um, so, uh, one of the things that you can do is build higher order components out of other components, um. So this is an example of a kind of construction, uh, that you could build, uh, where you essentially wrap the components with something called a props proxy, um, and so what that means is that. Down here you can see at the at the base you have a a function here um that takes a component as the parameter, um, and so it's sort of it's a, it's a wrapper and in this case, um, what it does is it effectively like, uh, injects, um, some properties into, uh, the component, um. Just Um, So, uh, in this case, uh, we have a welcome component, um, and this welcome component is going to be just a regular component. It has a render, uh, function, and it's just gonna be a div saying welcome and then it has this, uh, user and so. Uh, what, uh, what with user does then is it takes in some component, it could be welcome, it could be any other number of components. So the idea is that you could basically Uh, call with user on any number of different components and it should pass through uh this user property, uh, for, uh, the component. It will, um, basically, uh, create a wrapped component, uh, with, with this, uh, uh, property, um, so. Here you see. Sorry, hold on. Yeah, so, so wrapped component is the, the pasted in component. So it calls that, but then it adds in, uh, whatever properties, um, Uh, exist, uh, within this like custom made, uh, react component. So what you can see here is that the return value of with user is a class, so it's actually taking a class, it's extending the basic react component, creating a render function, and then it's gonna basically have inside of it and whatever component you passed in, but then take the properties of, uh. Uh, that are, are kind of, um, that exists there and, and pass those in. So then this will have basically it will get passed into this this child, uh, component. So what this does then is that if, if this props if the user property exists, um, then it will. You know, return this wrapped component but that otherwise it just returns some, some default, um, so you can kind of, you'll sometimes see this, um, in examples of racked components where, uh, they might do some kind of theming or other kinds of, um, you know, additional way that they want to pass down sort of the same property down into a whole bunch of different, uh, components, um. In this case, the user might be the logged in user. Like what if for example you have like lots of different components in your application and they all need to know whoever's kind of currently logged in, then you might use some kind of construction like this with user, uh, and then, and then, uh, use that user information somehow, uh, within your component. Um, so this is one thing that you can do with class components that you really can't do at all with function components, so it's, uh, you know, it's a nice kind of abstraction, um, that can help with things. Um, there's a, a few other, uh, kind of extensions to that, um, so you can use a thing, um. Where you can actually wrap. If you wrapped components, um, and other components, then you can kind of nest them together. So here you have the welcome component, um, it's wrapped with this with user, uh, function and then that's also wrapped, uh, with a, with a loader, um, function. Um, so, uh, essentially what it does is it's kind of, um. Uh It's, it's, it's passing in sort of the fact that, um, you know, first it checks, you know, is, uh, is it loaded if it's not loaded, it will just always say that the the current d is loading, but then here you'll see that it returns in this case, the super, uh, classes render. So all it's saying in, in this case is create a wrapped whatever component you pass in. Um, Call its render function otherwise have like some kind of default um component um so instead of like kind of pass in this case with the user what it's doing is it's passing through some kind of property in this case it's showing that it can, it's either going to defer to whatever whatever the kind of child component is or it's going to have some other view in this case it's, you know, if it's not currently loaded, it's gonna have like a loading. Uh, D, otherwise it's just going to render, um, whatever, uh, whatever this rep component was. So, um, the difference here is if you see here this return value here is extending react component. So what it's doing is it's actually just creating a new component, um, and calling it's render function. In this one, what it's doing is it's extending the the type of component that was passed in. Um, so it's, it's it's taking this, uh. This, this component that is wrapped around welcome and it's going to extend that component and change its render function so that it's render function now has a condition that's testing has it loaded, um, otherwise because it's because it's extending the the component that's passed in as a parameter, you can call super on it, uh, which means basically just take the super classes version of render and and run that, um. So this kind of stuff um is is useful if you're building for example very complex, you know, uh, application and you need to have certain behaviors passed around throughout many different types of components so that you want in effect wanna kind of have, have some kind of um abstraction around around the whole notion of components in general. Uh, within, within your application, um, and like I said, this, this can't be done with function components. So if you want to do something like that, then you have to do something, uh, like this. And so this is called inheritance inversion when you pass in the, um, when you extend the component type that's actually passed in as a parameter, uh, the previous one is called props proxy. So that's when you, um, when you extend the react component, uh, type. Um, so there's two different ways you can build higher order components off of other components. Uh So, uh, so yes, um, the last piece that I wanted to talk about with respect, uh, to react. Is how you can actually go about debugging React applications, um, I mean, obviously once you move into the browser environment, things are a little bit different, uh, than working in an ID, um, I mean because essentially you've got, you've gotta run your, your, your server you have to actually, you know, I mean, run the application, compile it, and then, and then load it up like on your local host and so the instructions are all there, um, you know, that in the labs for how to do that. Um, but there are some techniques and tools that you can use to actually, um, help with debugging react applications, um. So, so first off, um, When you run, uh, in some in development mode, um, sort of depending on whether you, you know what kind of like, um, package manager you're using and and how you're actually have set up your your project, you know, you might have different commands for that, but if you're running into development mode in react, you should have hot reloading, um, that's enabled so that means when you. Open it up, it's gonna start running and on some port like localhost 3000 or localhost 4173 or something else, right? So it's going or 5173 I think is a common one. So you'll have these kinds of um the application will be running there and the console will be there like visible, um. Uh, like, basically you, you can open up the application in the browser and it's running, but if you have the console, then you can, any time you've written like a console.air or console.log, you can always kind of, you know, watch what's being printed out. So it's essentially like a print line of like your current, currently what's going on. Um, so that's probably the best way to develop because you have your, your browser window open. Of the web page, the console's visible, um, and then you basically the terminal wherever it is that you're actually running the application as well with hot reloading, what happens is that if you save. You know, if you change the file, um, it should automatically rebuild it and sort of reload the code directly into the browser page but sometimes that doesn't work, um, you know, so for example, if, if the whatever you do, like say you could change the code and it actually crashes or the code can't compile anymore, um, then you'll see in the browser window probably a big error message like that if it's running in development. So at that point you pretty much need to reload the page, um, you know, it's not the hot reloading will will stop working. So you know if you're, if you're getting to a point where you're expecting it to hot reload and it's not, you know, first thing to do is just reload the actual browser page, um, and then if it's crashing, obviously you've got a bug in your code or something like that that's actually causing that to happen. So it'll show like a big error message if it's running in development mode, um. And then you can try to to debug debug that way, um. So, um, obviously writing to console, I mean, it's kind of like the, the most basic way to debug, but it's still like a very effective one, right? You could just print out, you know, variables as you run your code and then you can see, look in the console and see whether or not things are are going so you can see the state of variables like as they load because sometimes it's a little bit. when you're writing back to know, is it, um, are you kind of like, like what point in terms of where the component is, what part of what component is running in what order, um, what's happening, you just sprinkle through a bunch of console.log, um. Um, commands throughout it. And then you basically have trace through the code that as it's going on. Um, of course you always want to remove that before going into production, obviously like if you were to compile this, you don't wanna be logging a bunch of debug code to your to the console if the user is actually using it in production. Another, um, uh, quick tip is that when you use console that log, you know, if you just use a string and then you do plus, um, I mean that will work in JavaScript because it will coerce whatever the value is to a string and then created one string from it. The problem with that is that if you use a complex object with that, it will basically coerce it to a string that says object or something like that so it won't be very useful to you if you want it to actually um sort of print out the contents of that complex object, uh, use a comma instead of the the plus so it's not. Trying to coerce, you know, whatever it is you're trying to print out to a string, it's console log it's basically passing as a parameter and so it treats it differently, um, so it's just a little tip that makes your life a whole lot, uh, nicer when you're actually trying to, to debug and look at things, um. So, uh, the other thing is that, you know, of course you can go deeper and use a debugger, um, in Chrome developer, um, there is a, uh, a react debugger, um, that you can, um, install. Um, so, well, no, sorry. First of all, there is just the debugger. Um, so the debugger itself is, is like if you go into the source, you know, you can do things like put the debugger command. Directly into your JavaScript. And that will kind of like set you can set breakpoints and and run the code just like that. And so if you run your application, um, you know, the Chrome developer tools, so it gets to Chrome developer tools you just need to go in and go through the menu system and you'll you'll get there and it's the same way you get to your console, but you can look at that, you know, if you're running the development code, you should have all the kind of original source files available. And you can go in and, um, you could edit it, but you can also set, you know, manual break points, that sort of thing. So you can essentially run your code to a certain location and then inspect various variables, um, to see, you know, what's going on. On you know once it stopped like you basically can go over here and look into the watch area and and identify the values of things um so that could be very useful. I mean, I personally I find it's just as easy to write a bunch of console, you know, outputs, um, but, um. This allows you to sort of do a bit more step by step debugging if you've got some, something else that's going on that's not clear. Um, and finally, there is a Chrome extension, if you're developing a Chrome. It's called React Developer Tools, um, so I think, I think on the lab computers you can just install this in, you know, via like if you're logged in with your account, um, on your own, you know, instance then then because it's a Chrome extension, like if you log into Chrome with your account, you should be able to do, uh, um. Excuse me, should just be able to install that, um, and so the react developer tools are nice because it adds two different, um, tabs here into the, um. Into the Chrome developer tools. Oh, and I mean, as a side point, you know, we're obviously, you know, if you're building an application for production, you're gonna build for all kinds of different browsers, but in terms of the coursework, um, you really only have to, you know, use Chrome because that's what we're gonna be using for all the testing for the second assignment. So you just can focus on Chrome for what you're doing. But these two tabs, like the first one is a components tab and that will actually, you know, show you, uh, the components of the page and so instead of like instead of the, um, you know, the developer panel interacting with the various HTML elements like the like the divs and and the paragraph tags and all that you can start to interact and mouse over and find the different components as they match to your. Uh, to your react, uh, code. So that's super helpful. Um, you can see, you know, what are the props, you know, all the hooks and so on and so forth. So that's really nice. Um, and there is also, well, so there's also a profiler tab. So you can see, um, you can see the state, you can see the props, you can see the hooks, uh, the, the profiler, um, is for testing the performance of different components. I mean, that's probably pretty much out of the scope for like what you're doing here, uh, but you know, if, if you get to the point where you're building an application and you need to understand why is my application being slow, something like that, then you could use the profiler for that. Um, so these are super helpful and you should be able to just install them as, as extensions like if you log into Chrome using your own account, um, on the, on the lab computers. Um. So that's um. Really it in terms of like, you know, debugging and so on I mean obviously you, you also have the ID, you know, for developing, you know, your type script code and and the JSX code and all of that stuff like, but um, you know, it's you're kind of sitting somewhere between the browser um and the and the IDE when it comes to actually developing so it's a little bit different than sort of a. Uh, standard development environment because I mean, you, you just gotta make sure they're both in sync, you know, as you're working through it. Um, but really the console is a big help if you just don't information out as it's, as it's coming. Um, Any questions about any of of any of this stuff? No, um, OK. So, so that's more or less in terms of the what I wanted to dive into about REA in particular be above and beyond what we we cover in the labs, of course, um, so. What we're gonna do now, um, sort of in the next uh few weeks is shifting to a few other topics around the client side, um, development, um, and so. The first of these has to do sort of like we, we've we've worked with, you know, the API in the back end and we can make requests to it, uh, via, you know, like, uh, using the tests and everything and it's in the first term and then, you know, we, we are building, you know, a frontted application but then of course you need to tie it together, you know, you need your single page application to be making network requests and connecting to that. Uh, so, uh, the plan, you know, this week is to talk about those, um, aspects that connect the kind of the net the relationship of how the network connection happens between, uh, the client, um, like the single page application and the server, and then we move into some other kind of, um, client side storage topics, um, that, uh, kind of complement what we've looked at on, on the server side. So I'm gonna switch over my slides now. All right. So the topic now is about the communication between the single page application and and the server. Um So, there's a few different um key topics I want to cover. Uh, the first is something called Ajax plus XHR. Uh, the second is course, um, and finally, I want to talk about web sockets. Uh. So, uh, the first topic is, um, Ajax, uh, XHR. So I've, I've used the Ajax, the term Ajax previously already in the course. I talked about how, uh, when Gmail came along, it was sort of the first, um, example of, of a real single page application that dynamically. Uh, redrew the, the, um, the client interface and was responsive to data so that what it did is it made requests to the server, got, got data, and then that data would kind of like inform the application to redraw as it as it needed, um, so Ajax and XHR, I mean Ajax stands for asynchronous, JavaScript and XML. Uh, and XHR stands for XML HTTP request. So these two things, I mean, the, the, the names are kind of antiquated or out, I mean out of date in the sense that they don't really have anything to do with XML per se, um, but they are kind of technologies that are now kind of built into browsers and they're kind of what underpin the ability of an application to um. You know, load initially of an HTML page, execute some JavaScript, and then dynamically, you know, get pieces of data as needed, uh, to redraw or kind of, you know, recreate the view, um, so together, um, these two technologies tell us how we can retrieve data from the server or send data to the server. Oh, well, the user like interacting with with a web page on the browser, um. So, um, Before I, I dig into that, I wanna just briefly kind of um dive in to. Sort of somewhat at a high level, um, like what's actually going on inside of a browser, um, when you're running your application um so uh what what I'm showing here is just uh a diagram of the process architecture, uh, for Chromium, which is Chromium is the open source version originally like the base of, of the Chrome, uh, uh, the Chrome. Uh, browser, but Chromium is also, you know, the foundation of the Edge browser and, and Brave and lots of other things. So, so lots of browsers kind of use this model. And so what happened is, um, when. Uh, a, a few years back now, um, when Chrome was developing their browser, uh, when Google was building Chrome and they were developing kind of the Chromium, um, you know, kind of the Chromium architecture. Their whole plan was to build a browser that wouldn't crash all the time, so the problem with browsers used to be that like you would load a page, something would happen, you might have like 10 tabs open and the entire browser would just crash, um, and it's everything you'd have to close the browser, you have to reload and part of the problem. Behind why that was was because, you know, they were all kind of you just basically have one application and it was all linked together. um, so Chrome, what they did is they kind of broke up the way the browser works into multiple processes so every tab is actually. It's own, uh, kind of process in the operating system. So if that process dies, um, then it doesn't crash all the other tabs, right? It only crashes the one tab and so you've seen that probably before where the tab like goes down but you can click to another tab and everything's fine, right? um. So that was one of the innovations behind um what what chromium was all about um and so you know it's it's it is a fair bit more complicated than that and uh like I'm, you know, admittedly I'm not going into all of this, but the bottom line is that there's these different kind of processes that are kind of running uh in your application and so one of them is you have this browser, um, kind of this browser. Uh, process and this browser process has an input output thread. So it's a, it's a multi-threaded application. So these different threads maybe are running on a multi-core CPUs. So you have an IO thread. This IO thread, um, has, um, kind of a channel bus that allows you to basically send communications between different components of the application. Uh, and then this has like a main thread, um, which is the main thread that that is the thing that kind of is the host for doing all the rendering in the web page. But alongside that. You'll have these various uh different render processes and these render process you can kind of think of it in a very kind of big picture way that like the renders like every single tab in your application, it has its own render process inside of that it's made up of different threads and so on and so forth um. So even if you go like a bit deeper into that, um, they have. Yeah, they have like the main thread, they have a render thread and inside of that is this thing called uh like called, uh, web kit, um, which is the actual rendering engine that chromium uses. So it's the, it's the thing that actually constructs that. Document object model, um, it lays out the web pages, um, and all of that stuff and it's also what where the core JavaScript, uh, exists as well as the JavaScript engine so basically all that stuff is happening inside of you know, a render thread for the tab, um. But this each tab doesn't actually have its own kind of input output, uh, capability. It can't make network requests. Um, what what it has to do is it has to sort of basically send messages along this thing called the uh interprocess communication bus that like sends it up to here. And this thing makes the network requests, um, and, and like so for example, if, if, if your browser wants to make an HTTP request to a server, um, then somewhere in here you're gonna have some JavaScript, it's going to do, uh, something that's gonna dispatch, um, which is then gonna put something on the IPC here. It's going to set it up here and then the browser at some point, you know, makes its request and then it needs to actually send that information back down to. To the process, um, so like behind the scenes, like if like for example you do like a mouse click event, um, there's all kinds of stuff going on, uh, you know, here, um, it, it's basically, um, going to like go through a whole series of steps and then in the end if that mouse click you know has some code to make a network request, um, that eventually is going to make its way out into the IO thread and this all hooks in. To that whole event cue model that I talked about, uh, in, in term one. So, uh, The it's, but, but that, but that event queue, um, the, the JavaScript engine, all of that stuff is actually sorry, I lost my mouse, it's all inside of this little um box here called called web kit, uh, so. So this is the big picture, but essentially what we need, what browsers need is some way to kind of um hook together um this ability to make these external network requests out of the code um and and you know, essentially. Create an API for that um that the browser then implements and then the implementation of that involves this much larger architecture um which we have don't have enough time to go into any more detail on but it's clearly there's like a bigger kind of context in which in which this is all, uh, running, um, but the AHX and XHR requests are part of that, a part of that, um. Uh, API that sits inside of web kit that will, um, then make dispatches out, um, occasionally and, and fits within within this larger, um, application structure, um, so what actually happens, um, like when you want to get data from a server into your single page application that's gonna that's living inside one of these render processes in in the browser. Um, So So first off, um, single page applications, um, like we've already said, I mean, I mean talk about this in terms of JavaScript frameworks, but they separate. The data um from. The the content and and the presentation, um, so the question is how can you get the data from the server without uh refreshing the page um well you you're going to need to have some kind of call that you can make some JavaScript call that's going to tell the browser that you want to make a new HTTP. Get request so you're not gonna be making a get request for some HTML, but you need to get it from something else. um, so you don't want the user to reload the page, uh, you just want to be able to get some specific uh piece of information. Um, so, so you need a way to make HTP requests concurrently, um, to and independently of the user interacting with the application on the browser. So the the user is gonna be sitting there and they're interacting with the browser, um, they're clicking a mouse events, they're doing sorts of different sorts of things and then occasionally your application needs to say, um, I'm gonna go make an HTTP request, but the user keeps on working. They're not, they're not blocked. They can keep on interacting with the application. And at some point that concurrent, um, process, that other thing that's going on, um, has to complete and then your application needs to do something, uh, with that. Um, And you need to do all of this while balancing security and usability and so this is going to tie into our when we when we talk about cores, um, probably we'll get to it by tomorrow's lecture that there's certain, uh, considerations around security that we need to think about. If we have, you know, we're essentially have applications that are running inside of our browser that can make arbitrary requests out onto the internet, so we need some rules around what kinds of requests they can make, how they can make requests, who they can make requests to, and that sort of thing, um. So, um, so this is where, uh, XHR and and Ajax come in. So the idea is that they can execute some HTTP method, you know, like a get request, a post request, something like that. They can do it programmatically and they can do it in the quote unquote background, um. But Recall that JavaScript is single threaded so when I talk about background, I'm not talking about it happening in a in a parallel computing way, um. It's going to be done concurrently using that event, uh, event loop. Um, so, So you use JavaScript, you issue the HTTP request like a get, get or a post, um, and then, uh, you use this XML HTTP request. JavaScript, uh, API, uh, to do that. So you initially there so this, this API exists in basically every modern browser, um, and so there's kind of a raw, uh, JavaScript XHR, uh, that you can use or. You use some kind of abstraction of that, um, and that's really what we do nowadays is we use some other kind of library or functions that that browsers now have like, um, and, you know, it used to be that we would use JQuery before JavaScripts came in and they had functions that looked like this. Um, more recently, there's libraries like Axios or you can use fetch, um, to actually, uh, Make your requests. Um, so we don't actually use the raw, uh, XHR API anymore, but I am gonna show you what it looks like just so you kind of see what's going on under the hood. So a side note, um, XML HTTP requests, I mean, this XML part of it is just historical because it was back when we thought all the data that we would ever request on the internet was going to be XML. In reality, it's usually JSON or some other thing, you know, like an image file, like we don't actually use XML much anymore. Uh, so you basically, the way, um, the XML HTTP request works is you set up a request first. So you set up what kind of HTTP request do you want to make. I mean, I'm gonna make a get request, am I gonna make a post request? Uh, And including in there, you could put all of your various parameters, just like when we make, you know, we're talking about the API endpoints, um, in term one. You can set up the body, you can construct that, um, you can send anything, uh, it doesn't have to be obviously XML anymore, um, and, uh, you have, you specify sort of like what kind of data you expect to get from the server. Like I'm expecting JSON or I'm expecting H sorry, XML or something like that. Uh, and then you define essentially a callback function for handling sort of the range of different responses you can get. So if you get an OK response, then you should do this callback. If you get an error response, you can do that callback, and so on and so forth, right? Um, you know, so, like, unsuccessful or unsuccessful response. So, so you do all the set up first, and then you execute the request. Um, I'll show you what that looks like, um, and I don't know why it's doing this in my slide. OK. So here's an example of what raw XHR work looks like, um. So you could just copy this, uh, directly into an HTML file. You can just add the doc type, like the HTML head and body elements, and you can open up in a browser. And so what this, um, Let's see what this code actually does. So, in it, it's just got a couple of divs. So let's say, um, in here, it's got something saying an example data returned. Uh, another thing, uh, saying this ID PID, um, div with nothing in it, um, and then it has a button, and when you click on the button, it's going to execute the JavaScript function go. And all that it says click me. So if you, if you open this up, you say click me, um, well, first of all, when you load the page, excuse me, it's just gonna say example data return and it's just gonna say nothing, uh, in there, right? Um, if you, um, then click on that, um, what's the go function gonna do? Well, it actually creates a new XML HTTP request. um, so this is sort of the, the setup phase, um. And then you define, uh, basically a, of, of, uh, you, you define like what you want to be executed, what is the callback, uh, that you want to call when the state changes on your request. So your request can have, uh, 5 different setups. It could be, uh, unsent, it can be opened, it could be headers received. It can be loading and it can be done. Um, and so each one of those is a number. So like 0 is unsent means you haven't made the call yet. Uh, it's 1, it means it's opened, um, and that means that it's been sent, um. The headers received means that you've sent it and the headers um and status have been received in the response, uh, loading means that it's downloading. So the reason why you might get headers before the full response is maybe you're making a multi-part request right where you get the headers and there's still like multiple aspects they're responding. And then finally, uh, 4 is done. So, so what this is saying is this is just saying if that number that state has changed, uh then we're gonna say is the ready state equal 4 that means we're in the done phase and the status equals 200, so that's the response of of the status, um. Uh, um, sorry, that's the, the, the status of the response where you're like, you make your request and that's a 200 code, right? So it's an OK code. And then at that point, I'm gonna call document get element by PID so this element here, and I'm gonna set the inner HTML equal to whatever I get back from my response. Um, so this is all set up right here. Then you call open. Uh, which is where you actually define what kind of requests you want to make, what's the URL you want to do, um, and to be honest, I'm forgetting what the true, uh, stands for off the top of my head. Um, but then. You send it and when you send it, um, that's the point at which it will, you know, go and make the request and of course because this is something that's happening asynchronously, what really happens is that when you make this click when it executes send. Then if we went back to that bigger picture of the browser, um, and how it's set up, it's, it's gonna call this, uh, XML HTTP request API which itself is gonna put a message on that interprocess communication bus within the browser. The browser is gonna actually execute the network request and it's up there sitting there and then meanwhile, the rest of your program is just going on, right? It's continuing. So these don't, these don't block, they don't stop you from continuing to do your, your, uh, execution. It's just that at some point in the future an event is going to occur where the response comes back, um, and at that point when, when that happens, the XML HTTP request API will execute on ready state change. Um, because it will have been put into our event queue and at that point, um, you'll your logic will be executed here and you'll say, oh, it's actually 4, and it will update the HTML. So what this, what this code does is it makes the request, um, but then when it gets the response, it will, um, actually, um. Just take whatever this Canterbury.ac.nz webpage. HTML. It's just gonna take that and just shove it inside of this, this div right here. So. The resulting page will be a little thing that says example data returned, and then you'll see the, the Canterbury uh web page underneath it, right? Um. So, um, that's basically like the raw XML HTTP request API, but obviously it's very, it's not very nice to work with, so that's why we use kind of newer libraries that are built, but all of those are just built on top of, of this, and this is the thing that is like, you know, essentially the underlying aspect of how browsers allow applications to dynamically make make requests, um. All right, so, uh, there's lots of events that HR can have. So in that code example there was absolutely no error handling, but in fact, of course you could maybe you get an error, you know, maybe something happens, maybe that you make a request and you don't ever get a response, so you need to handle a time out, um, so we only use this on ready state change, uh, callback, but you could define callback functions for any number of, of these different things, um. So, uh, As I said, the, um, oh, let me do the time, the um. The XML HTTP request is not really about XML anymore. It's very misleading. You can trieve lots of data other than XML. It works with other protocols. It doesn't have to be HTTP. In fact, it doesn't even need to be asynchronous, um, so you know, the, the idea of, um, asynchronous JavaScript, um, it's not really. A requirement although you really should make it asynchronous if you don't make it asynchronous what would happen um so that would be sort of like if you put it in a weight keyword in front of the, the call, uh, then your your application would essentially be frozen and halted waiting for the, the response to come back from the server and the user would have no ability to interact in any way, um. Now there are browser differences, but for the most part this is kind of legacy stuff. um, it's not as big of an issue as it used to be in terms of incompatibilities of different browsers. I mean, Internet Explorer, we still talk about it but nobody uses it anymore really, um, but they had something else that it was called X domain request. But if you, if you actually, you know, you don't need to use XML, um. Uh, HTTP requests anyways anymore, and what you should do is use some abstraction. So use something like Axios or the Fetch API, uh, which is now pretty standard in browsers, and that's what we in fact use in the labs. Um. All right, so, um, I will pick up where I left off tomorrow. I'll talk about fetch, uh, and then we'll we'll talk a bit, get a little bit deeper into some of the other kind of security issues and considerations when you're trying to make requests for data, um, from your, from your single page application. All right. um, thank you.

SPEAKER 0
I is that I s OK Um You. Yeah. It. OK Yeah, I'll come to the lab I. Yeah Yeah for the for one of the stories here

SPEAKER 2
for register um it says optionally they can um like provide a profile picture, is it necessary? To put in the Oh yeah, I'm saying that the

SPEAKER 1
user has the option to do that, not that it's optional that you implement the user story. Oh, right, because the user can just create an account without uploading an image. Yeah, that's right, yeah, yeah, yeah, so that's what it's meant that's what the optional um just the register page

SPEAKER 3
when we're like creating users and like checking email and password. For that you check on the. like enough pass it back in. Um, well, you could get the response, um, but it's

SPEAKER 0
probably best to just short circuit that needs to check to make sure it's long enough, because then, yeah, because basically. Yeah.

SPEAKER 1
The way to do it. So I mean one of the things we just when we do the test. Um, you know, if it looks like it throws a

SPEAKER 0
weird error or something like that, that's not really satisfaction. Excuse me, I you can just go ahead and, you know, just stop them from giving thinking a button or something, you know, if it's not valid if that makes sense, like you can't. Thank. So I

SPEAKER 0
I just there but they haven't actually. So it's like And We end up in 6. This I. Which And No, no, it's actually it's. I've done to psychology. You put me on if it's OK Yeah No Yeah.

SPEAKER 1
All right, uh, welcome everyone, uh, so. Are there any questions about anything before I start? OK, um. I've had a few kind of stray questions about the assignment too, just about clarifying a few things. Um, one thing that I would. Uh, I mean this was a general question, but if, if you're going to build the application in such a way that like you are going to. You know, like if, if there's uh if there's situations where you need to like make a request to the server and you know it's going to fail, um, it's probably better to do that like on the on the front end, um, so what I mean by that is like if you're say you're like, uh, putting an email address, uh, and it's not a valid email address then. On the front end, you just don't even allow them to click the register button or the update button. So you kind of prevent the, the case where you make the API call to the server and it sends back an error message and then you handle the error message on the client side if that makes sense because you already know that the input is invalid on the client side. So in other words it's sort of like what I was talking about um towards the end of term one where when you're doing kind of validation you can you do it both on the server and the client side I mean certainly the the server shouldn't you know rely on the client, um, having done that but you know in this case it will kind of prevent a round trip, you know, network, uh, trip from the client to the server and back again, um. So, uh, just in general, that's better user experience all around, um, every time you do that. Um, I think that was the only like main thing that I wanted to highlight. Um, OK, um. So yesterday I was talking about um making requests um from your single page application so that you can get more data and so underlying all of this is this uh XML HTTP uh request API, um. But when I was sending, I was talking about how. Rather than, um, kind of using a raw XHR request, um, it's better to use some kind of abstraction library, um. And in particular nowadays with um more recent versions of JavaScript, um, you're probably gonna want to use the fetch API although there are other libraries like Axios which uh have similar capabilities. So, um, sometimes people prefer to use those, um. So the fetch API is a little bit different from sort of the prior, um, libraries in that it's kind of native to the JavaScript API as of 2017. Um, sorry. Um, so, The the JavaScript, uh, API gets continually updated with those new versions of ECMA crit and at some point they introduced the, the fetch API and so now it's implemented in most browsers, um, and it's effectively, I mean, the you, you could call fetch as a function you pass in the URL uh, in this case it's a relative path so it could be a relative path from where, wherever the current, um, website is or it can be. Like a full path, uh, you know, like an HTTPS slash da da da da da, and it returns a promise. So because it returns a promise, you can then call the then function on it or the catch function depending on whether the um promise is fulfilled or whether it's rejected. So in this case, um, you know, you would put in the callback for then some kind of callback function that takes the response as the parameter. And you would do whatever you want, uh, with the response. And then, if there's an error, for example, you get a 500 level error, there's a problem with the server, uh, then you can just handle um the error and do something with it. Um. Uh, please note that like, um, also here you're just getting some JSON data. So I mean it's, it's, it can be any kind of information, uh, that you want that you're required for your, for your application to run from back end, um, so. This, uh, link is to the Mozilla documentation. Mozilla has a lot of really good, uh, web documentation in general, um, but they have, um, the docs for the, the fetch API and they have a list of all the browser compatibilities. So most modern browsers now have the capability of it, uh, working, so you can pretty much rely on it. Um, Because it returns a promise, then of course, it will also work, uh, with, um, you know, async functions and the awake keywords, so. You could have something like an async function to do some Ajax, some asynchronous JavaScript, and inside of it, um, you put your fetch in here and you can You know, make sure you know, if you need to do something with the result and instead of like trying to put like a, a call back in the in the then function, you can just wait for the result. So in this case, it's fetching the, the file, it gets the result and then, um, that's becomes synchronous and then you can take the text out of the result and put that into a data field and log the data, um, and, um. When you use the asyncwa kind of notation, instead of using a a then and a catch, um, callback function, you just use the trib block, so everything in the tri-lock it, you know, you can kind of order what you want to happen and if at any point there's an error, then you just handle the error outside of it. Um, and then, of course, you can call this from somewhere outside in your in your program. Um, So it's pretty nice, uh, pretty easy, a lot easier to use than the XML, uh, HTP HTTP request, um, and you know that whole whole process. I mean, you know, really, uh, beneath it all, it's, that's, that's what it's doing it's the same process as that other one. You just don't have that kind of fine grain control. I mean, I suppose if you really wanted to know things like exactly when the headers arrived and then when you get the. You know, the response, the full response, and all that sort of thing, then you would still need to use the HTTP, um, I mean, sorry, the XML HTTP request. All right. So, um, so you could fetch, and I've kind of already talked about how in the browser you have all of these different processes and each, um, Each of the, you know, tabs is gonna be living in its own process with its own render process. And when it makes a request like this, it will kind of push it onto this. Uh, into a process uh channel, um, and where the browser itself will send off the request when it gets the response, it will then push it into the event queue, um, and so how does it handle all these overlapping requests? Well, it really all just comes back to that original idea of the, uh, event queue that we talked about in in the first, uh, term. So this is really, um, just a redrawing of that, um. Just from the kind of the perspective of, you know, you have your application, they're gonna request some input output, um, that, uh, is basically that gets put into, um, in the browser something called an event the multiplexer. So basically it says, OK, there's a bunch of different things that we need to handle, um, uh, different events, um. And uh at some point the browser like once, once like it has that, that, that, um, multiplex you're sitting over here and it has to deal with kind of like sending off different events so it's handling the network requests some point it gets a response, um, when that input output like completes, uh, the event then gets pushed into the event queue. So you've gone, uh, in, in the previous, uh, slide I showed that we had that little section down at the corner was where all the JavaScript is happening, um, so. And here your application that's in the JavaScript engine it like goes out of that goes into some other part of the browser that's handling these kind of, uh, network requests. Uh, at some point it gets the response and then it goes all the way back down into that little box, um, where the JavaScript engine is and it finds the event queue, uh, for that and it just pushes sort of the event in saying, OK, we've gotten. Now an event of of a response and then if you recall, uh, when the way that the JavaScripts works because it's single threaded, it will, um, just wait until the stack is empty. The stack gets empty, it takes the first thing off the event queue and then makes the the next, uh, function that it's gonna call. Um, so. The handlers the callback function that you, you kind of, uh, passed in when you first made the, the request, um, so it has that, um, the event loop gets emptied and then JavaScript will just run the handler, um, and it runs to the completion until the next point at some point later it has to do another, uh, input output request, um, so. This will allow for multiple overlapping requests because what happens is you can make 1234 requests, you know, for all kinds of different files and it's really on this space over here the browser's handling like all of these different operations it knows exactly what kind of handler function you're going to attach into each one of those things. And once it gets the response, it then pushes it into the appropriate event queue for kind of the appropriate render process, um, and, and depending on, you know, so for example, if one render, uh, process and like a tab has multiple requests going out, um, whenever they come back in, they just get shoved into the event queue. And at some point the JavaScript engine says, oh, OK, I'm ready for the next to pop the first thing off the event queue and then it, it runs it. So, um. It's, uh, the, the key here is that you know it's, it's really relying on this event queue to have all of these different processes happening but it's sort of like from the perspective of JavaScript it says oh you something over here is gonna handle that it's just gonna let me know once it's done and I'm just gonna at some point check to make sure that it's done, um, you know, by peeking into this event queue. Um, if there's nothing in the bank you, well, I guess it's not done, right? And so a key idea here, um. Is that um this whole model is one of concurrency, not of parallelism so um there's a distinction between the two. concurrency is the idea that you can have multiple executing processes, um, that kind of don't interact with each other, um, that's different than parallelism, which is where the executions are actually happening. Uh, at the same time, so you know, the, the input, the, the, the response from some network request happens, uh, in some order as they come in, but the from the from the JavaScript engine perspective those things not it's not operating on any, uh, more than any one event at any time at any given time. Um, so you're dealing with lots of different things, but you're using some kind of data structure, this Q data structure, to manage that. Whereas with parallelism, You're actually doing a lot of things all at once. Now if you take a bigger picture, step outside of like, you know, just the, the one process, the render process, and the JavaScript engine, obviously the browser itself, um, is possibly doing things at a parallel level because it might be running different processes on different threads, um, so there's like a mix of of the two, but from the perspective of of like. You know, your individual application, it's really just kind of handling all of these processes, um, happening, um, and, and organizing the order in which you're going to take care of them, um. So it's just a fine distinction, but it's uh it's an important one because I think, um, uh, you know that it was actually kind of an interesting thing when no JS first came along, um, on the server side, you know, it was kind of people just assumed JavaScript could not possibly be a web server, uh, because it was single threaded, um, and what they found is that actually this concurrency model works very efficiently. Um, so you don't actually need to have, um, kind of a parallel processing multi-threaded, uh, computation in order to handle lots of different things happening at once, and part of the reason why that works, uh, well in this case is that if you think about it like events are happening. And those events take time so they can't be blocking, uh, you know, so I can make a network request, you know, from the perspective of your, your computation that's an eternity, right? Like it has to go and send, you know, something along the uh wire, you know, maybe bouncing off some satellites, who knows what and gets a response that comes back like that's an eternity in terms of like your CPU cycles, right, um, but. That's all happening, um, sort of outside of, you know, what you're doing and, and you, but you can still do many different actions, but those actions have been kind of at a much slower pace than, um. Than what your computer is capable of of handling, right? So, so what this means is like, you know, if a user's going to click on buttons and doing things and making lots of requests, uh, you know, you can order them all together and it can handle them very well because in the scheme of things those events are actually much slower than the. Ah, then sort of this the pace at which, um. Uh, the event handlers can, can run, you know, if the event handlers themselves were, um. We really high compute and, and, um, taking up lots of time, then, then you would have more of a problem but because that tends to be pretty small, uh, in terms of the gaps between the events that are happening, a concurrency model works really well. Um, So, um, But yes, it is distinct from like parallelism where, for example, you have a high comp high performance computing environment and you just want to like split some job into across 1000 cores and run it really fast. So this is a different model of compute. Um, Uh, all right. So, um, any questions about that before I move on to the next thing? All right, so, um. The next thing that I wanna cover is a concept called uh cores or cross origin resource sharing um so we've talked about how a single page application take get some HTML, um, and then it will have some JavaScript and the JavaScript will execute and at some point it may request additional resources, right? Uh, but. You know servers, uh, like, like for, for various kind of reasons you might wanna limit sort of who can like what what kinds of um applications can be um can access information from what servers right? um so courses is effectively a way to kind of set up a policy on the server side. Uh, saying that I'm going when, when, when somebody's like for a browser is something's being executed and it wants to request some resource like it wants to get something or wants to post something, um, then the, the server will send back some information saying, you know, whether or not um. That uh is allowed or not and so essentially it sets it in as headers in the HTTP that could set back so um it has these special named headers like access control allow origin, access control allow headers and various parameters that you can set uh to those uh and so. Well, um, so of course has some, some, uh, has a reason for being sort of from a security perspective, but it's also something that you can sometimes find yourself kind of banging your head against the wall a little bit because what what it is the browsers will enforce cores in a way and if you don't like uh set it up accurately on your server side. Uh, then you're gonna get strange errors when you try to request additional resources, um, perhaps from a different origin from what you requested, um, so what I mean by that is if I, you know, I'm loaning example. HTML, but I want to, um, you know, access, um, you know, some resource. If if I'm going to example. HTML and sorry example.com and it has a particular IP address, but then I want to access an image file from or some other type of file some JSO from Ben.com from the same page. That's a cross origin request. So I'm, so the original web page is, it's example.com. It's coming from a particular IP address, but I'm requesting other, uh, resources from somewhere else, um. So, in our server implementation, I'll just show you this quick. Uh Um Yeah, OK, here it is. So, um, This is the reference implementation for assignment one, inside of the boilerplate code that we gave you, um, if you look under source at middleware, there's this, uh, file called Cosiddleware, and this is where, um, we set the course policy for your API. Uh, the bottom line is that we, we allow you to sort of make requests from all over the place, uh, to your, to your, um. Uh, to your server, your API running, otherwise you would be getting error messages if you tried to run this, um, from certain environments. Um, so we just set that up for you because we, we, we're gonna explain that to you at that point, but now I'm gonna come back around and so now you'll actually understand, you know, what, what these headers mean and what the purpose of, of putting this in, um. OK. All right. So, Why do we need course? um. So Uh, One, particular reason why, uh, it's there and why it exists is something called cross-site request forage forgery. Um, so essentially, um. Uh, you could, uh, send kind of fake client, uh, requests to another application. um, so you say you have some external website, um. That somehow uses some stolen credentials about the user, uh, maybe it's the off token or something like that. And so this other website at some, you know, arbitrary IP address decides it's going to use these credentials to pretend to be the user and that user, um, you know, could then make requests. So what you wanna do is you want to prevent that you wanna essentially say that only certain requests from certain IP addresses. are allowed to use, um, you know, to make this kind of request. Otherwise, the request is rejected. So, if, for example, I would um do some kind of get request that has the credentials alongside as an off token um and if the course policy is such that it says that that what it's coming in it's a match what you have um in that policy, um, it's the server is gonna send back some um special headers back to the browser to tell the browser that this is not allowed to happen. Um, and so that's called the, um, the solution is essentially that by default there's this thing called the same origin, uh, policy which means that if you, uh, make a request, uh, then you know to get some other kind of resource like some JSON, uh, from a server by default if you don't set up a course at all, um, the browser will only allow you to make, uh, those requests to the same to to. Um, a server at the same origin or some resource of the same origin. So, you know, it has to have the exact same, uh, uh, start to the path. So I'll explain what that looks like exactly. So, There are a lot of, uh, everyday and legitimate cross-origin uh requests. So here's an example in the workflow. So, say I'm a user. Here And I'm working inside of the browser, um, so I make, uh, an initial HTTP request for www.first.com. So I'm gonna go to this website and that's gonna return some HTML, uh, inside of it, right? So the HTML comes back into the browser. The browser looks at resource A this what this HTML is, and it's parsing it, and inside of it it has an image tag and inside of that image tag, the source of the image tag, the source attribute is actually an HT. TP request to a different server. So it's to www.second.com, and it's actually an HTTP request. So it's a port 443 instead of port 80. So you make the request, uh, it, it gets that image from a different server and it comes back with the response. So this is totally like legitimate, right? You want to be able to embed images into your HTML that have a different, that come from a different source from the original HTML, um. So that's legitimate, um, but, uh, for security reasons, uh, like let's finding an image tag, but, um, browsers will restrict, uh, script tags, um, so anything that's gonna have your JavaScript code inside it. It restricts the way that they can make a cross origin uh resource request, um, so by default you can only make one of these XHR um requests uh can only be made to the originating origin or the same origin as the resource that is that you originally um received so. For example, I go to a URL and inside that URL it makes a an HTTP request for a JavaScript, um. Content or you know, and uh that's at first.com that gets back something inside of a script tag inside of that script tag I have an XHR uh like request. I make one of those like sends to say or I make a fetch something like that, and I make that request to get an image file from a resource B and at this point. Um, what happens is if it sends that back, I mean, so the, so the, the domains are the same. The only difference here is that it's inside of a script tag now, um, that will, uh, what will happen is that the, the. Uh, server, well, uh, it's going to send something back and and the browser itself is going to say no, you cannot, um, this is not a an image um this image resource I'm not going to give the application access to um. So, It's so when you're sending and receiving resources, there's like many different web applications uh that have to load resources from separate domains. So these are like CSS style sheets, images, frames, video, and so on and so forth. But what we're really interested in is cross domain requests, in particular these kind of, uh, in XHR requests, um. Those ones are by default forbidden by the same origin uh security policy so any requests that happen within the script tag cannot by default, uh, make a cross origin request. um, so you might ask what is a cross origin, um, well. Sometimes you wanna be able to do that so um so first off let me explain what course is so course it's basically a way for the browser and the server to like work together uh to determine whether or not some application that is running inside the browser is able to make a cross origin request so. Basically there's the standard HTTP headers um which basically allow the browsers and the servers to talk to each other um and to access um certain URLs only when they're given uh permission to. So in other words these these headers are for talking between the server. And the browser, the browser will actually strip these headers out before they pass on uh the information into the application. Um, so. Basically, some kind of authentication happens or some validation of like the request happens on the server side. The server sends sends back the headers that say um these are the acceptable origins so the server will send a response no matter what it's just telling the browser whether or not it's it's only telling the browser what the rule is and then it's up to the browser to actually enforce and honor kind of what the restrictions are of of those headers. So in other words, the server like that setting that was in the server is just some information that could set back and then the uh when the request gets returned to the browser before it even passes it on to the to the application and puts it into the event queue and all of that, it looks at those headers and decides, am I going to allow this to happen or not. Um, so in other words, the application itself has no responsibility here, um, uh, in, in this, it's always, it's all down to the browser to prevent the application from doing something. So what's what it actually is a same origin, um, well, it's really made up of, uh, the basic components of sort of the beginning of of the URL. So it's the to have an identical origin, you have to have the same protocol, the same domain, and the same port number. So in other words, um, if you have HTTP, which by default is in port 80, and you go to example.com. That is different from all of these other examples. If the protocol changes but it's on the same port, that's a different origin. Um, if the, obviously if the name is different, it will have, uh, be different, um, but also if the port number changes it's different. So this is actually, you know, this can be quite a problem, you know, even for testing things on, on local hosts. So say you're running your server on local host, you know, I don't know, 3000. And then you have your, your, um, you know, web page on localhost 480. Those are not the same, same origin. So if you, if you're trying to request things, um, you know, maybe if you have other things being served even on local hosts, you'll get an error message inside something like Chrome. You can open up the console and see, you know, if it's not working, it'll say, you know, this resource was blocked by by the course policy. Now the course policy that we happen to put into the API just is a it's a star one so it's sort of like it will accept everything, right? Um, so it's basically saying anybody can request, um, uh, resources from us from any origin. Um So the headers that get sent back, so this, you know, you make a fetch request the browser sends that off to the server and the server in their response will add uh some special headers, um, and the headers cannot actually be uh manipulated uh by the client. So it's a, it's a what's called a forbidden header, um, so there's these different head, you know, we've we've already seen different headers. For HTTP, well, there's a there's like a category of these headers that's forbidden to send. Like if you try to make a request for the application and you try to set these headers, uh, the browser will essentially, you know, send an error, uh, but the example of the type of forbidden headers are things that say access control something. So for example, access control origin or access control headers. Um, origin it's another header, so that's basically the header that's sent by the browser to the server like it when when you make a request to a server, the, the browser adds in an extra header it says origin and and there's like a number of other ones as well, um. So, so these headers, uh, kind of, um, basically allow you to set up the rules of how, you know, what your server is saying is, is legitimate. So we, if you look in that API, we have something that looks like this access control allow origin call and star. So that same way will allow a request from any origin out there. Um, you can of course add specific ones that you want, like you can say, I will only allow an origin, a particular origin, um, maybe HTTPS food.bar is the is the only one that's allowed to request resources. Um, you can set particular methods saying I only want to allow post get an options HTTV methods, so if they only tries to send a delete, uh, method, then it fails. Um, you can, uh, set other kinds of parameters, um, so for example, how, how long they're, uh, allowed to have, uh, access to, um, this is like in 86.4 seconds, um. And like if you want to to send uh cookies um but you don't use this then then you can do that there's like like there's a lot more more to it um like a lot of different options. So, so in this example from from the API, you know what we have is access control allow origin star. Um, we, uh, allow certain kinds of, uh, headers, um, and, uh, we allow certain methods get post, put and delete, um, to be, to be done. Um, So, um, Now, what happens is something like this. So, if I'm making a request uh for a resource A, So I make the HTTP request to Foo.com. Foo.com has the script, uh, this JavaScript that I want to run. Um, I get the response from that. Inside of there there's an XHR request. Um, so, uh, inside of that, it's gonna make an HTTP request to, um. Uh, to, uh, bar.com and when it does that, so you make the request, so you say like I wanna fetch this thing, the browser takes that like sticks in an extra header called Origin and adds in the origin. So note that the origin here is this original domain. Um, this is, this is the origin for this request, um, right, so it takes HTTPS food.com because it knew that the, the kind of the, the script that made the call came from that original origin. So it adds that in. And, uh, resource, it, you know, the the server will just process the request as is, um, but then it will add in any course headers that are there and so it might say access control allow origin HTTPS.com that goes back here and the browser sees oh yes in fact that matches the origin uh that I set and so then I have a. You know, it's OK, so I will take that image and do whatever, you know, whatever the script asks for, um. Uh, so if it's like an anything, uh, origin, I mean, it's, um, basically it would just look like this. So instead of having a specific one, you know, this is just like I don't care, anyone can use my, um, uh, use my API from anywhere on the internet. Um, then, you know, this follows the exact same process, and it adds the origin, it selects the image, but in the response, it will add in this header, and the browser will just treat that, it will just basically say, oh, they will accept anything, so it doesn't matter what the origin was. Um. All right. So here is an example of something, uh, that's a request. So, uh, the beginning is the same. So, I'm going to go and make an HTTP request to Foo.com for some JavaScript. I get my response. Um, inside of there, I have my XHR request, uh, that then says, oh, I want to make an HTTP request to bar.com. Um, the browser adds in the origin of HTTPS.com. The server responds. It sends back the image, but it adds in this header, this forbidden header access control allow origin HTPS boo.com. And when this happens, then it, before it goes into the application, the browser. Um, will say, oh, I'm not, I'm gonna block this, and you'll essentially see an error message show up in the console if you're in Chrome or something like that, but it will say it, it won't, uh, get the request, so it'll be from the application perspective it looks like nothing happened, um. So, um, that would be a forbidden one. Now, of course, um. You know, you can, you can do things outside of a browser so you could create your own browser that doesn't enforce the responsibilities of the browser, um, so it could basically set various forbidden headers in a way that fools the server, so it's like pretending that the request is from a location that it wasn't from. So in this case, you've made this request, but when you do this, the, the, you know, the fake browser in that spoofs the origin and does something else, um. And, uh, you know, then it goes like this so you know, and that could be like maybe you accidentally downloaded some nefarious browser or something like that. The point is here that it's actually the browser responsibility. The, the idea is that you are using a browser that enforces cores. It's not the server, it doesn't have the job of, of deciding whether or not to send the response. It just sends the rules. So this the argument here is that you should be doing things inside of a. A browser that you know has uh follows the course policy um. So there's a really, really nice worked example on all of this, um, in this, this, this is a free book called uh courses in Action. You can find it online, um, it, it, you know, I've kind of gone through these examples, but it allows you to kind of, uh, go through them in a little bit more detail, um, but it's essentially about creating and consuming various cross origin APIs. Ah, so, um, and it's just the very first chapter, um, and it's free book online, um. So, uh, I recommend taking a look at that. All right, so That's course. The last little thing that I wanted to talk about and well it's a, it's a little thing sort of, but I mean in, in the, in the context of the course because we're not gonna be, you know, implementing the assignments, but there's, there's some. You know, a fair bit, uh, to it in terms of actually implementing it and that is, uh, web sockets, but before I do that, I mean I just wanna ask if there's any questions about about courses and sort of how it works and what the responsibilities are and so on and so forth. For whatever reason, I find chorus is something that can get kind of, it's a bit like confusing and and not a little counterintuitive, um. Uh, but, um, yeah, I would just kind of work through each of those examples and make sure you understand like why or why not things are getting, uh, rejected and then, you know, the important thing actually is here is that the origin comes from the original source. It's not, it's not what you're, it's not what where you're requesting, you know, the, the next thing and it's also not, um. Yeah, so I mean, it's, it's, it's the origin of, of the script that's making the execution. Uh, that's, that's the the key thing. Um, All right, so I wanna talk about, uh, webucket I only got a few minutes, um, so I might come back around to it, um, actually, uh, next week just to finish it up, but, um. So the whole time in this course we've been talking about. Uh, essentially, uh, HTTP, right? Um, I mean, we, we talk about making requests and those requests are, um, you know, you, you make a res a request and then you get a response and it kind of goes back and forth like that it's stateless, um, and you know, you know, that's it. But um that's that's fine you know for making kind of like one off requests for resources um but sometimes you wanna build an application where uh there's lots of information flowing, you know, back and forth between the client and the server um and you also want something that is going to be um. You know, potentially where the server has the capacity to push information to the client, not only just respond passively to any kinds of requests coming from the client, um, so the server should be able to push, uh, to the client, um. So, so something with HDHP and using Ajax to make these requests is fine for this because it's like this one way direction of communication. Client makes the server, server makes the response. It's stateless from the server perspective. It's every new request is a brand new request, um, but it's, um. What it what it doesn't do is persist or create any kind of ongoing two way communication. It has no state between between the two, whereas a web socket is a mechanism to do that. You essentially establish a web socket connection and then you have that connection and, and then the clients and the servers can each send information, you know, each way so the server can decide to send things every second towards the client once the connection is made. Uh, for example, um. So, um, so HTTP and AX is, it's less efficient than web sockets, but it's, it's more for kind of making one off things and if you do need to get regular updates, you need to manually kind of implement some kind of polling mechanism essentially I'm just going to have a time out and I'm gonna ask the server every so often, do you have something new for me? Do you have something new for me? Do you have something new for me? Every time you do that there's a back and forth heavyweight kind of exchange across the network. Uh, with a, with a web socket, um, it's a lot more lightweight because you once you've established the connection, then the sending of the information back and forth is there and ready to go and so it's really, really good for like real-time communications, uh, things like games, uh, things like, um, you know, just, uh, you know, you're, you're in on some kind of like social media and you're getting updates, uh, regularly, uh, things like that. So, so web sockets are quite, are quite, uh, powerful, um. Essentially, you know, the difference is that like with a polling mechanism, um, the client makes a get request to the server, you poll and you get the response then you make another get request and you pull and you get the others. So the HTTP requests, you know, there's just gonna keep happening over and over again with, with a push, uh, thing, essentially you, there's an initial get request to sort of set up the connection. But that at that point there's a web socket connection and you've made one request and the server can just periodically, you know, push, push, push up information, um, so there's kind of a, a handshake mechanism that occurs so essentially you know everything starts with HTTP. Uh, in the browser, um, so you have to make an initial request to the server. It's a, it's a get request, um, and inside that get request you're gonna make a special, you're gonna have some special header that says I want to upgrade this connection to a different type of connection. Um, so when you make the get request, uh, the server then responds with some piece of information that says this is what you need to establish, uh, a connection to my socket server, um, and then. The client sends, uh, uh, something with a header saying connection upgrade and it's the connection then gets upgraded to a socket connection and then at that point um you can just use the web socket, um, uh, message passing, um, so. There's like a handsha mechanism where like you make a request, um, say this is like you've got some chat application and you're going to serverexample.com, uh, you add in this connection, excuse me, connection upgrade request, so this is in the headers. Uh, you have your, your upgrade to a web socket and there might be other information available that you, you want to send, uh, that, that gets sent over there. Then the response comes back, um, saying that we're switching to protocols, um, we're upgrading to a web socket connection, and we now have this, uh, chat going on, um. All right, um, I think I'll stop there. I have, um, a little bit more information I wanna show you about like what those headers actually like like once you have this, you're no longer sending back and forth these um these HTTP messages with the headers and bodies you're sending a different kind of payload entirely um there's like bits that are encoded in a particular way for the web socket connection. So I'll, I'll go into that, um, just to show you how that works, um, and then I'll show you a simple example of how you can add a web socket connection using a library something like Express, um, which we use for the API and you know, there's a, there's similar MPM library you can just install to establish, uh, the kind of connection. All right, um, but that's enough for now. Any questions real quickly before we wrap up? Oh, OK. So I'll see you, uh, next week and good luck with the assignment. I'll also talk a little bit more about the testing of the assignment next week, uh, when we get back.

SPEAKER 0
All right, thanks. Not OK. Well, I'm not. OK. Yeah The Get too hot so it's like the lights on. Yeah Yeah. I gotta do it to put my band down. Which that's why I asked permission. I don't I I didn't hear that. So Yeah. But I think it was I Yeah. it You So That's. I. Yeah. No. No. Yeah. My So Yeah And. Yeah. 1.5. You just wire I, I know I like the the as well. Yes. I hay Not

SPEAKER 0
I I Well I I'll tell you But Today it's like literally the. Do It's like Yeah Mhm.

SPEAKER 1
But All right, apologies again in advance, I have another cold. Seems like the semester of colds. But I'll do my best to, uh, Try not to cough too much. What's going on OK, so. First things first, um. I have uploaded a um. An old exam, uh, but it's from a couple of years back now. Because it was the last time we had paper exams, um. But it's, it should give you a sense of the. Structure of the exam, the types of questions you have, with the caveat that you know some of the material is obviously different. So for example, the exam covers view instead of react. So point being that the content is really to study in what's in the lecture notes and the lab notes, but now you have like a structure of what to expect in the exam. Um, Uh, I will talk next week in more detail about each of the topics. I'll do kind of a review session to highlight exactly kind of the kind of things that. Uh, we're covering an exam. But You can find it here. Um, So under course information, there's a sample exam. Um, so like I said, it's a couple of years old, so, um, Pretty much the structure is the same like in the sense it's gonna be just a series of questions of short answers type. There's not like no like longer answered things or anything, but essentially being able to look at some things like HTTP requests, interpret them. Uh, look at JavaScript, look at React code, interpret that, uh, that sort of thing. There's not coding exercises. There might be a little exercises where it's like you look at something and you might need to say, uh, what's wrong with this or what might need to change in this, that kind of thing, but nothing like where you're actually like have to develop if that makes sense, um. And then there are some general short answer questions on basic topics, you know, everything from like the event queue maybe, um, in JavaScript, uh, to questions around, uh, data persistence and so on. So some of them were conceptual topics, but all kind of shorter answer, you know, no more than like a sentence or two type of answers. Um So take a look at the sample exam. Um, I'll cover that again in more detail, like the actual exam topics, uh, next week. Um, the other thing is that the Obviously the um assignment is due, the second assignment, so I, I just got an email. I just saw it. I haven't responded yet, but the question was why is it doing on Friday instead of Sunday? Well, the reason for that is because I need time to prepare, um. I need to get um. Basically anonymize all of the assignments that come in and do the assignments out to people because effectively what we're gonna do is in the last week we're gonna run tests where everybody comes to their lab session for whatever reason you can't make it to your scheduled lab session just come to a different one, but it's best if most people go to the ones that they're scheduled for so we don't overload the labs. Excuse me, uh, so. Uh, basically what you're gonna do is you're gonna download. Um, you know, a zipped file of the submission, um, that's anonymous of somebody else's, you're gonna load up the local like the server on your local, um, computer in the labs you're gonna load up. The application uh that they that somebody else built and then you're gonna run through a series of sort of basically tests where you follow exactly um some kinds of user stories that match the user stories that we had in the requirements and all you do is you're just gonna basically like say it did this this work this didn't work, that kind of thing um. And so the idea is that everybody's gonna get at least 3 different people testing, you know, your submission, um, so on the first hand it's not going to be kind of, uh, you know, just based on one person's arbitrary thing so of course if things don't align or match, um, then that would be, you know, highlighted and singled out and then also. Um, you know, we'll do additional reviews, so it's don't think that your mark is entirely being, you know. Done based on, on your classmates, um, and, and what they, what they do, um, so. Let me pull up the slides. And I will, um, Show you a little bit more what that kind of looks like, although, um. It's an example from last year. Right Well, actually, hold on. Alright, so before I show you that, just real quickly, I mean, the topic this week is gonna be on uh. Some new items. Um, around, uh, web application development, the first of these is web storage. So this is storage on the client side and progressive web apps, um, which is sort of the, the next stage from kind of, you know, building a web application to building a web application that actually behaves the same as a regular desktop application and so progressive web apps, we're not gonna be building any of them here, but. They are sort of how we get to the point of like building something like a web application like you build an assignment too, but making it something that behaves essentially like an application on something like a mobile phone or something like that. Um, So, but coming back to assignment 2. So, a few different things, um. First off, in the submission requirements, um, you know, it's, you can if you wish, of course, put it up, use and get, but it's different from. Uh, the, uh, last assignment and that you are submitting up to learn so learn allows for, uh, attachments up to like hundreds of megabytes, so it should be fine. What you need to do is, um, zip up your project and please use your, your user name as the zip file name. So, like your code, you know, like your, uh, three letter, not, not your, sorry, not your ID number, but uh, you know, like mine's BTA 47 or something like that. That's it. And then please also when you upload. Uh, delete the node modules folder before you do it. If you, I mean, I think it probably would be fine, but it's just gonna make it a ginormous download because the, the, the node modules folder is, you know, like hundreds of megabytes sometimes. So. Um, if you just upload the code itself. That's fine. Now, We've had weird things happen before in the past where people upload the reference server, uh, API server with their um. You know, front end code, the react application or other kinds of strange things happen. So don't include any of that, just include the react application. Um Don't include the server code, um, because, uh, we'll just have everybody to just downloading the same reference server when they go through the tests. And so basically, the way it's gonna work is everybody's gonna be in the labs. You're gonna have a sort of an identifier to say, uh, you know, download these three zip files, um. So you'll download the zip files and they'll be on like Dropbox or something. Um, you'll download the latest version of the server. Um, it might be a little bit different than the API reference. We'll have the instructions all there for you, um. And then for each application, you're kind of could go through a step where you reset the database, you run reset, resample, not, not using Postman, sorry, um, using the Bruno tests. So, A reset and resample, um, and then. At that point it will just install and run the client side application, um, you know, MPM install and run, and then they're gonna, you'll open it up in Chrome. So if you want to make sure that your application that you submit follows the steps that somebody can. Uh, just run NPM install, run it and open it up in Chrome. Then that's good. I mean, there's always like weird things that pop up, but. We'll all be there trying to help you out, you know, as you're testing if for some reason the server doesn't start or something happens with the configuration. Um, There's a little bit more that we that we will, uh, talk about in terms of, you know, where you install it like if you're downloading 3 projects and just, um, installing it, it's better to use the local drive on the lab computers so the local drive is the actual hard drive in the machine rather than your home directory which is in the network drive, um, that will just speed things up for you when you run the tests, um. So, um, Then you will run the test. So the tests, this is a um sort of like something kind of like what it looks like, it'll just be a Google form, um. This is a different, you know, site, it's not for the game review site, but there's a similar sort of thing. So, it'll basically. You know, give you an action to do, um, and the action should match something that's in the user stories, and then there will be just you just kind of click it should do this or that or whatever, you know, and usually there we have more options in this in the actual tests. But, but that's effectively the way it's gonna work cause everybody's gonna fill up the Google forms and we'll get their results. Um, OK, any questions about any of this before I move on to the rest of the stuff? No, um, OK, so we do, um. Need to get the assignments by the end of the week because, um, we have a fair bit of prep stuff that we have to do to kind of make sure that tests get all, uh, in line. Uh, so that's why we have the deadline on Friday, rather than sort of Sunday, um, right before the week starts, because we have to do some stuff over the weekend, um. All right. Um, so, So this week, um, we're gonna cover just, uh, a, a few different, uh, topics related to storage and, uh, the progressive web apps. Excuse me. So. I'm gonna talk initially just about web storage. I'll, I'll, um, talk about a type of database that you can actually run on the client side and you're when you're running your application. So we've had databases obviously in the back end for a server, but you can also essentially store a small database inside of the browser now. Then we're gonna, um, I'm gonna go into cash storage and progressive web apps. These are actually related to each other. So cash storage is actually a way to sort of cache websites for offline use and so it's one of the technologies that helps us build progressive web apps because we can they are essentially web applications that can behave somewhat like desktop applications. So just to give you an example, like if you've ever used Google Docs, um. You will probably see that um like have you ever like opened uh something offline you don't have internet connection you can still open the web page and edit the document of course it's not getting uploaded to the um. It's not getting kind of uploaded to the changes um to a server until you reconnect but the application doesn't like fail to work for you, right? And so, um, cash storage is used for this and it ties in it's like one of the key elements of progressive web apps. There's another topic too that um I cover called Service workers. So, um, so far, you know, in terms of web application development, you're essentially building. An application that has a user interface uh and it then has a state but then it maybe goes and you know makes requests to back end server but in fact you can also have other services um that that sort of run in the background and so these are essentially kind of you can think of them as a kind of application in the browser but they don't have a user interface at all they're just there. To kind of, um, do some kind of work, right? And that could be for any kind of thing that you might imagine like it could be, um, like heavy compute type things or something that you need to run sort of in the background without. You know, interfering, you know, with the, the, with the kind of application that you have in in the browser and so servers workers are a part of the technology that's all embedded inside of, inside the browser and then finally I'm gonna talk about web assembly so web assembly. Like all, all that we've talked about really, um, this semester has been about using JavaScript. As the scripting language and the browser and for many, many years that was the only option you had you could only write applications using JavaScript. But uh with the web assembly, essentially you can use all kinds of other programming languages and uh and compile code that can run in the browser. You still need to use JavaScript, sort of for the base script for like a, like in your HTML page, but that JavaScript itself can invoke some, uh, web assembly code that's compiled from another language like C or whatever. Um, So all of these things I'm gonna cover, um, just kind of talk about them in together and sort of bringing them all together. They're like kind of part of the tool kit. Excuse me, of modern, uh, web application development. So, uh, web storage, so. Excuse me. Apologies about that. Um, so for web storage, um, There's really 3 key pieces to it. I mean, I mentioned index database, um, we'll get to that last, but then there's also session storage and local storage. You will have already come across local storage, uh, in the context of, um. The labs or where I think the, um, the zoo stand gets backed by, by local storage. Um, I'm just gonna talk a little bit about how it's used, um. Just in generally, so. So the question is sort of like, you know, imagine you have a web page and yes, you obviously can store data in the back end of your server and you can make a request so you can either request, you know, make an API call that will go to a database or you can request like something like a JSON resource or something like that. But. Maybe we want to have data stored inside of the client computer as well. So lots of benefits to that, right? You can not have to make a round trip, uh, request, um, and, you know, maybe you need to store data between sessions, that sort of thing. Um, So, we've already seen one way to store some type of information on the client side, and that's cookies, but cookies are very limited. So, uh, cookies are really limited to about 4 kilobytes in size. So, You can't store any kind of, you know. Anything of, of, of, of, you know, significant size there. And the idea of the cookie is you actually send it to the server with each request. It's not really meant as like a storage unit for the client side application. With HTML 5, they've introduced web storage which allows about 5 megabytes worth of storage for an application. Um, so that significantly increases the size of information that you can store, and it really depends on the browser implementation, how much exact size that you get. So, there's two types. There's uh local storage and session storage. Um, they're really there are advantages so that they've got really nice kind of API easy to use, um, flexible, they're in no way more secure than cookies in any way. They don't like add some secure layer or anything like that, so that doesn't have any benefits on that, on that side. It's just like a way to store more information, um, so. What is local storage? Well, local storage stores permanent data for your site. So there's no expiration date, um, and it just stores the data in key value pairs. So they're both strings, right? Super simple. So, they, you just have two functions, you have a setter function and a getter function. So, if you say local storage set item, key value, these key and value both could be strings, and then at a later point, you can get the item out of local storage, um, and you just pass in the same string, the key as you had before, uh, and you get your value back. Um. So I just So if we go into a browser here, um. And I go to Develop our tools. Then I can just say local um storage. That set I hate um. My OK And then it's Value or something like that, right. Um, so I've done that. Now, if I go into the application tab, you can actually see the local storage is here, and you can see the local storage is attached to the domain that I'm at example.com. And you could see it's got um my key and its value. So I've stored it here. Um, if I um close this window, And I just go back. Do it again, so I just sorry, show that. I just reopened it. If I go back to the developer. Tools. You can see it's still here. The local storages has lived on. I closed, I closed the, um, window. I reopened it, um. And so the browser knows that, um, example.com has this key in value. Sorry about my voice. Um, OK. So that's local storage, and you can then access it, um, in the console, uh, just by saying, you know, console.log, something like local storage, oops. Local storage. Get item. Uh, and. And then it wrote out its value, so it works, right? It's easy. And so in the in the um Uh, in the labs, what we did is we just backed the Zooa store with this. So every time we wrote to Zooan, it would automatically use local storage to kind of pack it up, and then it can read it by default from the local storage, um. So it's a way you kind of have persistence between different uh sessions in your application. Alright. So, um, yep, so that's an example. I just kind of went through it, um, but yeah. So the other thing that you can do is you could, you know, since, since different browsers might have different implementations, I think most modern browsers now have local storage, but you never know. Maybe you're dealing. With an old browser that doesn't use local storage, or you're running your script in some weird environment. Um, so you can check to make sure local storage exists or not. Uh, if it does, then you can just call that item and get item just like I did there for. Oh, So, um, what you saw with Cyan, it's kind of like this. I mean, essentially, it's just building kind of a wrap around it. So, um, When uh we read a collection right here. Uh, from local storage, um, basically when it's created, when the zoo stand store is created, it first tries to get it from local storage, uh, it looks in the key collection. If that doesn't exist, then it will just give a, an empty array as a result. And then when we call set collection, um, it sets the state but then it also calls the set local storage um function in there, uh, and, uh, calls, um, basically passes in whatever it's doing. So, so essentially when the collection is set in Zoo stand it also updates local storage. So you basically just have a wrapper for the getters and setters um into local storage. Um, so we build it that way, then your application will persist data essentially. So but you should keep in mind if you're gonna build your application like this, then that means anybody who has access to that computer can obviously go in, look in the developer panel, look at the keys of values so you don't want to be storing secure information here in some way, right? Or information that you don't want to persist from one session to the next. Like you would never put a store a password in plain text here or anything like that. Um, so there is session storage. So session storage is, it's exactly like, uh, local storage, but it's, uh, temporary in the sense that it only lasts for the session. So as long as long as soon as the browser or the tab is closed by the user, it will disappear, um, but it's in all other ways it's exactly the same. In fact, I, I seem to have messed up this example here, um. The, yeah, so you could just have the session storage store the data. This should be session storage here. Oh no, sorry, I, I'm I'm forgetting my own example. So you're saying hi, and then you're getting from local storage, um, and then here you're getting from session storage. So, And this came way, it's kind of combining the two. But it's not, I mean, it's essentially it works exactly the same way. It's just that the browser enforces how long that the data lives lives for, uh. All right, so local storage and session storage is super easy to work with, um, simple, um, it's a nice way to store information, um, that's not that you don't need to see secure, but the way you wanna kind of just keep, you know, know about the user, um, I mean you basically use it in an application like, like you could either map keys like the keys themselves could have some kind of user identifier in them so that like say. You might want to store information about different users, um, you basically have to encode that into your key as a way so that like when you're reading your key, then you're using some kind of user, uh, ID, you know, concatenated with whatever the the other key is that you that you want for your application. So you bring those things together, but um. But yeah, I mean, if you are going to have user information sitting around in the browser, you have to be kind of careful about that. So, um, But this is, uh, you know, sort of how, how the computers know that you're, you know, already logged in on certain websites, right? You close your browser, you open up Gmail, right? If you're still logged in, you know, between sessions, um. And they're using this kind of storage to to enable that. So, there's also index DP. So, what is indexDP? Well, um, Uh, it's just, it's, it's basically a web API that's built into the modern browsers, so you can create a no SQL database like one of these key value databases, but it can be indexed, you know, so you can actually create indexes on fields so that it's efficient and to search on values and that sort of thing. It's also has a much higher size limit than either local or session storage. Um, it's really. Browser dependent, but I mean it's at least 500 megabytes, so you can. Store a lot of information, you know, in the database uh for your application and in fact it's, it's just like a database and that you can kind of create different stores of data they're independent of each other so they call these things object stores in there but it has like a lot of the nice features that you would expect of a database that has primary keys you can index, um, you can do the crud requests so that's the create. update and delete requests, and they all have, um, it, it can all be done asynchronously with promises. So you basically make a crud like a create a request and then if you have it in an async function, you could do it in a weight on that, that sort of thing. It also follows course which we talked about uh last week um so the same origin policy essentially what this means is that you know to access one of the index databases um you can only do that from an application that was from the same um. The actual the same origin as we define for with cos last last week. Um, So yeah, so it's basically like, you know, it's like a database management system, you have one or more databases, and then inside of those databases, you can have one or more object stores. Oh So, You can also, uh, like, um, you know, for to create one of these, uh, databases in the, in the browser just like I showed with local storage, you can, you can inspect it inside the developer tab and you can see. You have the origin, um, so this is the origin of the website that created it. Um, you might have a database and then you have, uh, object stores, and then inside of the object stores, You can have different uh indices and so. Uh, here is an object store where you have keys, primary keys. Um, and value, and you see the value just looks like a. Um, Kinda has a, a new sequel, um. Like Jason style, uh, view to it. So you can see you have metadata in here you've got a name, author, so on. And so these indi indices are, these are kind of like building an index, you know, all across these various uh fields that are available in your database. Um, this allows you to do like queries that are very efficient if you have a large database you could search on name, you know, matching name or author or something like that, um, quickly. Um, so it's all kind of inspectable inside of. Inside of the browser. So, um, The object store itself is conceptually quite similar to a database table, um, but it is no SQL in the sense that it doesn't have like a, it's not a formal relational database it's more like a a JSON, uh data so you have different records. A record is like a JSON object, um, and then you've got like keys and values that go on it. You can create the indexes on the object stores. And then it has a transactional model. So you basically execute a transaction on the database, either to read that is like query the database or to write some new piece of information, something similar to like an update or a delete or something like that. Um, So You basically open up the index database, uh, indexDP is just provided inside the, inside of the, um, system. So. Uh, like if I, if I. You could see I just took the index TB and it's a um. It basically has, it's an object that I can call various methods on, and one of these methods is the open method. So this, you call this function as a way to open up a database. Um, so, Um, you basically open it and then you define various callback, uh, functions on it. I'll show you an example, a few examples, you know, in a moment. Like, so, for example, you. Um, when you open up the database, then it might, you know, there might be an error that happens when you try to open the database and then you wanna handle that so you define a callback function for on error on success means you've successfully opened the database. So that means now that it's opened in the callback, you can then, uh, execute your various transactions that you want to do, you know, like update some data or something like that. Uh, and then there's other callbacks like this, um, this one called an upgrade needed that was executed when a new database is first created. So that's where you create a new, uh, object store. So like when you first create your database, um. And, and, uh, you basically create a a a new database. So, you, you can also have versions of databases and, and so on. So let me just uh show you. Yeah, so it kind of looks like this. Um, so, uh, if you want to, um, open up, uh, a database, um, it would be something like you would first check whether or not an index database exists in your application. Um, you know, if it doesn't, then you can't use it, but otherwise, you might open and you pass in the name of the database, um, and this is, uh, a version number of the database, so you can have different versions, um. So this returns a promise. So you could use the await syntax here. So you could say, so that that return for the request is actually gonna be a promise type. It's not going to be, uh, the open database. So if this was all in an asynchronous function, you could say a wait for the database to open and then do something. Uh Uh, Oops. So, so here you've, you've defined your quest, right? Um, and then because that request, um, The result of that you can then um handle basically define your callback functions. So like these are the ones that I was showing before like if there's an error, then you just would come right up to the console, oh, there's an error um with their database and you print out the error code. Otherwise, if it's a success. Then you can put the the the event uh object that's passed into the call back, um, inside of it, the event.t target that result that result is the database object that you can then use to execute various transactions on your, on your database, um, so. Uh, and here's an example, an upgrade needed. So this is, um, like we're gonna get our database the same way as before. Now we're gonna create an object store called Contacts. I'm gonna pass in some. Um, you know, uh, some properties of that, so it's gonna be an auto increment too, so it's gonna have an auto incrementing key. So we create a new store, and then on top on that store, we then not going to create an index. And so that index is gonna be on the email, uh, field. Um, so this is essentially saying that, um, You know, every email send in some properties has to be unique, um, and, uh, so then we have an index on there. So. This way we're basically saying. We're going to create a database of contacts. Inside of that, there's gonna be various fields. There's no sequel, so it can, some, some instances can have, uh, fields that other ones don't. But, um, If it has an email field, the email field has to be a unique. If you try to add 2 records with the same email, then it will fail. Um, so this is kind of how you create a data store. And then, um, before, I mean, here. This was the autumn success, so this is where you actually do the transactions. Here's an example of some different things you can do so. If you say like you've got your database, uh, then you can start to call various functions. So here you can start pulling it apart and making, you know, helper functions. So in this case. We're gonna create a helper function called Insert, uh, contact. And so we have our database object, um, and that insertact is going to then Take the contact in the database as parameters. We're gonna create a new transaction, so this is just kind of initializing the transaction. Um, we're going to Get the contact object store so we we have our, our, our transaction, um, and basically we're gonna say what we're interested in looking at is contacts then, um, we're going to, uh, put. Um, the contact that we're searching for, so that's this object, uh, into, um, the store. Um, if it's successful, we're going to say it's OK. If it's an error, we're gonna lock, it's an error, and then at the end, once everything's complete, uh, we're gonna close it. Um, so essentially what this is doing is this is. The store put, you know, once we've pulled out the object store we're done putting in our, our contact. So effectively you can kind of populate a database, you know, this way, um, you just need to like because everything's kind of done with promises you just have to handle it with with callback functions but you could all do all this, um, probably easier like if you use the weight uh async a weight syntax, it might look a little bit, um, nicer, um. So that's um more or less what there is to index database. I mean, it's just a very simple thing. I mean, you don't. As you can see, you're just passing in objects like any uh JavaScript object can be passed in, um, and that's just this put call can take that in so it is really a no SQL database in that regard like there's no schema, there's no like defined columns and all that, um, but because you can build indexes and that sort of things you can build like kind of more structured rules on how that's supposed to look and how it's supposed to behave. All right, um, I think um I think I might just, uh, I know we're a little bit about 8 minutes early, but I think I'm just gonna stop there, um, just because I'm. Losing my voice, um, but I, and then I kind of pick up on, on the cash, um. Uh, on how, how to do cash storage and how that ties into progressive web apps tomorrow. Um, but any questions about anything that I've covered so far? No. OK. Uh, thanks, and, uh, good luck finishing up the, uh, second assignment. Um, if you have questions, I mean, probably, you know, the labs always get kind of busy in the last week of the assignment, so. You know, feel free to send emails, um, and I guess one other thing I should mention is that, you know, just because I know I get emails I get a lot of emails and I got a lot of emails for class and I get a lot of emails for other things and sometimes I miss emails, so don't feel shy about sending a follow up email if you don't hear from me. Um, I should have probably said that in week one, but yes, no, just, just, you know, don't, don't feel like you can't kind of spam me. That's totally fine. Um, make sure I actually get the email. All right, uh, thanks everybody, and I'll see you tomorrow.

SPEAKER 0
Right. Different yeah.

SPEAKER 1
Um, it's fine. It doesn't really matter so much, yeah, just so I mean, I just want most people to go just because I totally to keep things from getting overloaded, but yeah, that's fine. Yeah, yeah, sure, yeah.

SPEAKER 0
Uh Uh Oh kind of a, um, how does the website. Oh, right, um, so, um.

SPEAKER 1
I mean, the purpose of the assignment is not really, I mean, you're not meant to be designers, right? It's mostly just about um whether things make sense sort of from a usability perspective like if they can follow through the user stories and and it kind of follows. I mean, so, so like the vast majority of the marks is on that. There's a little bit of like a general, you know, I get people's feedback on like, you know, usability, you know, you know, score of 1 to 5, that kind of thing, um, but, um. Yeah, the vast majority of the market is just on kind of the, the actual functions can be done, um, and then I give a little bit of ability for people to comment essentially on what they see as the creativity involved, uh, and sort of the design and development of it, but, but not like I mean I don't, you know, that wasn't what we taught isn't isn't about like doing CSS design or anything like that so that's, yeah, no that doesn't make a difference. It's more like. If there's certain things about the way things behave, so for example, like the log in log out, um, registering thing, if we're, if there's like weird bizarre errors that show up, you know, that seem for the user make no as much sense, you know, um, that might take you down a little bit on the usability scale that makes sense, right? Yeah, yeah, OK, yeah, yeah, yeah, but yeah, we're not, we didn't cover CSS design in this class, so.

SPEAKER 0
I try to make That's usually somebody else anyways in

SPEAKER 1
the team that does all that stuff.

SPEAKER 0
Yeah, being able to log out. Yeah, like how literal are the log. Yeah, like, is that acceptable? Are we going to be able to explain? It's the person reviewing how this stuff works and get Uh, no, but I mean, I think, um, I mean,

SPEAKER 1
I think if it's um.

SPEAKER 0
It seems pretty I think if you, if it's like

SPEAKER 1
sort of navig if the navigation to it is easy

SPEAKER 0
to find, um.

SPEAKER 1
Yeah, yeah, that's fine. Yeah, that's totally fine, I think, yeah.

SPEAKER 0
I P. What is your um. Yeah The uh I think it's it. Yeah Uh, tomorrow at 2 p.m. OK That That No. 0 to Yeah, that's that's right. Because I It's like I. And Yeah, because I don't think it's much better. But I I I I think we just continue to that. Because. OK. So I think to be that one. Yeah I the last question. It's I have to stop my couch. And I was No, I'm not I I. And then I was supposed to, but then I can uh so now I. like how OK, let's So And now that's how.

SPEAKER 0
I I just need All right, um, hello everybody.

SPEAKER 1
Um, so any questions about the assignment? Nope, OK, um. All right, uh, cool. So, um, yesterday I was talking about web storage, so I'm just gonna wrap that up, uh, and then go on to talk about, uh, progressive web apps. Um, any questions about any of the material that I covered? And I apologize again. I'm still gonna cough, unfortunately. So no questions. OK, so, um, we talked about local storage and session storage, um, and indexed, uh, database. So the last of the kind of web APIs that we talk about in particular relating to storage is the cash storage API. So cash storage API, um, is gonna be something that can be used in concert with. What we're gonna talk about next in terms of um the uh progressive progressive applications but um it's something that you can kind of use, uh, outside of that if you want to and so. Excuse me, cash storage is really about. Caching pairs of requests and response objects. So when you're doing an HTTP request, there's an object kind of representation of that request, and then when you get a response from the server, there's also an object representation of that. So in other words, um, you know, when you make your request to the server like your API. Instead of making the actual request across the network to the server, um, instead it could take that request in the in the browser and just look and see if there's a response already cached, in which case it could be, you know, just make that available to you directly and so there's really very limit little limit in terms of size, uh, for the cache so it can be hundreds of megabytes in size. Um, and it has, um, a pretty simple like API to it. You just access the cash, you say a thing called cashes. Should be available to you, um, like if the browser has it, um, and then you can just add to the cache like a new request object. Um, you can add multiple, uh, URLs, uh, you can, um, put, so this would be like, um. Uh, putting a, a new, uh, response in there. So basically what you do is you take your request and if you get a response from the server you can actually just push the um response directly into the cache, uh, and then if you want to. Sorry, um, retrieve from the cash, then you would just match against a request object, it would see if it's in the cash and it would get the response. Um, so this is super helpful if you want to. A kind of allow you to take your, um, you know, basically JSON or other data in your single page application that you have to make requests to if it's already stored locally then you're reducing the turnaround speed for that um and alternately, um. It also allows you to uh serve elements of your application offline, uh, which is relevant to the next topic. Um, that's progressive web apps. All right. So, progressive web apps, um. are essentially a. Kind of an innovation in sort of the delivery of applications via the web where you take something like a single page application that you've developed but you basically turn it into something that's installed on your device so that it acts as if it's a a native application on your device, um. You can do this on a laptop or a desktop computer, but it's also often used, um, in like a on mobile devices as well um so it begins its life as a browser tab so you open up a single page application and then it will prompt you to do something like it will install the application. To act like a native app, so you probably have seen this the times when you've opened up an application in your, um, on your phone and it says install the app, um, and so it relies on some other APIs and tools, um, so one of these in particular are service workers which I will go into some more detail in a moment and so the service workers, uh, like provide things like notifications, um. Like, so it allows something to be running in the background, get a notification, and that gets, uh, can, can get pushed into your application and it also, uh, can do background synchronization so it uses the cash API to sort of synchronize in the background and it and it will store, you know, either load some of the data or store like what you're doing in an offline mode. And, and sync it back up once it is connected. Um, so there's a. Google has some really good um information about this here uh if you want to look at it. So what are service workers? So service workers are basically little proxy servers that are running inside of your browser, so distinct from the server. On the, um, you know, that you sits on another server it's actually inside of the browser and it sits between the web application, um, and the browser and the network so you can effectively like run some JavaScript that sits there and you can access it. You can send requests to your service worker. Uh, it can make, uh, HTTP requests, um, you know, on the network. But it runs on its own thread, so it doesn't block anything that you're doing on your own, uh, kind of application and it is, um, headless so what that means is that it has no direct access to the document object model so it's just running some code it can make network requests it can run executions, but it can't manipulate the actual HTML of the page directly. It has to be done by the calling JavaScript that's in the browser. It calls the service worker. Service worker maybe does something and it sends a response. And so service workers always have to be, uh, run on HTTPS ser, um, uh, sites, um, for security reasons, basically, it's impossible. Like a browser just will not allow you to interact with a service worker using a, um, using a website that's on HTTP and it's, uh, associated with a specific server or website. Um, So in other words, your, your service worker's running and maybe he's running in the background, but it can only be accessed by 11 web application. You don't have like multiple web applications all sharing the same um uh service worker so. We'll come back around to that, but, um, essentially, um, to kind of motivate why we wanna use service workers and how it relates to this notion of a progressive web app, um. You, uh, you know, we could think about sort of the landscape that we're developing it now. So right now we've got many different form factors, um, we have, you know, large screen displays, desktop type situations we have laptops, we have tablets, we have phones, right? And you want your application to essentially run across all these different devices seamlessly. And so the one thing that all of these devices have in common is they have browsers, right? So um. So the option, you know, a clear option is instead of trying to build an application for all of these different types of devices you just develop websites um and then you have kind of a a way um to like take that website and run it as an application. I mean. You do have the option to develop a website that works in the browser and actually recode your entire application as a native application. So if you do mobile computing like you can write applications that run as direct applications just like you would run a a a normal application, you know, on, um, your file system on the laptop or desktop or. You can, uh, use what's called a progressive web app. So that means essentially you write one web app for all of the different forms and then it, it installs it and makes it act as if it's like a, an application itself. So, As a case study, um, well, it's not called Twitter anymore, it's called X and it's kind of gone completely off the rails, but back in the day Twitter was a really great website in some ways, and it was something, you know, that um people were wanting to use for um. You know, communication and and social media and all this sort of stuff, but originally, you know, they, they originally was uh an app that you would run on your on your computer but you know of course they want people to use social media on their phones and things like that and so originally on mobile they had a separate website for the browser and then they had an installable native app so you go to the app store you would install that, um, and so but Twitter decided to. Uh, migrate everything over to a progressive web app. Uh, on mobile in 2020 and they had some advantages for why they wanted to go for that. Uh, first of all, it was a much smaller size, um, so if you build an application to run in a browser, all you need, like you're not like, like all of the rendering code, all of the stuff that kind of comes packaged in a browser you get for free, right? Because it's there to run all kinds of different applications. Um, the JavaScript that you include in your application along with the HTML, I mean, that's gonna be a lot smaller in size than a kind of a full native application that's supposed to run with all of the UI elements and everything built into it, so it's much smaller. Another, uh, key changes that made it adaptable. So if you try to develop native applications for, um, the app stores. App stores, um, you know, uh, well, Apple is notorious for this, but, but also for the Google Play store you have to go through a whole authorization, um, kind of process, and if you are making new versions of a native application, it has to get recertified through that process. Um, it's easier with a web application because essentially the shell of it is the, is the app that's installed, but the internal, like the, the code itself is just the JavaScript that's running inside of a browser essentially. And so you can automatically update um it would in theory work for new operating systems should they come along if they support a progressive web apps and so and it was also just generally faster and more efficient because they had to develop one code base instead of many code databases so then it became essentially the Twitter app that you had in your phone that looked like a native app was exactly the same. The exact same application as when you opened up your browser on the phone and ran it or when you ran it on the, on the computer. Um. So What exactly is a progressive web app? So first of all, um, progressive web apps, it's not like a formalized term per se. I mean, it's the people have tried to formalize it and I'll talk a little bit about the technical requirements for it. But it really started through a series of, um, web blogs where people were talking about, you know, how, how we're gonna build new applications across different devices and so this link here. Is one of the first ones to really, like, itemize what it is that makes an application. What are the criteria for a progressive web app? Um, and so they, they came up with a number of criteria. Apologies, I'm just gonna drink some water. I, I know it's not pleasant to listen to you. Sorry about that. So, um, They, uh, these, these criteria, um, were essentially kind of like. I mean there you kind of think of it is a bit like the different between kind of like marketing an idea and like some like real uh technical thing, but they go through and kind of define these these different um uh criteria. So the first thing. Uh, is that they said it should be responsive. So when you build an application and for it to be a progressive web app, you want it to be able to fit any form factor. So it should fit on, you know, a large screen display, it should fit on a small little phone and so on. Uh, it should be, uh, connectivity independent. So what this means is that. Um, for it to be a progressive web app, it should use service workers that, um, allow the application to work offline in some way. Um, this is sort of done in the context that, well, if you're gonna have applications on phones in particular, you know, especially back in 2015, you know, signal might be spotty or maybe you're in a part of the world where you don't always have, you know, high speed. Uh, you know, unlimited data in, in like, you know, in, in some situations, so you want your application to still work, uh, you know, you should be able to open it and it should start, um, and then. So it should be able to work offline using uh service workers to, to help with that. Um, The, the next thing was called app like interactions that they talked about and so. This is where they talked about it you should uh you should basically design uh using something they call a shell, uh, plus content application model. And so the idea behind this is that. You basically want um yeah, the image of it. Let me just pull it. Uh So you should essentially have your application, you know, load up quickly, um, and, and, um, in a way that like the user sees the application and they start that almost immediately can feel like they're inside of the application without being relying on sort of the, the kind of the content itself to be filled in from the network or something like that. So in other words you design your application have some kind of shell and maybe it's like a a header or some kind of frame to it and then the content then fills in after that um and so this is sort of from a usability perspective you're not the user is not waiting there for the whole application to load up the, you know, you get this kind of application kind of feel uh immediately, um. So All right, um, So the next thing, I mean, and like I said, this is a little bit like a marketing type language, but they said it has to be fresh, um, so. Not only should should service workers be used to make it work offline, but it should also have uh service workers that are kind of working to like seamlessly update the content uh in other words, you might have information that's sitting, something that's sitting in the in the back end, um. Like a service worker sitting there getting updates and automatically update the view, you know, based on things, kind of pushing information into the user. Um The safe criteria really refers to the fact that it has to be done using HTTPS. I mean that's just. Sort of standard, um. The idea of discoverable. Uh, relates to, uh, a, um. That basically there's. And I'll talk about this in a moment like from a technical perspective there's sort of a manifest file that goes that goes alongside the application and that that manifest provides material that kind of surfaces up your application and makes it available to things like search engines and so on, um. And Re-engageable, that's really the, um, comes down to the idea that, um. There should be ways to sort of um hook into the device and it's ability to kind of get people re-engaged into your application and so what they mean by this is like things like push notifications you know if. Uh, if you are, uh, on a, on a mobile device, for example, you can get notifications that will pop up, um, indicating there's a change in the status of your application, um. That's been adopted now more in operating systems on on desktops and laptops uh uh but essentially you should kind of hook into the operating system provided, you know, mechanisms to kind of re-engage the user into your application, um. Uh, the installable, um, and this is a key it, um, it's just, it's the idea that You basically at first access the application to the browser, but there is an option to install it so so like on your device it will show up as like a home like an icon on your desktop or something like that um and then finally linkable uh relates to this idea that. You have um Uh, there, there's a, if, if you take the mobile course we'll touch on this topic again, but like linkable means like you can use things like hot links which where where you essentially provide ways to hook directly into some internal state of the application, uh, via like hyperlinks, um, so the idea is like I should be able to share a link on social media or something. And that will kind of open up the progressive web app and not only will it open up the progressive web app on like the home page, but it might take you to some, you know, internal uh page on on within your application specific to the link that you have, um, so they talk about this in the blog it's all kind of like general criteria for for progressive web apps. There was a follow up a blog um that kind of. You know, expanded upon this, um. And uh they tried to make it a little bit more uh concrete, um, you know, but then they talked about like good to haves for progressive web apps, not really criteria, but these are things that you would expect um them to have. They should be have a mobile mobile friendly design, so the different form factors. Um, sure, you could write an application that can run on all kinds of devices, but partly because it's a web application, you can do use things like, uh, CSS to target the form factor exactly so that the design, you know, if it, if it detects on the screen of a, you know, small size, it should automatically reconfigure the user interface, uh, to match that, um. It should have near instant loading, um. And they define this in the blog as interactive in less than 5 seconds, uh, before servers workers installed, um, and once the servers worker installed, it should load in less than 2 seconds. These aren't just arbitrary numbers that this blog writer had come up with, but it's, you know, it's like a, these are guidelines, um. Where the service workers is essentially the, the system behind the scenes that's managing, you know, loading like the cash off the cashed, uh, version of the website, uh, and things like that, um. For off, you know, so that you can access offline, um, it should in theory work across all kinds of devices and browsers, and they put a number of 90% of the users in the market and then finally they just talk about how it should also have fluid animations, visual transitions, all that good stuff, right. Oh Now, all of that's fine, um, you know, but, you know, there's some interpretation, I guess, about all of those things, um. There's a slightly more technical definition of a progressive web app. It's the same article. They kind of talk about it in technical reasons. Uh, but The definition is that first of all. Uh, it must originate from a secure origin. So this is when we talk about course and it's the same idea of an origin, um, that definition, you know, the, the protocol, the URL, the port, that's the origin, right? So it has to or originate from a secure origin. In other words, it has to use HTTPS, um. It has to allow for loading well offline. And it has to reference something called a web app manifest. So there's a particular, um. W3 specification defining sort of a manifest file that that is it comes with your application, um, and it's, it's a JSON file, so. I think this link should work. Yeah, so, um. You could see here it's uh it has a very it's a this is an example of a manifest file um and the the manifest gets linked inside of your um HTML so when people first go and open up your web page that manifest file should be there and then different um like devices that are progressive web app compatible like all of our phones and everything like that, they will read that manifest file and know how to interpret it, um. Based on the content and so it has things like uh the name of the application, a short name a um so this is the name like these are like the I think the short name is like what shows up maybe on the um when you put the install the app um on the uh on the device, um. It has things like a start URL. So this is like the URL that the application should connect to, um. You know, once it's installed, it should have an icon that's at least 144 by 144 pixels in PNG format so it has to have all this information in there and then what happens is that the device knows how to like create what looks like an application to install on on the on the device. Um, so right, yeah, here's a. Example, within HTML that you first go to the web page too, it has a link tag, and in the link tag, um, it says, it has this REL, um, attribute. It says the manifest. And then there's a link to the actual JSON file, so that will get pulled. It's just like if you have a CSS file or some other thing um that's linked within your HTML and then inside of it, um, you have all of this uh information. And so, Like you might have a a weather app inside of that weather app you have different, um, icons that are available at different sizes so you might have larger icons for like a device that has really high, you know, like, uh, I don't know, you, you've got like these Apple screens, right, that have really high resolution and so on. So you can, uh, have a 5512 by 512 icon, um, and, um, it has a start, uh, URL oops. Um, in, in there, it might have, um, defined specific shortcuts that allow into your application in a particular way, um. Uh, and so on and so forth, uh. So, so the manifest file is what the, what the um. Device uses to sort of make it installable but those manifest files are also scraped by by web crawlers so that when you make your application available it it scrapes out all of that information and makes it available in search engines and so on, um. So I've talked about uh service workers, um, being a part of this, um, so a service worker, um, is some JavaScript, uh, that just runs in the background like I was saying, um, and so it's, it's not like it's not specific to. To progressive web apps, I mean it's, it's used in progressive web apps, but it could be used for all kinds of other things as well. I mean just any kind of service you want to run, um, that's like a long running process, but it needs to be started and registered by a web page so you open up a web page and then it will start up a service worker, um. But it effectively allows websites to run offline, um, because the service worker can, can serve the cache data. So you use the cash, um, API. Really sorry, um. you take the cache data and you, um, you know, that API you make the calls from the service worker, um, and it, and it will load that. So basically, the application will interact with the service worker which, uh, gets the cache data. So it can basically interrupt and take over, um, or, or interrupt like a request for a data outside of your. Uh, like on the network instead the service worker will serve the data instead, um, and it has to work over HTTPS. So basically service workers have a life cycle, um, first of all, you know, so you build, build an application like it's JavaScript and it's going to start up a service worker. Well, first it needs to install the service worker. That will either be successful or not. If it's not, there's an error, and then at that if it's uh if there's no error, you go to an activated mode. Um, and then it will kind of go into, uh, potentially an idle mode, um, where it might get terminated or it will continue, maybe it will fetch things, um, and, and send messages. So, um, you know, you can, you, you can basically fetch information from your main application. So here's like what registering looks like it's, you know, you don't need to remember all of this, but it's mostly to give you a sense of how I go like what the. Concretely, how do you, how would you actually go about doing this in your JavaScript? So, so here you're inside of your. Your normal JavaScript application and so what you need to do is say I want to register some service um. And so, um, first, uh, it's basically asking if the service worker, uh, whether that's possible within within the application and so what it does is it calls this register function and it passes in a JavaScript file so that's the service worker JavaScript file uh that is being. Uh, that's being sort of loaded or or registered by kind of the, the home application. And in there you pass in a scope so basically you wanna define OK maybe the service worker only has a certain scope of what of what um you know like it's only allowed to to kind of access um files within this uh SW test subfolder and then you know uh basically um. These are just uh. Um, sort of giving some logging about like what, what's the word, what's the registration status, um, the maximum scope that you can give to a service worker is the scope is the location of the worker itself. So like the worker is gonna sit in some, some folder and you can't give it like you can't go outside of that, but you can scope it down to be uh more restricted. So, So, here, this is This is registering the service worker. SW.js file. Now, if you actually look inside of that, uh, service worker, um, then you can, um. Have um Essentially, um, building, uh, event listeners which will, will kind of handle, um, you know, handle, uh, things like, uh, you know, when, when certain events happen to the service worker it will then do certain actions. So, um, so here we're in we're we're installing it well you know we're trying to install the service worker from the home, uh, kind of JavaScript. And here we've added an event lister to that install event and when the, when the install occurs, what it's doing here is it's going to. Uh Execute this function called add resources to cash um so what it's doing is it's going it's actually trying to get a whole bunch of uh different uh files uh in there um and serve them all in as the, um. Uh, you know, basically add these to the caches API, um, so that they're available to be served offline, um. So, um, then what you can do is you can fetch, um, data so like when you make a fetch to the network you can have your service worker be listening for those fetch events and essentially intercept them. So when you made a fetch to get some JSO data from your API instead of doing that, um, what happens is the service workers kind of watching that and it grabs the fetch event. Um, and it, it says it's going to match, um, and send back, um. This is that cashless API that I talked about before. It's that's a a response object it's going to resend that back into. Uh, you know, essentially it's going to serve up the, the response object from the cache instead of, you know, allowing the browser to make the request out to the network. Um, so this is kind of a visual. Um, sort of, uh. Visualization of the steps, so it's like the service worker, um. Like, basically, it's going to uh register, um. The service workers registered and so when you want to look up a a page that's under the scope of the service worker, um. If you try to make a fetch, the service worker's gonna hijack that request, and it's just gonna respond back, uh, with this respond with back to the page and this this connection never happens. Now if the data is not cash, the service worker makes the request, um, to go onto the network and gets it and then it but and then at that point cashes it, right? So that's effectively the way it works, um, and, um, you know, I can, um, I'll share you with you on learning you can see sort of some code examples of this, um, but, um, you know, I wouldn't expect you to, to know, be able to put it together we didn't obviously do anything like this for the assignment, but it's like if you want to, uh, in, in, in general like I'm just want you to understand kind of the general kind of. Pieces and how they and how they fit together, um. So, So when you build a progressive web app, um, then you can obviously use web storage in lots of different ways because it is a web application. It's living in a browser. Um, so you can use local storage, of course, um, you can use index database or you can use the service workers and the cached resources using the cash storage API and that kind of works together. Um So that's progressive web apps in a nutshell. Um, I'll, um, share that example like that actually this example here, um. This one here, uh, with the Star Wars logo and so on, that's, that's from, uh, an example, um, where the code's all available on a standard tutorial. So I'll, um, I'll share that with you all so you can try it and run it and see how it works. But effectively what it allows you to do is to. You open up the web page, um, and it's gonna serve some images, like some Star Wars images, um, based on the network request to the server and then it caches that, and then you can turn off your. Turn off your network, um, connection. Reload the page and it will show that it will reload the images directly from the cache and it and it works. All right. Um, if you're interested in. Progressive web apps and that sort of thing, you know, you might want to continue on, uh, and, and take a mobile, uh, application course like that that we can look, talk about some of those topics in more detail. Um, so that's progressive web apps in a nutshell. The last little topic that I wanted to cover, um, sort of to wrap up, uh, these things was web assembly, but maybe any questions about progressive web maps before I, um, go move on. No, OK. Um So the last thing I wanna talk about is web assembly. So, um, because this is something that is growing in popularity in web development um. And probably in sometime in the near future we should probably add it directly into some of the assignments as well though if you're interested in this topic, um, I do cover it in a if you're around in 4th year I teach in sort of an advanced web computing course where we go quite a bit more in depth with web assembly but effectively what web assembly is is it's a way to run code that's not written in JavaScript but in any language that can be compiled to web assembly, um. In a browser, um, so essentially what happens is you take, you have some binary code, um, which is pre-compiled to a format called web assembly, and, um, it can be C, C++, rust, um, there's something called assembly script you can write go go laying code so you can write all of this kind of code, um, and code that is potentially much faster than like interpreted, um, JavaScript because it's compiled to bytecode. Um So it will usually use either ahead of time or just in time compilation of the browser, um, ahead of time means it's actually compiled it's, it's compiled into machine code, uh, before you run it, uh, just in time means it's compiled, but then it's there. I mean just in time is sort of how Java works, um. But effectively there was like a whole history of like ways to speed up, you know, web, uh, computation. In the browser there are lots of different uh versions of this um but finally people settled on web assembly um and so now it's a W-3C recommendation and pretty much browsers implemented now um it can be used as a supporting technology also for progressive web apps, but it's really designed for any kind of high performance, uh, web page because effectively you can write code that would be, um. You know, so for example, like C or rust code, that's extremely fast and efficient, um, and run it in inside of the browser. Um, so. There's lots of different applications where you might want to do this. I mean, for many things it's fine to use JavaScript, no problem. I mean it's pretty it's pretty efficient, you know, when you're dealing with interface type things but um you know lots of other things you might want to have, um, use of awesome for these are just a bunch of examples I'm not really gonna go through them all, but you know things that have. A lot of compute like visualization, simulation aspects of games with lots of assets in it, um, image, video editing, um. Also another thing it's, it's useful for, um, things related to like encryption and and security related stuff because one of the issues with JavaScript is that it's a garbage collected language so. If you're doing something, say, encryption, but you don't want, um, you want to kind of make sure memory is cleared immediately after you run the execution, you can't guarantee that with JavaScript because it's garbage collected and you just don't know the garbage collector will just run whenever it runs and so if somebody's inspector inspecting the memory somehow of the computer, then they could potentially steal information, whereas with lots of application. Um, you can zero out memory and things like that because you can write it in C or something like that. So there's lots of different reasons you might want to use WOM. Uh, for lots of different, uh, things. And maybe you also just want to build in a different language, um, you know, like maybe you want to use existing libraries from, uh, like C or Rost or some language like that. Um, but generally speaking, you know, like things like simulations and visualizations, that sort of stuff are the kind of things that people often, uh, will use, uh, web assembly for. So effectively, the way it works is that you just write your source code in whatever language you do. And then it compiles it to a binary format and then there's a wassome engine, so there's an engine that executes the binary with that's built into the browser itself. Now there is an intermediary text format that you can compile to. It's not really used to execute the code, but this is just for debugging like if you want to look at it, but effectively you can see it's, it's sort of like um assembly language type of thing. Um, but, um, it's based on a, it's a got a stack architecture, so instead of having registers for, um, the way that like, you know, like chips, um, like if you, I don't know how many of you took like any assembly language, but like with assembly language at the low level like you have different registers for your chip like your um your intel chip or whatever but with web assembly it has a stack based um register so it just means you, it pushes and pops values off of um. A stack, but that's neither here nor there. That's just about how it, how it works, you know, deep down like if you actually want to look at the code, but the bottom line is that you have a compiler, uh, for the language that instead of compiling to machine code. On your machine you're you compile to web assembly, uh, binary instead so the target is different. um, you're not compiling to like, like Intel or AM uh CPU you're compiling to web assembly and then this web assembly gets, uh, downloaded along with, uh, like your JavaScript and it can get executed within your application. Um, There's, uh, so, so in other words, like to, to, um, if, if you're interested in doing more web assembly and you're around next year you can take my, uh, it's, it's a special topic it's COS 473 but I we have a whole assignment using web assembly and all of that, uh, in there, um, but. Bottom line is that you know web uh technologies now like the client side even though I introduced it at the beginning like as HTML, JavaScript, and CSS, um, in reality it's, uh, much more than that now, so on the first hand like. Inside of um. The browser, it will run some, it will run JavaScript, that's for sure. Um, and, um, it now can also run, uh, web assembly, but as a developer, sure you might be writing in JavaScript, but you can also you might be also writing in TypeScript which gets compiled down into JavaScript you might be compiling. JSX for, for React, which also all gets compiled down into JavaScript. So on the browser, it's all being, it's all running JavaScript. Or you might be writing C or C++ code, you might be compiling it to web assembly. And running that as well and so that all runs in the browser, um, and then meanwhile like with CSS we didn't actually go into this and scores, but you know CSS is the style sheets but um there are kind of, you know, kind of newer uh versions of that that compile down into CSS which is run sort of in the, in the browser. And then when it comes to content itself, I mean this is also something that we um. Didn't fully cover, but you know you have HTML but there are even things where you could do things like write and mark down or something that gets has a preprocessor that gets compiled to HTML. That's passed on to the browser, but then, of course, now so much of the code itself, um that is um. You know, sort of generated might be JSON data, CSB data, who knows what like it could be any kind of data. So inside of the browser we have JavaScript web Assembly, CSS and HTML, um, but you know, as a developer, your landscape of like tooling and everything is much, much larger on, on the other side, and it all kind of just gets smooshed down into technologies that can themselves be run inside of the browser. Um, and then of course, uh, you know, once you're in the browser too, you know. There's all of these, these web APIs that are available for things like storage and, and so on and so forth. So Uh, I think that that's good for now. I'm, uh, I think I'll, if I keep talking, I'm just gonna cough and cough. So, um, well, we'll stop, stop here. I'm gonna end with some a few more, um, topics covering some of the things related to, for example, uh, how bundling works and other things, uh, next week. Um, and, uh, and then also kind of review over like everything that we've talked about and covered in the course. Oh, and the last thing is for the, um, for the assignment, yeah, like I said, please come to the labs next week and, um, we'll have all the instructions and everything when we get there and we'll, we'll all be there to help out.

SPEAKER 0
All right, any questions before I finish up?

SPEAKER 1
No? OK, um, all right, have a great weekend and hopefully, um, everything goes well with your assignment, um, you know, send us questions, email, email questions or ask the tutors, uh, if you need help with anything. All right, thanks.

SPEAKER 0
OK. Uh Um, just wanted to follow up in terms of like. Go on Resources Uh, well, I put an example. In previous years I know, OK, yeah, I put that up there, um, so that's the first step. So that's, that's a, it's diff like, so, uh, it's the format, so you have like, you know, it's all the short questions you can kind of see how there is that thing, um, but just so you're aware, I mean you can see like it has the example of the exam we use view instead of react. So just yeah just just be aware, you know, like you're not studying the exact questions because you know, but the, but the format is all exactly. You take a look at that. Uh And they're matching up with what content, but I'll, I'll go, uh, I'll do kind of like a review also, uh, next week. So kinds of things OK, sounds good. Thank you, take a look at that, I'll definitely you. I What I think you know it's a very, very strong. I swear if you can convince me. I move. I Yeah. I don't think we do. Oh. Right No, no, I do. I Right Oh, I heard. Like just to like. Yeah No hesitation. You've got part of it. You did that right in the heart of it. You hit that on speed though. I couldn't even tell you that. I mean, I'm just rolling through like quite quickly and I see that. I Oh You should see Yeah, I understand. Right, it's very rare. Yeah So This is the the. To tectonics. Get them. I'm all right. Oh yeah I mean I I didn't. Oh yeah, So I Yes. probably you know is. Yeah Yeah. I think. talk to you. No E to be our first day. Um, I'm gonna make you. Yeah for one situation if we give the other. Did you? 34. is Yes Yeah.


SPEAKER 0
Yeah. I'm sure you all just big workouts. To make things worse. That's great. Yeah, I didn't even realize I had one it saved me lots of money. So I guarantee it's less than 40. it's different. I, I don't care. They make, they make good. I wanna read it now. It's about like 5. It's basically telling you that we have 13, yes. Oh, I need to call in practice but you. I don't think he's touch. Are they a guys. I I'm just gonna ignore. Thank you. No, I see he's not. Yes, I But I see my stuff. Well, generally there is something that. But that should be So you just walk up and you, you, you do that. I. Oh. show. I. He did mention and the. Yeah. I'm almost done, uh, because I want to keep checking it, and once to the 62. Yeah, but some people are on to it. Uh, we, we do actually not because there is a one and one. Right Yeah Yeah. Honestly, I wouldn't mind because if you're doing like features you actually like them and stuff. If you're just doing testing, it's just free hours. And we just said to my father to write this test we're lucky. A lot of testing you just found. research in this library. That's what the solution is. Oh really, or tomorrow's lecture. It's meant to be in this que. Is this selenium don't. Oh more. It just And Yeah. Really Yeah. I'm not a hood. I was a team guy for couple of you want. It is closed um. And I really saw. Thank you to the. He If that's that's. Right In. Yes, yes, we, we, we bought a consort from the. I'm pretty sure the health star rating is compared to others. Where you can have like a 5. I Yeah. I'm pretty sure the health of like. sorry. What else Don't think I don't think, I don't need the.

SPEAKER 1
All right, hello, everyone. Sorry, I was kind of rushing over here, um. So welcome to the last week. Of the semester. Um, oops sorry. All right, uh, so last topic of the semester we're gonna be talking about, uh, bundling, uh, and front end testing, so. Bundling is essentially the what happens um a little bit about what happens between your development and the thing that ends up in the browser um that actually gets run uh and then I wanna just cover some topics around front end testing uh because we talked about back in testing, uh, last term. Uh, but I wanna just give you a little bit of an overview of that, um, and then, um. So, I'll talk about these things, uh, today, and a little bit tomorrow, and I'll do a quick overview of what we've covered all semester, uh, so you have a, you know, kind of a review. So the final exam is gonna be on the entire, um, You know, two terms worth of, uh, material, um, it's essentially gonna be short answer kind of questions, um, covering, you know, various topics. There is an example exam from a couple of years ago last time we had a paper exam we haven't had paper exams since then, um, so the formats exactly like that, it's just it's gonna be on learn. So you will just, you know, go into the computer lab and you will run it as a quiz and with questions like that, mostly just like short answer type things, uh, there's no questions where you have to like code things, you know, and try to get the right answer, um, you know, like some of those you know earlier year courses it's more just on the. You know, covering, you know, each of the different, uh, topics that we covered sometimes you might look at examples of, of code and things like that. So you can look at the exam, uh, example from I think it's 2021. I mean, the structure is the same. That's an older exam, so some of the content is different. For example, it covers view instead of react, so on and so forth, but you can see exactly it's the, the kinds of questions you can, uh. Expect but the but the content the format is like to look at sort of what we've covered in in the various uh lectures and so on, uh, but let's go ahead and um. I'll come back around to that, um, but let's, uh, talk about, uh, the last few topics that I wanna cover for the semester. Oh sorry, and one other thing I wanna mention is just remember to come to the labs, uh, this week. So first lab is tomorrow at 8 a.m. I'll be there, um, and, uh, I'll help you like kind of run through the tests, um, so make sure you come to one of the lab sessions, uh, this week. Any questions about any of that before I go on? Yeah, if you, I mean, if you can't come to your scheduled lab, just come to a different lab, but try to come to your schedule one if you can, so we don't overload the labs. Alright, so the things that I wanted to talk about, I mean, the first thing is really about modules and the development deployment pipeline we've been using that in so far when, when you've like been building with React, use, uh, Vite or is used to create the project you can. You know you compile it you're running it you run, you know, in in the browser um but sort of the question is like how's that all kind of work and come together and part of that ties into sort of how you know how do you get your, your final bundle in like production uh ready format and what is something some of the things that happen to your code between what you developed and what is running in the browser, um. So Yes, modules and the deployment play. So, um, when you have a single page application as we've already seen, I mean, excuse me, it's primarily going to be some, you know, JavaScript and HTML and CSS, um, so you have those three elements there, um, of course last week we talked there could be other things it can be web assembly, for example, um, and you will also have, you know, maybe you're drawing data from, you know, making subsequent HTTP requests to get some JSON data or something of that sort. But essentially you have some JavaScript and some HTML and that's what's actually running inside of the browser, right? um. But the important thing is that, you know, the, the preferred form for developing a single page application, like when you were in your ID and you're like building up your React application versus the format for downloading it to the browser. Uh, those are two very different formats, uh, in terms of what you want to do. So for when you're developing, right, I mean the best thing you can do is to create a nice directory structure. You have all of your components and lots of little small files, you know, you're writing all your typescript files. Uh, and you don't want to have everything in one giant, you know, file, right? Um. And when you're developing, um, there's also a lot of data like actual bytes of data in the code that you're writing that are completely unnecessary for running your code. So you might write some really lengthy long, you know, um, function names. Inside of your code you might have comments in your code. There's all kinds of things that you have in there both you know functional aspects like I mean actual semantic programming code components and as well as comments that all go inside of what you're writing um but. You know, when you are developing on the web, you're always trying to minimize or you you should always be thinking about minimizing kind of latency and the amount of data that you're transmitting on the network and so on and so forth so you know you wouldn't want to just take the files that you've written and just directly download them all as individual JavaScript files with all those like nice kind of readable uh function names and so on and so forth. And then of course um as we've already seen the semester often the preferred language for coding is not actually even gonna be in JavaScript. I mean you're you have to run JavaScript in the browser but you know you might want to use something like TypeScript um so. So this shows that like you know what you're developing in and what you run in the boroughs are are actually two different uh things so that's what what bundling and and the deployment pipeline is really all about is how do we go from one to the other, um. So first off, what is bundling? So bundling is like I said, it's taking the preferred form of web code for the developer and it is kind of pulling it into some preferred form for the browser to consume so you can think about this as being analogous to you write a C program and you compile it to uh machine code that's going to run as an executable file on your machine. Um, it's not, I mean that's just an analogy, right? I mean, Java you would compile to bytecode, um, but it's, it's, it's somewhat analogous to that, but I mean in our case we're not actually compiling, uh, the code to some kind of bytecode or machine code. All we're doing is we're compiling it to a different form of JavaScript that's a bit more, um, you know, smaller and, and, and compact, right? Uh And so the strategy for what happens inside like what a bundler does in order to do this bundling is it needs to think about what exactly does like a browser slash user on the client prefer so you first of all they're gonna prefer fewer network requests. Fewer network requests means fewer files because every HTTP, I mean every individual JavaScript file that you want to put down is going to be a separate HTTP request. It would be a lot better if you could just make one request and get all of the JavaScript, uh, that you need. You also prefer smaller network requests so we want to make those files as small and compact as possible, um. And uh we want to be able to do parallel network requests or um if you know ideally no network requests at all so we want some way maybe to cache the files um so that the browser doesn't have to, um, you know, even make the request, um, and we'll see, um, that in fact, um, even the way we bundle our code can sort of help and facilitate uh things like caching, um. Uh, for, for a web page, um, so. All right, so the simple, I mean, so first off, like I mean one of the things that we're looking for is fewer files, right? Well, I mean, and, and kind of the, the kind of in the sense of like, like what is it that you can actually do? Well, I mean, first of all, when you write a bunch of JavaScript modules um inside of your, your application, well you could if you want just take all of the code that you have all that JavaScript and just slam it all into one. You know, giant JavaScript file, um, and you do the same thing for CSS as well like if you have different CSS files you just throw it all into one, file and so this is exactly what some tools, um, that are kind of built into the various bundlers that are out there do. So some of these tools are like Gulp, uh, grunt Roll up is the one that's inside a vite and so roll up is the one that you've been using. Um, inside of your, your application, but they basically follow the same pattern they just sweep through all the files, um, you know, that are, uh, basically there, um, and then they try to do some kind of transform on those files to generate, um, fewer output files. Um, so, They're trying to create fewer files, and then the other side of it is they want to create smaller files, so. Browsers for the most part don't really care about about JavaScript function names. I mean they have to be valid JavaScript names, but you could have the letter A as a function name and the letter B is a function name, uh, but so since the browser doesn't care about that, um, but we do care about how much data we're gonna, um, spread over the network, then what we need to do is try to find some way to kind of just. You know, squeeze all that stuff into smaller names so you can shorten all the variable names, all the function names, uh, and so on and so forth. So here's an example, um, this is, uh, the output of a tool called Uglify uh JS, um, so Uglify, I believe is used in as part of the web pack bundler whereas Vi uh uses, um. What's it called? uh. So I'm blanking on the name. Let me see if. Um, Uh, ES build, yeah, so, so they, um, they use ESBuild, um, and so there's different, different like tooling will have different kinds of bundlers in there, but the basic principle is the same. You have some kind of, um, you know, function. And you wanna turn it into a different thing. So what Uglify does in this case is it's taking of JavaScript file.js, um, and it's gonna map it out into some other, uh, function. Now there's some other, other, uh, parameters here that I'll talk about in a moment and and link into to other things, but, uh, first of all. Just let's just take a look at it, um, in, in the context of, uh. You know, the function. So we have a function called global function name. It takes input inside of it it has a nested function, um, that nested function, uh. Takes the input that's passed in, uh, increments it and does the console log and then it calls, uh, nested function inside of there, um, so Agliify uggliify will turn it into some function that looks like this, uh, right here now what you'll see here is, um, it does a lot of stuff that I mean first of all, I mean it's uglify because in the sense that like it gets rid of um. The variable names like input, it gets rid of, uh, nested function as a function name, um, but. It, um, It also does takes takes into account some weird features of JavaScript language um that basically allow it, you know, that that will, um, force things to sort of be evaluated for example. So, so in in this case it's it, it, it has the global function and it's changed input to end so that's taken 5 letters down to 1. It compresses, it gets rid of all the white space that's clear. It makes nested function an anonymous function, uh, without any um name and um. It just uh uses a shortened version of incrementing and uh it calls console.log, um, and then it calls it, it puts the if if you recall way back, um, in, in term one I, I talked about how the function keyword for it to understand whether or not it's um it's meant to be evaluated or not um you you need to. The the function keyboard it can be kind of ambiguous in in JavaScript so it just puts the the not um simple in front of that which forces this execution to happen uh immediately and it just sends it back as the return I mean it's the um. Uh, well, in this case, yeah, I mean, there's no return value, so it's just gonna call a console that log and it even does some funky things like it. If you see here it has a comma like in JavaScript you can you if you have multiple expressions on a single line you can separate them with commas, uh, instead of using semicolon so so you can see it's like it's taken into all these things and it's trying to squeeze it down into the like the minimum number of actual characters is that it can possibly have um. But there's some important things, so I mean you'll notice here that global function name is still there you might think why, why can't they replace that with something else? Well, uh, you can't change a name or things like string constants or object keys and and that sort of stuff. You can't because you're uh unless you can be 100% sure that nobody else is going to use it, right? So, if a function is exported from your module. And then it could be used by some other script, uh, in your code. Um, well, then you can't, then the, the, the Uglify tool doesn't know. That somebody isn't trying to reference global functioning, you know, from another module that is not um that wasn't, you know, using the same same mangler or or you know ugglifier, um, so certain things can be reduced, um, but global variables, um, and global function names cannot be because they still need to be, uh, accessible, um, so. All bundlers will go through this process. Now, there is a thing called the source map here as well. Um, we'll come back around the source maps uh in a moment, but, um, just to give you I mean just to tell you what they are and at the most basic level is that if you do this, if you compile your code like this but you want to run it in a way that still allows you to kind of um you know, in a development mode where you can map back to the original source, then you basically need a mapping uh between the functions uh and variables here. And the function names and variable names in your original file so that if you're if you're running a developer and it kind of gives you an error message or something, it can tell you where you are in your in the original code um rather than in the mangled code right? because that would not be very useful to you as a developer. Um So these kinds of tools are now kind of baked right into to all uh bundler tools out there whether it's web pack or Vite or anything else. So, so yeah, OK, so there's, there's Uglify JS that's the one that's using the web pack. Turser is another one. ESBuild is used inside of fight, um, and so. Like I said, the code is name mangled, um, sometimes optimizations are applied like, um, you know, for example, it, it could, um, instead of having a separate, uh, function call, uh, inside that one, it just automatically executed it immediately from an anonymous function. So the result is very difficult to read as a human, um, and then probably any website that you go to now, you could probably open up the source and look at it. And see, and it's probably going to look a bit like that kind of mangled code there. Um, but the bottom line is that Even though this is true, uh, it's always important to realize that it's still very easy to reverse engineer. It's still JavaScript code, right? It's not even machine code or bytecode. It's, it's something, uh, that you could, you know, open up in an ID and you could, you know, pretty print it and you could have, you know, JavaScript functions and you could, you know, even though the names might not make sense, you could figure out what's going on, uh, with the code. So basically anything that runs in a browser, you know, you can forget about it being kind of IP protected or, you know, intellectual property, uh, protected. It's, it's all there for anybody who has the skill to look at it and and open it up so anything you are sending to a browser is public, uh, knowledge you can't have kind of private code that that nobody sees, um, so like I said, uh, to aid debugging you can make source maps. So, so what happens is when like when you run for example a development mode of your application. Uh, and it opens up that local host, you know, maybe some support like 5173 or something like that. What's in there, what it loads up is the mangled code alongside the source maps and the browser knows how to uh handle that so that the development tools within the browser use the source map to kind of link back to the original uh source files. Now once you compile your code to production. Um, you know, if you were to build to production without running in development mode, all of that stuff, the source maps is, is removed, so none of that is actually included in a production application. You shouldn't ever have your development, uh, code then in, in, you know, on a live website somewhere. Um, there's a lot more to learn about the source maps, how they work, you know, various tools for them and so on. But effectively, I mean the name says it all, it's a it's a map. Uh, map to the original source files, um, between like the, the mangled or code and the, and the original code. So it aids with, with debugging and and that sort of thing. Um. So, so that's part of it and make things smaller, um, and then there's bundlers that kind of wrap up these various tools together and pretty much I mean it's best practice to do all this now if you wanted to you could create a ACT application and install individually all of these various pieces one by one and build up your project, um, you know, set up all your, your, uh, files that you need. Um, adding the NPM packages, um, you know, for the different elements and do all of that, but you know, we now have bundlers that kind of, you know, create project templates, you know, from scratch, and that's usually what we do, um, there's a lot of them. I mean, Vite has become popular in recent years. Uh, we used to use Weback, uh, in the course just two years ago and then we switched by, um, but essentially butlers are like the best practice if you're gonna build, build a project because it kind of sets things up. Now it is worthwhile to know what kind of butler you're using because maybe you need to customize or configure how you want your code to be to be compiled and then it. That point then you would enter into looking at, you know, what are all the configuration variables, what can you set, what can you change, um, and you know if you're, you know, I'm sure many projects they do set up, you know, various customizations, but essentially the bundler knows whatever whatever the input language is. So you know, like when you create a react app, um, you know, like a white react app, you can choose to create it as a JavaScript one or you can create it as a type script one and so the difference is that it configures all, you know, the, the relevant variables for the for the bundler to know how how that works, um. And so it configures where all the input files are like it knows that that's where it shows where you go in in, you know, for example, all of the, all the JavaScript or TypeScript files are gonna be inside the SRC folder, um, that sort of thing like all of that is configurable you can change that around, um, it shows it, it tells where the, where's the start of the application like the actual like, you know, core, um. Entry point into your application where's the index. HTML file, you know, that kind of thing, um, and so basically it will, it will analyze your code when it looks at it and it will kind of recursively go through all of the imports and exports, um, identify kind of, you know, which modules are there, and then it does something of kind of like a tree shaking thing where it identifies all of the. The files that are relevant if a file doesn't get imported, it's not going to be bundled it will cut that out, um, but it also removes dead code within the files so if there's functions that are never called if there's variables that are never used all of that stuff gets kind of stripped out, um, and, um. That's what they call unused or or dead code is is not included in your final uh version um so it does a full kind of recursive kind of depth first search through your code and finds all the links that are there, um, and then puts it all together and then the final output it will be something like this and it'll look like it'll have some like name like main and then it will be followed by a hash uh and then JavaScript um so. Uh, They this file might be a huge file might be like 10 megabytes or who knows what I mean hopefully not 10 megabytes, but you know it's probably pretty large and it'll include everything so it includes more than just like the raw like files that you've written, but all of the third party modules, all that JavaScript code, um, if it's not, if those aren't kind of directly linked. Off the web, you know, um, you know, off a CDN or something if they're actually bundled into the code, then all of that kind of gets squeezed in there, um. So you kind of come back, I mean, so this really comes down to bringing everything into into one file, you know, 11, web request, um, and so, um. All of this, uh, is, um. Yeah, I mean, essentially this is all set up for you, um, but it is also all configurable, um, inside like if you open up your files and and take a look at things, um. Maybe I could just show you real quick. Oh Oh shoot, do two-factor authentication. Right, so just to take a look here. Um, this is a reference implementation for assignment too, um, but this is what, what you can see here is all of, you know, byte is the bundler that's used, um, and. You can actually see in here, I mean, there's a little bit in here, um, there's a plugin, a react plug in, um, which is a particular, um. It helps Spike know that it's, it's compiling, you know, React and and JSX, um. And Sorry. Um, and you can see here there's a TS config, uh, file here. Um, so this, uh, includes information about what kind of, um, compiler is being used, um. Uh, it wants to know how it's going, I mean this is information that goes into the bundle of how, how modules are, are, are put together. It, it's, you know, telling it that the JSX files, um, should be treated as react JSX, um. And so all of this uh together and then in the package that JSON file here, um. You know, all of these, uh, things, you know, come together. With having a dependency on vite and so when we, when you are able to actually um like, like when you run sorry here uh dev what you're actually running isvite which is the bundler and so that bundler is gonna, is going to take all of that con all those various configuration variables it's going to know how to interpret what you know what's in the source files it's gonna know how to you know bring everything together, um, and it will, um. You know, essentially create the, you know, what we're looking at is like the JavaScript files that are, um, you know, bundled together along with the source maps and all of that. um, now if you see here, if you were to do, if you were to run MPM run build, you could see here it does the typescript compiler. And then it calls Vite build and so ViBuild creates a production version of the code that does not have any um uh of the source maps in it, um, just the kind of the compressed, uh, stuff. So all of that um. Got kind of set up for you, um, you know, when you create your project, um, but you know, if you wanted to really dig into it, you could look into the right documentation and there's all kinds of ways things can be configured, um. So Um So you know, the last thing I wanna talk about that I mean there's is it's just the idea that you know showed that you can combine everything. Oh sorry, there's one other thing I wanna say before I go on. So this when you, when you create the output, um, you know, it creates a big JavaScript file and you see it has this hash here so that hash is essentially like a hash of the compiled code, um, sort of the the current version. So any time you were to rebuild your application and you make the slightest change in your code, it's gonna generate a new hash right? because that's how hash functions work, you know, you, you create some small change and it comes up with a completely different um number as an output that's just some giant, you know, hexadecimal number so. The reason why this is also important is that it really helps for caching, um, because from the front end you can cash essentially um you you can cache files that have a particular hash um and so it can it can essentially trigger the application to load, um, reload a new version of the application the moment an update is made. Um, without having to kind of have some kind of time out or you know, some kind of expiration date on the cache, all it does is that, you know, you have this, this file will be linked, you know, say inside of your index. HTML file you upload a new version of index. HTML and then and. And that has a link to a different main with a different hash. Well, the cache that's not gonna be in your cache anymore, so the uh browser will know immediately to pull the new version down. So it's very effective for, um, you know, but, but on the other hand, if nothing has changed in your application and this hashed version of the JavaScript already exists in your device, then it doesn't need to make the request at all, um. So it's very I mean that's why that's why they include the hash when they when they they bundle it because it essentially allows you to have an efficiently efficiently update your application as needed on the client side um and the hash is pretty much unique, right? I mean the way the hash functions work is that there's no way you could ever make a change without the hash function being different and hash functions are very few collisions, so essentially they're basically unique, right? Um, for all intents and purposes, um. So, uh, so last bit is that well bundling it all into one big file sounds great. However, um, you know, because what that does is it reduces the number of requests that you need to make however, it might make sense if you really are interested in. Sort of quickly loading your application and reducing the amount of load on the initial, um, you know, when you initially pull it down. You can essentially break your single page application into various uh logical chunks. So. You know, for example, you might have a, a log in chunk, um, might have a settings chunk, um, you know, something like that, and the idea is that you know when you're interact when somebody's interacting with your application, they only download the the chunks of your application that they actually need. So the chunks are distinct from the individual JavaScript files that you're developing in though, right? So if you're, if you're building your application, you're gonna have all kinds of different components and that sort of thing, and those are all different files so we don't, we don't want all those files to be all separate chunks, but what we do want is some some kind of logical relationship between aspects of your application that you want to load and um the links so. Basically bundlers as well as as well as sort of JavaScript frameworks like React so like React and Bundler have to agree somehow on how to split up that import graph, um, that, uh, is done. So I like I said, when the when the bundler looks through it like kind of starts at the at the entry point of your application and it runs through essentially tells a depth tree depth search. Through all of the different imports and it constructs a tree of those. Well, it needs to know at what points in that tree does it split that off into kind of, you know, one chunk and this into another chunk and that, that kind of thing, right? And so basically there needs to be some way for them to agree together like what you're writing in your dra code needs to tell the bundler, I want this to be a separate, uh, chunk, um, and so there's different, you know, this sort of depends on the on the bundler you're using the JavaScript framework that you're using. I mean, there's the, the most of the bundlers now are kind of work. Have effective ways for you to do this, depending on whatever framework you're working with. So, for example, if you're using React, and you're using by, um, then it will automatically. Do code splitting, um, if you use something called uh react lazy. So what this is is it's like a lazy loader uh for functions um what that means is that you make you reference a function, but you know, or you know, in a module, but that doesn't actually get loaded up until, uh, it, it's needed right until the code gets to the point of where it needs to be. So this example here is like, um. There's some, um, I don't know, suspense. I'm, I'm not actually sure. I mean, I'm saying that like suspense is like a standard react, uh, component that like, um, just, you know, sets in a like a pre, um. You know, kind of like a pre uh loading page kind of thing. And so, um, Uh, you know, it has a fall back and so that fall back is just that it's gonna show this div showing loading. Only, um, when it's ready, um, does it, will, will it pull in this other lazy component. But, and what you can see is here by this construction where you, you basically. Instead of doing a direct impact of the lazy I mean sorry import of the component just from the file directly, if you just if you just said import lazy component from whatever, uh, then the butler's just gonna shove that all together in the same code and it's all gonna be the same, but if you do it like this, um. Essentially what this means is that they this will tell uh like fight will know to say OK well this this import is actually something I wanna put off into a separate JavaScript file and when this code in this callback in this lazy callback actually gets executed only then will it uh kind of download uh that file uh and run it, um. So you can do um you know this kind of code splitting um and so this can be handy for like fast loading of a page so maybe you have like your basic uh page that's there, but then you know you lazy load other elements that you don't mind if they take longer uh to load or something like that. So this kind of balances between having things in one larger file or a few smaller files, you know, depending on your use case um. All right, so that's, uh, more or less it in terms of bundling, um, that I wanted to talk about is are there any questions about that? Anything that I've covered. Oh, OK, um, so. Um, the last topic I wanted to talk about, um, you know, it's just automated testing. I think maybe I'll just quickly start with a little bit about it and we'll just finish it up tomorrow. Um, so. First of all, testing is like a huge area, um, when it comes to any, any software development. I mean, if you've taken other courses where you look at testing some of the software engineering courses, I assume, um, you know, you know, you learn about all kinds of different tests out there. You can do unit tests, you do behavioral tests, you do acceptance tests, there's all kinds of different tests you can do, uh, and there's all kinds of different systems that you can test, um, but in particular when it comes to web applications, um. There's a lot of challenges, um, so the first of all I mean is that it's just a very like. Heterogeneous space, like your application is running in all kinds of different environments that you have almost no control over. So, there's the different browsers, different versions of browsers. There's different versions of HTML and JavaScript and, you know, and JavaScript engines. um, there's differences in the APIs that are built into the browsers, so we talked about XHR maybe one browser has a different implementation of, of, um, uh, XML HTTP requests that another one and it behaves a little bit differently. There's differences in the way the DOM is handled, um, there's differences in libraries versions there's all kinds of like variables out there, um, and all of these things, you know, play a role. I mean, in some sense using bundlers and using frameworks helps it helps a lot actually because it kind of smooths over some of these some of these differences. But nevertheless you still want to be kind of like test, you know, in different environments. So I mean for example we're gonna be testing your application in Chrome, uh, but you know if we tried to say we're you know it has to be tested across all different browsers I mean who knows what what happen right? I'm guessing unless you had a Mac you probably didn't test it on Safari or something like that, right? And it could, there could be something that happens that you don't you don't expect. Um, there's a lot of advantages to automating the testing, uh, with web, uh, programming. I mean, essentially, I mean this is just a laundry list of, of different things you could do. But essentially automation means you're basically offloading tests that humans would otherwise have to do, uh, to machines, uh, so you can do a lot more frequent testing of different things, uh, you can get very quick and regular feedback, um. You can, um. Uh, you know, you could, you can run different iterations of your test and, and, and so on and so forth. I mean, so there's lots of different, um, kinds of things that. Automated testing gives you, uh, but there are when especially when it comes to web uh stuff there are um sorts of ways in which automated testing. Doesn't really cut it entirely. I mean you wanna try to automate as much as you can, um, but on the other hand, like sometimes you just need to fall back into manual testing, uh, so on the client side it's very hard to write tests if you're if your if your interface is changing all the time, right? So if you're rapidly like developing on that, you know, changing the features and that sort of thing to actually write automated tests for that is really cumbersome, right? um. So if for example all the various HTML elements in your page are always changing, then you can't easily write a test that's just gonna check for like the state of some element, you know, um, so you just have to match, I mean the, the, the change of the tests have to the tests have to change at the rate that the, the, the interfaces and then on the server side if the API is similarly changing and there's time scales, it often doesn't make sense to write like a whole automated, uh, test suite up and so forth. Um, nevertheless, there are some very cool automated, uh, tool, excuse me, automated tools for web testing that I would like to cover, uh, and I think I'll just, um. I'll just cut it off here and I'll, I'll, I'll say talk about I mean I'll just introduce it that we'll talk about the web driver API which is just a, a really nice way to automate, um, kind of testing where. In a sense, if say you mentioned you're building your application and you wanted to actually say, oh, OK, I just want to push my application across a 100 different types of machines with different form factors with different, um, different, you know, Linux and Mac and Windows and all different types of browsers you could do that with this kind of of tool um so tomorrow I'll, I'll cover that, um, and then we'll do a like a, a review over, um, sort of the whole semester. And happy to answer any questions and things that you have about, you know, different topics that we've covered all all throughout the semester. Then to prepare for the, the exam. All right, any questions about, about anything we've covered so far? All right, um, thanks a lot and we'll see you tomorrow.

SPEAKER 0
Um, uh. And You I run so last question. I. so uh. Oh yes, it's closed book, sorry, uh, no, not during

SPEAKER 1
the exam, OK, yeah, I'll, I'll talk about the exam a little bit more tomorrow, but yeah, it's, it's closed book. It's, um, uh, it's basically like short answering kind of a few multiple choice questions, that kind of thing. Uh, no long questions, no quiz. I mean it's no like coding questions, but sometimes I might be like, you might look at code and have to interpret it like a little thing, a question about react or about typescript and things like that.

SPEAKER 0
Yeah, yeah, yeah. I Yeah But he said this. But Yeah. All right. Oh, I Yeah, well, I just, I You Yeah questions I. No. It's the the the. So I guess I was on. Right P I guess. Yes. Yeah. Yeah. Yes. a. So. I still do. And Thank you. Some of the. Yes. Yeah. I don't think it's, it's not like lynch. I actually have to do with society. Yeah, yeah. I I don't know, it's not. well OK. Yes. doesn't make sense. And I D.

SPEAKER 0
just something. Is it 8. Because That All right, hello everybody.

SPEAKER 1
Welcome to the last lecture, uh, for this semester. Um, just out of curiosity, is anybody taking, uh, 303 next semester? OK, just a handful. Um, yeah, I'll be teaching that one, next semester. Well, the first half, second half is, is somebody else. Um, so, um, cool, OK. So we started the lab tests, uh, and they seemed to go OK, um, as far as I could tell we had a few, you know, things always crop up, um, as in the first time we're testing it, but surprisingly few things and issues, um, we had a, I mean I had a problem where I I copy all of the um. Projects up to a Dropbox, but it wasn't uh. It wasn't sinking, uh, like for 12 hours, so, um, mostly because I had all the I had all the folders and then I turned them into zip files and I was just having the zip files and I deleted all of the folders, uh, but then, you know, because of the syncing for deleting all the folders or something like 180,000 files or something like that that had to be synced and so it was like turning away, but it seems like it's all good to go for the next, the next lab. Um, but when you go into the labs, you're going to, uh, follow the instructions here on this, uh. Um, on the assessment tab, um. I'll, I'll be there, so I, I'll give you guys, uh, instructions, but if you want to look ahead, it's they're just here in terms of giving that the, uh, instructions on how we're gonna be. Uh, running the tests, so. Sorry about the coughing, um. All right, so that's the um. Uh, I mean, lab tests, which seem to be going OK. Everybody's doing testing 3 of their peers and, uh, you know, we'll see how, you know, look at the results of all that um. So, uh, the next thing I, you know, there is a little bit of a topic I wanted to cover, but it's a little less important than maybe just, you know, doing a quick review over all the topics and talking about the exam. Apologies, so. I think I'll actually take put a cough drops. All right, so The exam there is unlearned a um. An example exam here from a few years ago. Um, and the reason why it's a few years ago is because We switched the format. I mean this is a written exam, a paper exam. And so, um, the other ones are on like quiz server type things. So, um, this one's easy. You can just look at through the examples, but it's basically just to give you sort of the structure and the kind of like the scope of the questions. But there's been some revisions and topics. So if you look through that sample exam, you'll see, you know, for example, the questions about view JS instead of react, and obviously we didn't use view in the, you know, in this class, so you know things like that are, are, are gonna be covered, but um. Effectively, I thought I would kind of just go through, you know, the different lecture topics. Talk about the kinds of questions you might anticipate. You know, for each of these, uh, uh, topics, um, so, um. Let me um So, let me start it off, uh, like the first kind of beginning of the course. I mean, we introduced uh. Like a lot of the fundamental um. You know, pieces of, of developing, you know, on the server side and that was like HTTP. JavaScript A type script, um, and so. HTTP Um, you should expect there will be some questions on HTTP, for example, being able to. Uh, you know, recognize and understand the structure of like an HTTP request and response and being able to distinguish between those, um. I could pull up the And uh you know, I'm highlighting things. I mean, the important thing is to just, you know, look over the coverage of the content, you know, across. The um semester, but. Let me just open the slides. I'll show you. So, um, Yeah, so, for example, I mean, this, this is just an example, um. You know, you. We expect a certain structure, um, for you know requests and responses you should be able to differentiate between those like see an example of that maybe and and know, you know, whether it's a request or a response, um, look at it, you know what are some of the headers, um, what are they saying? You know that sort of thing, um. And um Also matching between sort of, you know, what we have as in terms of HTTP. So for example, you have an HTTP request, um, you should be able to sort of know, OK, what is the. Um, what is the form of like a URL that would have made that request, um, you know, something like that. Um, And um You know, also maybe just understanding like being able to interpret something about like the different headers and or body fields or things like that, you know, kind of understanding like what is, um. You know what does that mean, you know, this text document um. So Uh, Along with that, Uh, you know, it's also just understanding for HTTP, you know, what are the, the common methods. And you know tying into what we talked about in around week 4 like which methods are kind of um like how how are HTTP methods interpreted for a restful, uh, API. You know, so for example, understanding which methods are safe, which methods are item potent, um, and that kind of thing. Um, so, HTTP Uh, you know, it's important to understand the basics of the protocol. Then you know, obviously a piece of the course was around learning JavaScript uh and learning to implement it, but in particular I mean part of it's just learning the language um. But more interesting is to understand a little bit about how JavaScript works for a synchronous flow. So, for example, being able to interpret some code that maybe has some async function or something like that and look at the behavior, you know, so. An async function is a function that returns a promise, um, which means it's a promise that is, you know, either, you know, pending or completed, and it's gonna, it's gonna operate in some behavior so we have these examples, for example, like the time out like time out functions like. You can, you should be able to look at some code. And interpret how it's going to behave in one way or another, um, and tying into that is also at a little bit more of a conceptual level how does this relate to the event cue? What is the role of um the event cue? In how asynchronous computing works uh in JavaScript. Um, I mean, I kind of assume. At a basic level, you've done enough JavaScript programming now that you should be able to read JavaScript and just, you know, interpret what's going on. Um, as far as type script is concerned, um. We are, um, I mean, the key difference in TypeScrip obviously is it's a, you know, it's a typed language, um, so, uh, you might, uh, have some questions sort of around, um, looking at that aspect of, of TypeScript and how, how you define things in TypeScript and what might compile in TypeScript, um, or not compile, you know, based on the typing, um, and that sort of thing. So that was kind of the, the beginning part. Linked into that is also, you know, the topics about rests and and APIs. So we, we talked about APIs more generally, like how do you, how do you go about, you know, constructing them. Like and certain topics around the things like versioning and that sort of thing, um, but in particular, you know, focus on like the things around rest and understanding what is mean to make a restful API and um how does that relate to the HTTP methods and that kind of thing. So then there are a number of other topics that we kind of hit on that we didn't really get too deeply into the technical side, but they were more about kind of rounding out I guess the um kind of giving you a foundation of the scope of web computing and on those I would put things like data persistence, um. GraphQL, uh, testing and so on and so for those kinds of topics, um, you know, it's good to review them, but essentially but you know, questions about those are gonna be sort of more about. Um, things like how would you, uh, use these, um, different kinds of, um, tools or what in what circumstances might you use this versus something else, right? Um, so just to give an example like you know SQL versus no SQL, there might be. Questions around like, you know, given some kind of scenario, you know which kind of, you know, um, data persistence with you, what would be the be the pros and cons of that in different ways that that sort of thing, but all of these are very short answery kind of, um, questions, um, you know, they're not essay questions, you know, the sort of might be things but it's essentially about applying. Your conceptual knowledge around around the things that I talked about trying to understand the context of how they might be used and so on. Um, so really then, when we flip to the client side of things, um. That's when we started to look at JavaScript, uh, running in the browser, um, and so there was a, a lecture all about JavaScript frameworks, so. Um, In that sense, um, I mean, I think probably the. I don't wanna like kind of say. How, how should I put it, put it, I mean, I would say that like the concepts that were kind of fundamental to the JavaScript frameworks, like I wouldn't expect you to like remember all the different frameworks that are out there and like, you know, in the history of that. I mean that's not really important so much, but what is important is understanding sort of how that that JavaScript frameworks. You know, implement by default some type of data binding either one way data binding or two way data binding, um, and to be able to, you know, answer questions about that, um, really in the context of REA primarily because that's the framework that we've we've, uh, looked at, um. And so then coming into REAC, I mean, you should expect to be able to, I mean, some of you've all done React programming now in the assignments, so that's good. But, um, what we talked about in the lectures was trying to kind of dig a little bit deeper into sort of what is going on, uh, with React, like, for example, You know, uh, if you're writing JSX, um, that's actually some JavaScript, um, so you know, can you. Um, You know, look at examples of, you know, one or the other and compare them, for example, uh, or, um. Uh, for example, um. Just being able to look at things like class components uh versus function components, I mean, essentially they're the same they have like functionally equivalent in many ways, um. But they might, might kind of implement the same kind of behavior, um, in different ways so being able to to sort of answer questions around that um so used function components in their functional components in the in the labs, but we did cover class components pretty extensively, uh, in the lectures, um. So, um, Let me see here. Trying to look through my My topics um. So any questions by the way, as I'm, I mean, feel free to interrupt me and ask questions, that's totally cool. Um, I think Um, Just looking through to see what kinds of important things. Um, Oh right, yeah, OK, so I mean beyond React, I mean that was sort of the, I mean that really went into week 10 I think, um, in terms of. Can't remember exactly. I mean, I was running a bit slow on things, um. Then like the very end, we kind of talked about things like web storage. Um, We talked about web storage we talked about the um I mean just yesterday we talked about bundling um and uh. We talked about um. The other kinds of things. Oh, Oh, like cores, for example, like, um, you know, trying to understand those, those kinds of topics, so there might be, you know, like one or two questions on these different topics, short answer topic, uh, kind of, uh, questions, um, so for example with courses, I mean an important concept in course is to understand the notion of what the origin is, um, and how that's interpreted. You know, in a scenario, um, and so being able to kind of do something like that would be good, um. And so they can expect, you know, on the order of less than 20 questions altogether it's not like a super long exam it's gonna cover all of I mean it won't cover everything, um, uh, you know, but it tries to cover kind of a broad scope of things across, you know, the various, uh, topics that we've talked about. I mean it, it definitely will cover things like, you know. Uh, HTTP, you know, JavaScript type script, um, react, you know, those sorts of things, and then for these other kinds of topics there will essentially be more kind of conceptual questions where you you it's just so that you can interpret and, and kind of apply your understanding of, you know, the topics, um. To to sort of understand like why they're important in in different scenarios um. And um Yeah, let me see here. Yeah, so it's, and it's 2 hours. So it's 2 hours on, I think the 11th. I think it's scheduled for the 11th now at 2:30 p.m., um, but, um. You know, the questions kind of vary in their length, so I mean some of them, and they're not all like the same number of points either, so you might wanna kind of look through and just gauge, you know, how much, you know, things are. I mean a few other questions have some parts, you know, for example, ones that might where you might need to interpret something like some react. Like JSX or something like that and just, you know, interpret pieces of it or like some specific questions about that and its behavior and what it might do. Those kinds of questions, you know, might have multiple, some multiple subparts in them, um. But I think um. You should expect um. I'm still, I still, I mean, I'm not, I tweak with the exam like still, um, as I'm going along, so I don't have the finalist version of it, but. I would, um, You know Yeah, I mean, I, uh, I, maybe around 16 questions or so, you know, so not, not too long, um, but it's really just about trying to tap into some of the other topics that we've covered, um, throughout, throughout the course. Um I guess, uh, I mean, any, any questions about any of the topics in particular or or want me to kind of elaborate on anything?

SPEAKER 2
16 Question will get more mark. Yeah. The answer will be Like how is all. You got a question 2 more with like a short answer, like 2. like 4 or 6 Yeah, I mean, yeah, the points,

SPEAKER 1
uh, you know, and how much of a question is gonna be based essentially on the effort slash, you know, length of the answer involved. I mean, I don't know that I have an exact way to describe it, but yes, I mean there are a few small questions that are just like very simple, like one or 22 words or something, you know, you can answer the question. I mean there's just an answer, right? Um, there's other ones that you know you might need to just do. I mean sometimes it's, it's not so much about the length of the answer, but it's about. I mean like if you have to interpret something and think about it and that's a little bit more than just answer you know some some questions that are sort of like um. More informational, right? You are sort of presenting that you know some piece of information. Other ones are about being able to apply what you've learned in in the context, so you're kind of interpreting something and looking at it. So I, I don't think those tend to be take a little bit more effort and would be worth more points, um. That makes sense. I mean, yeah, um. I, I try my best to try to like gauge these points, but you know it's, it's never like perfect, you know, match for what how the effort that people put in necessarily. Um. But um, Yeah, um. Any other questions? Concerns or anything. Um, yeah, and so I mean, just to see like in the um. Where's the I'm sorry I'm on the wrong window here. Um So Like I don't know if you look at this sample example. I mean, it is admittedly a few years old, so things have, some of the topics have definitely changed, but um actually let me just downloaded that. Uh Yeah, I mean, so here's like a longer question. I mean, what I, I mean, I don't know that there's what a comparable question now, but this is what like UGS. So it's like you're kind of in this case, I mean this is view, not react so you know, you know, but it's basically, you know, in view you have some HTML, you have some things and then it has some to do things and it's asking sort of like to fill this stuff in in the question, um, so I think these points get, you know, these, um. Can be a bit more, but you know some of them. Are sort of, you know, questions about you interpret the code and so it's asking something about it. I mean this is about view, so don't worry about it. It's not the question doesn't make sense in the context of react, but you know, so it's just basically asking some simple sort of question. If you understand what's going on in the code, you should be able to answer yes, no, da da da da, you know. And so on and so forth. Um, But, you know, there's other questions that are a bit more, um, you know. About, about topics, but you know this in this one, I don't think this example had anything with the HTTP. This one was more about HTML. I don't, we're not really. Um, we won't have a question like this, um, in the exam, but you know, this one's sort of, you know, it's about interpreting code and, and that kind of thing. Um, But yeah, I don't want you to actually, you know, pay too much attention to the old exam in terms of the questions themselves because like I said, the content has shifted in the course quite a bit. Um, I've changed around a lot of things, especially with React being in there now that's all new. Um, But, um, yeah, I mean, but it's all just as a quiz, so you like go in and they'll just one question per page and then you'll just have like a basically a text box to type in your answer. And it is a closed book, that's the other thing. Uh So you won't even have like an IDE or something to help you out. OK, I stunned with silence. I'm assuming you, that means you have no more questions. If you have questions, feel free to just ask. Um, all right, so, In that case, I think what I will do is there was one last topic, um, that I wanted to cover uh briefly um. And that was around testing. Uh, I pulled my slides. Oh So, so yesterday I covered bundling and some of the the issues around that about how you want to kind of optimize so that you're not making too many network requests you also want to reduce the size and so for that we um. We essentially um. We throw all the code together and went to one bundle or one JavaScript file, um, but we also, uh, uh, you know, potentially might split it up by logically into logical chunks depending on sort of how you want your, your, your program to operate and so bundling is, is part of what you get for free when you created your React app. Then built it um so towards the end of that I was talking a little bit about source maps. So when you build to development, it includes the source map when you go to production, you don't have a source map, um, but the source map really comes down to the reason it's there is to aid in debugging, sort of which naturally kind of takes us over to the last little topic which is around, uh, testing. So So for that, um, I just want to talk about a couple of different ways of doing testing. So So first of all, you know, with web programming because you don't control the environment that people are running your application, there's essentially like all there's a multitude of environments that people can can work in. Um, so one of the ways that you can get about doing this is to use a thing called the web driver API. So this is another API that's built into a browsers, and it's effectively a way to sort of programmatically interact with the browser. So the web driver API is not really enabled by default because by default it would create all kinds of security, um, problems, um. Because it essentially gives you power over the browser, um, but it is great for doing testing. Um, so web driver is essentially a way. That you can write tests that act as if you're a user agent. Um, using some separate process, so you write a program that process is the controlling agent and it's gonna use via the web driver API it's gonna go in and interact with your, um. With your application, um, it can also allow script scripts that run inside of a browser, um, itself, not like an external script that's running the test, but like something that's actually in the browser, um, or a separate browser controlling another browser, but you know, of course for that you need to kind of unlock that because that is a clear kind of security concern if you've got browser applications able to control other browser windows and that kind of thing. Um, so basically provides a bunch of interfaces you can directly, um, sort of look at the state of the DOM. You can manipulate elements to it, uh, so and you can act essentially as a, as a user, um, and the whole idea is that it's supposed to be platform neutral and language neutral, so it's, it's basically they define a protocol they call it a wire protocol. Um, that if the, if the browser itself, uh, implements that API, then you know you just build your code to, um, interface with the web drive or API, uh, and then you basically can call functions that will instruct how the web browser is supposed to, um, behave, um. So Yeah, sorry, this. Slide's a bit repetitive, but this is like um essentially you know there's implications, um, in terms of and concerns about if you were to do this in reality like if you're doing it just in open it up for anything that's not uh a web testing environment, um, you're essentially creating a huge security, uh. Openings uh for your applications so you don't you only use the web driver API and kind of control the situations um so on top of that there's another tool called Selenium. There's a couple of other ones, but I mean selenium is one of the more um popular ones and so essentially Selenium uses WebDriver but it builds a whole bunch of tooling around that from right up kind of running these these automated services and scripts so. In it, you can kind of automate everything about the browser, um, you can do testing, um, you can even act, you know, do administrative functions and stuff, um. You know, all of that kind of thing can be all automated uh with with the browser and so you basically just drive the browser, um, so if you as a tester say oh I want the user to do this, I want to load up the web page I want them to wait two seconds. I want them to click on this part of the screen. I want them to type this into this text field. I want to do this sort of thing and it, it's actually doing it in the browser, right? So it's not, it's not testing. It's not tests against the JavaScript code it's actually uh as if the browser is, you know, a real person is doing these actions so it's happening within sort of the environment of the browser, uh, with all of the other external browser activities sort of present so it's a bit more of like a real uh real environment, um, and so for this you can do all kinds of things. I mean anything you want really, but you could. Uh, you know, automate things like, you know, some kind of unintentional behavior. The user accidentally does something that you don't want them to do, um, bad things, try to automate security attacks and see if that works, that all that kind of stuff, um. So, uh, it was developed, um, I mean, part of the, the issue with, um. You know, doing testing, um, with a, um. With a a single page application as this dynamic generation is that you need to, um, allow it to sort of drive in and interact directly with with the DOM and and and do that sort of thing. So, um. And it's not like you can just automate and write tests that make requests to a server, pull the data and try to like, you know, um. You know, handle like static, uh, resources you need to build an environment that at best stimulates, you know, how a user is actually gonna act in the in the real world and for a single page application, the application state itself is like evolving right over over time, um. So, the web driver part, it's built into the browser. Um, so in order to do this, you do need a relatively up to-date browser. It's, it is a lot harder to test older browsers in this way. Um, so Effectively, you have some kind of structure like this where you have your browser application, um, and there's the web server back end. So this is the bit you guys have been working on. Um, but then you would write some kind of selenium commands, and they can be written in any language you want. It could be Java.net, Python, whatever you want, um, and they interact, you know, so you write your tests over here and it just interacts with the browser and and does stuff and then the browser just acts as if no different than if the user was using the application is interacting with the the web server, um, and then you get to see how it works, um. So So this bit here, um, you know, if you go into the documentation, like if you can write commands in some other language and interface with a browser. And and different browsers implement that web driver API then effectively you can create scripts that will automate against all different kinds of browsers, you know, browsers at every different version number, uh, you know, and, and so on and so forth, um, and so there's this quote, um, from the Selenium website it's kind of long, but you know if you read through it all, um. You know, they're they're basically saying um that. Um, That when you when you test your program you can't just test JavaScript um and the JavaScript code to see how that's behaving and that it works the way you expect you have to you have to test the JavaScript in an environment that also contains the DOM or the document object model, um, because the implementation of the DOM is gonna be different in different browsers, so you need to have, you need to test against that, you know, wider context, um, and so. Uh, you know, basically, I mean what they're saying here is that like, um, you know, there's every browser has different quirks and differences and so on and so forth so that the implication of this big long quote is essentially just that you have to automate your test on multiple, you know, different browsers, um, not just, uh, one browser. So what does it look like? Well, you write some code, um, kind of looks like this. It's declarative. It's somewhat similar to some of the testing that we've saw, uh, in the first semester, um, uh, for the, the API, uh, testing, um, but you know, essentially you create, um, a web driver builder and then you define what kind of browser you want it to be for, um. And then you just start to take actions, right? So in this action in this case is gonna say I wanna get I'm, I'm uh I'm a user in the web page and so I wanna get a web page that's sort of like putting that into the URL bar and and getting it. I wait for the results of that that and based on that I'm going to look for an element. Then send keys says that's basically a uh a command that says I want to send a keyboard entry so I want to act as if I'm a user typing in University of Canterbury and then the return key then I want to wait um for until the title of the, you know, of the page that I'm in has changed to be equal to this, um. And so on. So, so you can, you can essentially just simulate any kind of user activity, uh, you can imagine, including with like pauses and, and all of that sort of thing. And then you can, you can inspect the state of the browser as you're kind of going through it. Um. So that's kind of what I was talking about here, but yeah, effectively it's, it's all done with um with promises you can build that in this, but you could actually write this in other languages as well. I mean this is written in uh JavaScript uh to show you in a language that is kind of you should be familiar with, but you could write the tests in, in, uh, Python, for example. Um, so you can do all kinds of things, you can fetch a web page. So you know you can so what's different about this from testing internal to one application is you could in fact write tests that go, you know, select one page, you know, select a link, go to another web page, and you know, so it, it can combine different pages together and so on, um, you can locate elements in the DM as needed. You can get text values you can simulate user input. You can actually move between Windows and frames, uh, in, in the browser, you can interact with pop-up dialogues, um. All of the navigation and history is available, the cookies, um, the drag you can even do like drag and drop features so like, you know, for example, you have an application where you might drag something, you know, from, you know, into a box, um, all that kind of stuff can be simulated, um, so it's, it's pretty powerful what you can do with that. Um, so you get, you know, you basically get the page and then you can locate your element. Um, and you could see that it kind of matches in some ways how the JavaScript code works for finding elements. Um, instead of get element by ID and JavaScript, um, you know, it says find element and then it has this by ID then you pass in the ID. Um So, so that's sort of just the basic selenium, but then of course they've got one, extensions to this that will let you is to kind of create like a server for, um, if you, if you wanna have some kind of um continuous integration um system where say you're pushing code and you wanna test across a whole suite of systems like even across like, you know, different operating systems like maybe you wanna run. Against a Windows, Linux and Mac, and you have different browsers, um, then you can have you write your code for your tests and then Selenium server has this thing called a control er a remote control server which will then pass the tests across all of the different like. Bunch of VMs and all of those VMs might be running different, um, operating systems, different environments you, you run your application so you could shove this all into a continuous, uh, integration pipeline so you push your code and it just goes out and it runs against all these things, um. So, um, So WebDriver is the is the API that exists in the browser so you can use WebDriver without Selenium Server, um, but there's a lot of reasons why you'd want to use that server because it basically allows you to do this more robust kind of cross-platform testing so you can, you can basically, like I said, distribute your test across a bunch of VMs, um, and, and do your testing, um, and you could, um. And also, I mean, if you know you wanna just connect to some remote machine um that has a particular version you can just go in there and test with it, um, uh, directly. Um So I mean for uh obviously this would be way overkill for a project of the scope of what you've done, uh, you know, this semester, but I mean if you're if you're working on a really important web application that's gonna have millions of users using lots of different, um, uh, different platforms, then you probably do wanna look into some kind of, um, thing like this. Um, so having said all of that, I do want to just also point out that. So that's testing in the browser and we've established that testing in the browser is really important because your application is not only the JavaScript but it's how it, how it interfaces with the DOM and the DOM's implementation in the browser is gonna be different, you know, from one browser to the other. That's all really important, but then of course you can simply write tests against the JavaScript code that you've uh written as well. um, so the different JavaScript frameworks all have testing, um, utilities that are kind of developed. For the framework itself, um, but this is really JavaScript testing it's not or you know, it's testing of of the code so you can write things like unit tests against your, um, you know, particular functions or the behavior of a component or things like that. What it can't do is say, you know, test how you know if a user were to take this action in, in, um, you know, Chrome versus, uh, an edge browser it can't do anything like that, um. So, but you can run various types of unit and integration tests with that, um, so there is, there is kind of like for JavaScript there are just these kind of, uh, platform agnostic test runners that you can use. So just is, is one of the most popular ones. um, it does let you run tests, uh, with some, uh, db interaction, but, um. Yeah, so it doesn't have, it doesn't know anything about the framework, so it doesn't know necessarily know anything about the fact that you're dealing with react components versus I don't know some other kinds of component or it's just, it's just testing as JavaScript, but then RA itself also has a testing library that's kind of specific to writing tests against components that's kind of informed by understanding things, you know, so like if you wanna test things around hooks and effects and all of that sort of stuff, um, you can look at that. Um, So the RAC test library looks kind of like this, um, you're right, I mean all of these testing libraries kind of use a declarative type of way of describing the tests that act as if, you know, it's describing some behavior, um, but you know, in the rag testing library, you'd write a test, you would say what the test does, um, and you can see that it can actually, um. Render a component in JSX, um, so that's gonna be very different than a kind of a generic JavaScript testing, uh, tool, um, but then you can. Do things like I want to fire a click event. On an element and the way I'm gonna do that is I'm going to take what's in my screen, uh, space and get a particular element, uh, that matches this text, um. So it gets that, uh, element and then it's gonna fire a click event on that so it's what it's gonna do is essentially uh be equivalent doing an on click event um within React, uh, and then you know that's, um, as synchronous so, um, you can put in a weight, um. For it's where you wait for something to happen, um, so you want to say find, you know, a heading, um, and you wait for that, um, and then, then you can put it in your test, um, essentially assertions, you know, I expect, you know, that, um, the heading is going to have the text content of hello there, and I expect the button, some button to be deceived, something like that. And so this all is built into, you know, it's very specific, uh, for, for React, um, but all their JavaScript frameworks all have similar kinds of, of testing libraries for them. Um, Yeah, and so all of this stuff is good to do, um, you know, if you're, if you're wanting to build unit tests, integration tests, and all this sort of thing, uh, in your application, um. All right, that's really it. That was the last topic, um, and any questions about that or? About anything really about the final exam or anything that we covered all semester. Um Nope. OK, so, like I said, the exam is on June 11th, uh, at 2:30. I think that's correct. Double check your timetable though, don't take my word for it. Um. So as a mix of short answer like I said, including sort of interpreting code and not not writing like full code but you know might be like saying, you know, put, you know what enter some line like what would be some lines of code um that you would put in here to make this happen or something like that um. It's gonna be in the CSSC computer labs. I'm not sure which one, I'm sure that will be sort of all in the timetable. Um, I'll be around, um, Steven will also be around when the tech staff whenever we do kind of lab tests, uh, around, but I won't necessarily be in the room during the exam, but I'll be around in case there's any issues or concerns, but essentially. It's gonna run as a a learned quiz, so you'll go into a an environment, um, that's kind of uh a lab environment where you won't have anything but the browser and you can go to the learn page um and you can, you know, go into a quiz and that's the final exam. Um, all right, well, uh, yeah, a question. Uh During the break, oh yeah, yeah, yeah, I'll be around, yeah, so if you send an email with me, that's fine. In fact, I'll probably respond more quickly to emails during this, during this thing because I'll have, I'm assuming I'll have fewer of them than I have had during the semester, but maybe, maybe that's incorrect. Um, All right, cool. Well, thanks everybody. I hope you enjoyed the class um and uh. Yeah, if you are around next year, I teach a, um, a distributed web programming class. It's a, you know, a bit more advanced, but if you're say you're if you're a software engineering course, you might, I mean as a student, you might wanna, uh, think about it, but that's, that's the course where we dig into things like web assembly and so on, and the, the structure is a bit more open ended because it's a 400 level class and you know the projects are less prescribed and, and so on. All right, thanks a lot.

SPEAKER 0
OK.

SPEAKER 3
All right. Uh, it's graphic or test, uh, included in the test. And it's a graphic graphic that's section included in the test.

SPEAKER 1
The no sequel, I mean the graphic, the graphic QL. Oh graph QL. Oh yes, yes. Um, there may be one question about that, but it

SPEAKER 3
would just, uh, I mean we don't cover all that

SPEAKER 1
much so it's just maybe just if I include a question I haven't site then it would just be sort of like comparing about like sort of um how, how does a graphQL request look different from an HTTP request so something similar to what I talk about in the in the in the lecture yeah yeah. Oh hey Oh, OK, it was about like a ratio

SPEAKER 4
for example, you know, with the topic you just like what would be normally be the multiple choice like around 20% of the short 1 to 2.

SPEAKER 1
I don't know. I don't know off the top of my head. I, I can't, I mean, it's, I, I, I think. There's only there there's not that many bigger questions. I mean they're all I'd say they're they're, they're more or less the same. There's just a couple of them that are real short and a couple of them that are maybe a bit longer, but they're not, it's not like wildly different, you know, in terms of what are they. OK, I have to run over to the labs because I wanna, are you doing the lab testing or yeah,

SPEAKER 2
oh yeah, oh, Friday, yeah, yeah.

SPEAKER 1
Sure, yeah, yeah, I don't know which one's yours.

SPEAKER 2
We took 03 Oh right, yeah, OK. Of course, of course it was, yeah, yeah, yeah, yeah, alright, well, yeah, I. That's true. It does in some ways, uh, feed off of it last year and we do that, but then like it's really helpful to do this, I was much the same or next semester.

SPEAKER 1
Yeah, I mean, I, I, so I might change the labs around and decide it a bit. I, I have to, I still have some work to do preparing it, but I used to teach it at the 400 level class where we had projects that were very much open ended. So essentially there was just certain levels of requirements and then people had to kind of, they needed to have certain types of features, but they could they build whatever type of application they wanted and people really liked that, um, and then. When I was turning into 300 level class, I was giving a, you know, like too that you have to make it very like specific and stuff, but I don't know if people like that as much. I'm not sure like whether what what people think, but I, I, yeah, if you have any feedback about that about 3 about 303 about what could make it better.

SPEAKER 2
It was good Yeah, OK, yeah, especially with the, the one that we can choose like the, the, yeah, yeah,

SPEAKER 1
for the second part, yeah, I think, I think actually what might be helpful is in the first term to maybe have two smaller things or you know, kind of something to build you up, you know, rather than, yeah

SPEAKER 2
yeah yeah yeah.

SPEAKER 5
But like I, we just play and then a huge uh project like I feel like at at that time

SPEAKER 1
it's a project because I like a very small intro

SPEAKER 5
like you build a basic app, you know, so you

SPEAKER 1
just get all the pieces together and you learn how to create a couple of, you know, an interface and some things and then. You do a few more things and then the last

SPEAKER 2
stepping stone and then it's easier to understand because I remember last year was huge thing about launch it and. Oh my god, yeah, that's it's like probably a bit too early.

SPEAKER 1
Oh well, I hope you still enjoying it right, yeah,

SPEAKER 2
yeah, I'll see you on Friday, I guess.

SPEAKER 0
The Yes. That That's Uh Not expecting a huge turnout today.

SPEAKER 6
Imagine most people will be studying. Don't worry, this won't take long. It's the last bit of content.



